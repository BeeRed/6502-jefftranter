; This source code was entered from the original scanned PDF. Changes
; were made to get it to build with the A65 assembler. Minor typos and
; formatting issues were corrected. It appears to generate the same code
; as in the original document, but I have not tested it.
;
; Jeff Tranter <tranter@pobox.com>
;
;************************************************************************
;
;                        OS-65D V3.2 DISASSEMBLY
;                                   by
;                          Software Consultants
;                            7053 Rose Trail
;                           Memphis, TN 38134
;                             (901) 377-3503
;
;
; This document is not from any official source, but was done using the
; "brute force method". That is, starting with the small amount of data
; released by 051, each routine was painstakingly traced and decoded by
; hand. Great care was taken to insure accuracy throughout, however, if
; you do find any errors or omissions, please let us know. We will then
; forward all such corrections to all purchasers.
;
; In several places within this listing you will find comments which are
; less than complimentary to 0SI. This was not done with the intent of
; belittling the original authors of 05-65D, but strictly to inform all
; readers of the shortcomings as well as the virtues of this operating
; system. If anyone feels we have been overly critical, we apologize.
;
; If any of your friends asks you to allow them to make a copy of this
; document, please ask them to first read the following.
;
; Software Consultants is a professional software house specializing in
; OSI compatible products. We are in business to make a profit, just as
; all businesses are. The OS-65D disassembly represents over 500 manhours
; of research, compilation, and editing. The price was set as low as was
; possible while still allowing us a reasonable profit. If we are denied
; this reasonable profit by large numbers of people making pirate copies
; then we will not be able to continue working on other products for OSI
; equipment. You may save yourself a few, dollars, but you will also be
; jeopardizing one of the very limited number of sources of high quality
;
; COPYRIGHT 1980 by Software Consultants.
; All rights reserved.
;
; GENERAL INFORMATION
; -------------------
;
; One of the most frustrating features of using Ohio Scientific
; equipment is the almost total lack of useable documentation.
; OS-65D is supposed to be a "developmental" operating system, which
; implies that the user can develop his own machine language programs
; and tie them into the OS. Obviously this is not the case or this
; document would never have come into existence.
;
; We originally broke the OS not as a money making project, but to
; enable us to tie our own machine language programs into the OS, and
; to give us the information necessary to make modifications that suit
; our needs. Once completed, we felt others attempting to use this OS
; could use this information to the same advantage that we have. Of
; course, the profit motive was also a deciding factor.
;
; We assume that anyone using this document is thoroughly familiar with
; the workings of OS-65D V3.2 and is also a competent 6502 assembler
; programmer. Every effort has been made to make each routine within
; the OS as clear as possible. However, this is a reference manual,
; not a textbook.
;
; We suggest that upon first reading this document you simply scan
; through and read all comments rather than attempt to absorb the entire
; thing at one reading. Then you may go back and read the actual code
; after first getting a feel for the contents and flow of the OS.
;
; This manual was intentionally printed on just one side of the paper to
; allow you to put your own notes on the facing pages. In particular, if
; you make changes to the OS, note each change in the listing along with
; it's purpose and the date made. If you will do your documentation as
; if you were going to be struck with amnesia tomorrow, it will truly
; make your life easier.
;
; Following the listing of the OS itself is a complete cross reference
; showing the locations where each label is used. The location where
; the label is defined is marked with an asterisk. This should prove
; invaluable in both tracing logic and in assuring yourself that any
; changes made will not have any undesired side effects.
;
; Our intention in the preparation of this manual was to make it as
; useful as possible to you, the purchaser. If after careful study of
; the listing, you still have unanswered questions about the workings
; of OS-65D, write us and we will attempt to answer your questions
;
; Happy computing!
;

       .PAGE OS65D V3.2 DISASSEMBLY
       .ORG $2200

; INITIALIZATION ROUTINE
;
; THIS IS THE ENTRY POINT WHEN THE SYSTEM IS BOOTED.
; THE CODE FROM $2200 TO $22FF IS OVERLAYED BY BASIC WHEN IT IS CALLED.
;
        LDA #1
        JSR PATCH0      SET SECTOR # AND STEP RATE
        JSR SETTK       MOVE TO TRACK 1
        LDA #$2A
        STA MEMHI       SET HI MEM ADDR
        JSR LDHEAD      LOAD HEAD
        STX MEMLO       SET LOW MEM ADDR TO 0
        JSR READDK      READ TK 1 INTO $2A00
        JSR UNLDHD      UNLOAD HEAD
        STX PTRPIA+1
        STX PTRPIA      CLEAR PRINTER PIA (X=0)
        STX PTRPIA+3
        DEX             X=FF
        STX KPORT+1     SET KEYBOARD SOUND GENERATOR TO
;                       LOWEST FREQUENCY (192.753 HZ)
;                       THEN TURN IT OFF @ $228F!!!
        STX PTRPIA+2    SET PRINTER PIA
        LDA UART+6
        STX UART+5      SET SERIAL PORT
        LDA #4
        STA PTRPIA+1    PRINTER AGAIN
        STA PTRPIA+3
        STY FLOPIN+1    RESET DISK (Y=0)
        LDY #$40
        STY FLOPIN
        STA FLOPIN+1
        LDA #1
        JSR SETDRV      SET DRIVE TO 1
        LDA #3
        STY TERMAC      RESET TERMINAL ACIA
        LDY #$11
        STY TERMAC      SET TERMINAL ACIA
        LDX #$1E
CLRX16  STA X16ACI,X    SET CA-10X 16 WAY SERIAL BOARD
        TYA             (IF ADDRESSED @ $CF00)
        STA X16ACI,X
        LDA #3
        DEX
        DEX
        BPL CLRX16
        LDX #8          CLEAR VIDEO SCREEN
        LDA #$D0
        STA MEMHI
        LDY #0
        STY MEMLO
        LDA #$20
CLRVID  STA (MEMLO),Y
        INY
        BNE CLRVID
        INC MEMHI
        DEX
        BNE CLRVID
        STX PAGE0       X = 0
;
; WE ORIGINALLY THOUGHT THE ABOVE INSTRUCTION WAS USED FOR A
; FOR A PURPOSE WE HAVE NEVER SEEN DOCUMENTED. WHEN BASIC IS RUN
; IT PUTS A JUMP AT $0000 TO $0474 (4C 74 04).THIS JUMP WILL TAKE
; YOU TO THE COMMAND MODE. IF YOU RESET THE SYSTEM WHILE BASIC
; IS RUNNING AND DO NOT WISH TO LOSE THE PROGRAM IN MEMORY, ALL YOU
; HAVE TO DO IS TO JUMP TO $0000 FROM THE MONITOR. I.E. TYPE M THEN
; L012E0000RG FOR A SERIAL SYSTEM OR .0000G FOR A VIDEO SYSTEM.
; ANOTHER TIME WHEN THIS IS USEFUL IS WHEN BASIC IS AT AN INPUT
; STATEMENT AND YOU DO NOT WANT TO CONTINUE THE PROGRAM. SINCE YOU
; CANNOT USE CONTROL C AT AN INPUT STATEMENT, JUST RESET AND DO THE
; ABOVE. WE SUSPECTED THE PURPOSE OF THIS INSTRUCTION WAS TO
; PREVENT DOING JUST THIS IF THE RESET IS HIT, THEN D, THEN RESET
; AGAIN BEFORE BASIC HAS BOOTED. ACTUALLY THAT IS NOT THE REASON,
; BUT SINCE THIS IS A USEFUL PIECE OF INFORMATION, WE PUT IT IN
; ANYWAY. THE REASON $00 IS SET TO 0 IS AS A FLAG FOR BASIC TO
; KNOW WHETHER OR NOT TO SWAP PAGE 0 AND 1 (SEE $2D50).
;
; MEMTST : HIGHEST MEMORY TEST ROUTINE
;
; THIS ROUTINE CHECKS FOR THE HIGHEST AVAILABLE MEMORY PAGE.
; IT STARTS WITH THE PAGE @ $BF00 AND MOVES DOWN IN STEPS OF ONE
; PAGE UNTIL IT FINDS MEMORY. A WORD OF CAUTION. IF YOU HAVE LESS
; THAN 48K AND INTEND TO USE SOME OF THE UPPER ADDRESS SPACE FOR
; HARDWARE, THEN THE STARTING PAGE ADDRESS @ $2277 SHOULD BE MODIFIED
; OR THE MEMORY TEST MAY DO STRANGE THINGS TO YOUR DEVICE.
;
MEMTST  LDY #$BF        START TEST @ $BF00
        JSR MEMCHK      TEST THIS PAGE
        BEQ HMFND       IF SO, FOUND MEMORY
        DEY             TRY NEXT PAGE
        BNE MEMTST+2    ALWAYS JUMP BACK
HMFND   STY HIMEM       STORE HIGHEST MEMORY PAGE
        LDX #1          CHECK FOR SERIAL OR VIDEO
        LDA $F01        (EITHER 65-A OR 65-V PROM)
        BEQ *+1
        INX             IF VIDEO SET X=2
        STX DEFDEV      STORE DEFAULT DEVICE
; THE DEFAULT DEVICE ABOVE IS PICKED UP BY BEXEC* AND PUT INTO THE
; INPUT & OUTPUT DISTRIBUTOR BYTES. THIS IS THE REASON THAT THE
; BASIC STARTUP MESSAGE IS NOT PRINTED ON BOOTING THE SYSTEM, SINCE
; THE OUTPUT DISTRIBUTOR ON DISK IS $00, WHICH DOES NOT OUTPUT TO
; ANYTHING.
        NOP
        LDX #1          SET VIDEO TO 64 CHAR/LINE
;                       TURN OFF SOUND GENERATOR, COLOR
        STX VIDSIZ
        JMP GOBAS       SKIP OVER UNUSED CODE!
;
;$2297-$22B2 IS UNUSED CODE
;
        CPX $F022
        CLC
        LDY #$D7
        JSR MEMCHK
        BNE $22B3
        LDY #0
        LDX $22C7,Y
        BEQ $22B3
        INY
        LDA $22C7,Y
        STA VIDOUT,X
        INY
        BNE $22A4
GOBAS   JMP BASIC       LOAD AND EXECUTE BASIC
;
; THE JUMP ABOVE IS TO THE SAME ROUTINE USED WITH THE 'BA'
; COMMAND. YET 'BEXEC*' IS RUN ONLY WHEN THE SYSTEM IS BOOTED.
; THE METHOD USED TO DO THIS IS REALLY QUITE ELEGANT. THE INPUT
; DISTRIBUTOR ON DISK IS SET FOR MEMORY INPUT, WHILE THE MEMORY
; INPUT POINTER ON DISK POINTS TO $2E25. THIS IS WITHIN THE OS
; INPUT BUFFER. AND WHAT IS AT $2E25 ON DISK? WHY, 'RUN BEXEC* (CR)',
; OF COURSE. THEN WHEN 'BEXEC.' RUNS, IT SETS THE INPUT AND OUTPUT
; DISTRIBUTORS FROM THE DEFAULT DEVICE (SEE NOTE @ $228B), SO THE
; NEXT TIME THE 'BA' COMMAND IS EXECUTED, 'BEXEC*' IS NOT RUN.
;
; THIS PATCH ADDED FOR ADAPTIVE STEP RATE
PATCH0  STA SECTNM      SET SECTOR TO 1
        LDX #$08
        STX STEPRT      STEP RATE
        RTS
;
; $22C7 THRU $22EB IS A TABLE USED BY THE UNUSED ROUTINE @$2297.
;
; MEMCHK : MEMORY CHECK SUBROUTINE. CALLED @ $2278
;
; THERE MUST BE SOME REASON TO ONLY CHECK THE LOWEST SIX BITS OF
; THE BYTE UNDER TEST, BUT WE SURE CAN'T THINK OF ONE!
;
MEMCHK  STY MEMHI       POINT TO PAGE UNDER TEST
        LDA (MEMLO),Y   GET A BYTE FROM THAT PAGE
        AND #$3F        KILL HIGHEST 2 BITS (?!)
        EOR #$3F        INVERT ALL REMAINING BITS
        STA (MEMLO),Y   PUT HASHED BYTE BACK
        STA TS2         AND SAVE IT
        LDA (MEMLO),Y   GET BYTE BACK FROM MEMORY
        AND #$3F        KILL HIGHEST 2 BITS
        CMP TS2         IS IT THE SAME?
        RTS             EXIT WITH EQL FLAG SET

; OS-65D V3.2 (NMHZ)
;
; ZERO PAGE LOCATIONS USED BY OS
;
PAGE0   =   $0000       BASE OF PAGE ZERO
TS1     =   $E0         TEMPORARY STORAGE
OSIBAD  =   $00E1       OS INPUT BUFFER ADDRESS
STROAD  =   $00E3       ADDRESS USED BY STROUT ROUTINE
HSTTK   =   $00E5       HIGHEST TRACK NUMBER OF FILE
TKNHLD  =   $00EE       TRACK NUMBER HOLD
STEPRT  =   S00EF       STEP RATE FOR DISK
SCTRTY  =   S00F5       SECTOR RETRY COUNT
WRTRTY  =   $00F6       WRITE RETRY COUNT
RDRTYM  =   $00F7       READ VERIFICATION RETRY COUNT
;                       AFTER MOVING HEAD (3)
;                       NOT USED ON VERIFY AFTER DISK WRITE
RDRTYN  =   $00F8       READ VERIFICATION RETRY COUNT
;                       WITHOUT MOVING HEAD (7)
; ON READ, TOTAL RETRIES BEFORE AN ERROR = RDRTYN * RDRTYM (21)
SCTBYP  =   $00F9       SECTORS BYPASSED COUNTER
SCTLEN  =   $00FA       SECTOR LENGTH IN PAGES
SCTNUM  =   $00FB       SECTOR NUMBER
STKADR  =   $00FC       STACK ADDRESS
TS2     =   $00FD       TEMPORARY STORAGE
MEMLO   =   S00FE       INDIRECT MEMORY ADDRESS, LOW
MEMHI   =   $00FF       "        "      "      , HI
;
; OTHER MEMORY ADDRESSES REFERRED TO 8Y THE OS
; ALL EXCEPT THOSE MARKED WITH AN ASTERISK ARE PART OF AN INSTRUCTION
; AND THEREFORE ARE CASES OF SELF-MODIFYING CODE.
; DURING THE LISTING, ANY ADDRESS WHICH IS MODIFIED IS DENOTED BY
; TWO ASTERISKS (**) IN THE PLACE OF AN ADDRESS.
;
STACK   =   $0100       * BASE OF STACK (PAGE 1)
SWAP4A  =   $0213       * 4 BYTES SWAPPED DURING POLLED
;                       KEYBOARD ROUTINE
STASM   =   S1300       * COLD START FOR ASSEMBLER
RTASM   =   $1303       * RESTART ASSEMBLER ENTRY POINT
STEM    =   $1700       * COLD START FOR EXTENDED MONITOR
;                       THERE IS NO RESTART POINT
RTBAS   =   $20C4       * RESTART BASIC ENTRY POINT
STBAS   =   $20E4       * COLD START FOR BASIC
X_HOLD  =   $235F       X REGISTER HOLD
Y_HOLD  =   $2361       Y REGISTER HOLD
A_HOLD  =   $2363       ACCUMULATOR HOLD
IOOFS   =   $2378       VECTORED I/O OFFSET
MINADR  =   $238A       MEMORY INPUT ADDRESS
MOTADR  =   $2391       "     OUTPUT "
D1IADR  =   $23AC       DISK 1 BUFFER INPUT ADDRESS
D1OADR  =   $23C3       "    " "     OUTPUT "
D2IADR  =   $23FD       "    2 "      INPUT "
D2OADR  =   $2416       "    " "     OUTPUT "
VOTOFS  =   $25A4       VIDEO OUTPUT LINE OFFSET
VLP1    =   $262B       VIDEO LINE POINTER DURING SCROLL
VLP2    =   $262E       "     "    "       "      "
VLOSAV  =   $2639       OFFSET SAVE
NMHZ    =   $267B       NMHZ VARIABLE
;                       $31=1MHZ, $62=2MHZ
;                       WE CAN NOT FIND WHERE THIS IS
;                       SET, PROBABLY IN BASIC.
DEFDEV  =   $2AC6       DEFAULT I/O DEVICE (SET @ $2288)
BUFOFS  =   $2CE5       OS BUFFER OFFSET
MAXBUF  =   $2CED       MAXIMUM SIZE OF OS BUFFER
PLINE   =   $D700       * PRINT LINE FOR 549 VIDEO
;
; FLOPPY DISK PIA (MC6B21)
;
FLOPIN =   $C000        FLOPPY DISK STATUS PORT
;
; BIT FUNCTION
; --- --------
;  0  DRIVE 0 READY (0 IF READY)
;  1  TRACK 0 (0 IF AT TRACK 0)
;  2  FAULT (0 IF FAULT)
;  4  DRIVE 1 READY (0 IF READY)
;  5  WRITE PROTECT (0 IF WRITE PROTECT)
;  6  DRIVE SELECT (1 = A OR C, B = B OR D)
;  7  INDEX (0 IF AT INDEX HOLE)
;
FLOPOT  =   $C002       FLOPPY DISK CONTROL PORT
;
; BIT FUNCTION
; --- --------
;  0  WRITE ENABLE (0 ALLOWS WRITING)
;  1  ERASE ENABLE (0 ALLOWS ERASING)
;     ERASE ENABLE IS ON 200us AFTER WRITE IS ON
;     ERASE ENABLE IS OFF 530us AFTER WRITE IS OFF
;  2  STEP BIT : INDICATES DIRECTION OF STEP (WAIT 10 us FIRST)
;     0 INDICATES STEP TOWARD 76
;     1 INDICATES STEP TOWARD 0
;  3  STEP (TRANSITION FROM 1 TO 0)
;     MUST HOLD AT LEAST 10 us, MIN 8us BETWEEN
;  4  FAULT RESET (0 RESETS)
;  5  SIDE SELECT (1 = A OR B, 0 = C OR D)
;  6  LOW CURRENT (0 FOR TRKS 43-76, 1 FOR TRKS 0-42)
;  7  HEAD LOAD (0 TO LOAD: MUST WAIT 40ms AFTER)
;
; FLOPPY DISK ACIA (MC6850)
;
ACIA    =   $C010       DISK CONTROLLER ACIA STATUS PORT
ACIAIO  =   $C011       "    "          "    I/O    "
;
; OTHER HARDWARE ADDRESSES
;
X16ACI  =   $CF00       NORMAL BASE ADDRESS OF CA10X BOARD
VIDSIZ  =   $DE00       VIDEO SIZE (1 = 64 CHAR, B = 32)
KPORT   =   $DF00       POLLED KEYBOARD PORT
PTRPIA  =   $FD00       PARALLEL PRINTER PIA (MC6821)
UART    =   $FB00       430 BOARD SERIAL PORT (S1883)
TERMAC  =   $FC00       SERIAL TERMINAL ACIA STATUS PORT
TERMIO  =   $FC01       "      "        "    I/O    "
KPOLL   =   $FD000      POLLED KEYBOARD ROUTINE (ROM)
;
; THE ACIAS AT $CFXX AND $FC00 ARE ALL MC6850'S

; START OF RESIDENT OS MEMORY AREA
;
HIMEM   =   $2300       HIGHEST MEMORY PAGE ADDRESS
;                       SET @$2280
;
; I/O DISPATCH TABLE (ADDRESS = ACTUAL ADDRESS - 1)
; ROUTINES ARE CALLED BY PUSHING THE ADDRESS ON
; THE STACK AND DOING AN RTS.
;
; INPUT DISPATCH TABLE
;
IOTABL  .WORD TERMIN-1  TERMINAL (ACIA): BASIC DEVICE 1
        .WORD KBINP-1   PDLLED KEYBOARD: BASIC DEVICE 2
        .WORD SERINP-1  SERIAL (UART): BASIC DEVICE 3
        .WORD NULLIN-1  NULL: BASIC DEVICE 4
        .WORD MEMIN-1   MEMORY: BASIC DEVICE 5
        .WORD DK1IN-1   DISK1: BASIC DEVICE 6
        .WORD DK2IN-1   DISK2: BASIC DEVICE 7
        .WORD X16INP-1  CA10X: BASIC DEVICE 8
;
; OUTPUT DISPATCH TABLE
;
        .WORD TERMOT-1  TERMINAL (ACIA): BASIC DEVICE 1
        .WORD VIDOUT-1  540 VIDEO: BASIC DEVICE 2
        .WORD SEROUT-1  SERIAL (UART): BASIC DEVICE 3
        .WORD PTROUT-1  PARALLEL PRINTER: BASIC DEVICE 4
        .WORD MEMOT-1   MEMORY: BASIC DEVICE 5
        .WORD DK10UT-1  DISK1: BASIC DEVICE 6
        .WORD DK20UT-1  DISK2: BASIC DEVICE 7
        .WORD X160UT-1  CA10X: BASIC DEVICE 8
;
; GENERAL STORAGE AREA
;
INDST   = *             INPUT DISTRIBUTOR
OUTDST  = *             OUTPUT DISTRIBUTOR
X16DEV  = *             CA10X DEVICE # * 2 (0-1E)
RNDSED  = *             RANDOM NUMBER SEED
KPDO    = *             KEY PRESSED DURING OUTPUT
D1BFLO  = *+2           DISK1 BUFFER LOW ADDRESS
DIBFHI  = *+2           DISK1 BUFFER HI ADDRESS
D1FRST  = *             DISK1 FIRST TRACK
D1LAST  = *             DISK1 LAST TRACK
D1CRTK  = *             DISK1 CURRENT TRACK
D1BFDR  = *             DISK1 BUFFER 'DIRTY' FLAG
D2BFLO  = *+2           DISK2 BUFFER LOW ADDRESS
D2BFHI  = *+2           DISK2 BUFFER HI ADDRESS
D2FRST  = *             DISK2 FIRST TRACK
D2LAST  = *             DISK2 LAST TRACK
D2CRTK  = *             DISK2 CURRENT TRACK
D2BFDR  = *             DISK2 BUFFER 'DIRTY' FLAG
;
; START OF ACTUAL CODE
;
; INPUT/OUTPUT ROUTINES
;
IN1     JMP INPUT       USED BY INECHO @$2340
;
; DOINP : DO VECTORED INPUT BASED ON VALUE IN INDST
;
; (SEE NOTE AT #2CD6)
; THE OS-65D MANUAL SAYS THAT INPUT IS DONE FROM THE LOWEST SET
; DEVICE & ALL OTHERS ARE IGNORED. WRONG!!! IF MORE THAN ONE BIT
; IS SET IN INDST, THINGS REALLY GO CRAZY. TRY ENTERING "1O ,11"
; (OR "IO 12" FOR A VIDEO SYSTEM) AT "A*" AND WATCH THE RESULTS.
;
DOINP   LDY #$00        SET FOR INPUT
        LDA INDST       GET INPUT DISTRIBUTOR
        BNE DOIO        GO DO INPUT
;
; INECHO : INPUT & ECHO. ALSO CHECKS FOR CONTROL CHARACTERS.
;
INECHO  JSR IN1         INPUT AND ECHO
;                       THIS SHOULD HAVE BEEN
;                       JSR INPUT. WHY THEY DID IT
;                       THIS WAY WE DON'T KNOW.
;
; PRINT ROUTINE : OUTPUT TO ALL ACTIVE DEVICES
; OUTPUT CHARACTER IN A
;
PRINT   JSR SAVAXY      SAVE ALL REGISTERS
        LDA OUTDST      GET OUTPUT DISTRIBUTOR
        LDY #$10        DENOTES OUTPUT
;
; DO I/O, EITHER INPUT OR OUTPUT BASED ON VALUE IN Y
;
DOIO    LDX #$FF        SET INDEX TO DETERMINE DEVICE
        BNE PATCH1      GO TO PATCH FOR I/O OFFSET
        INX
        LSR A           CHECK FOR I/O BIT ON
        BCC DONXIO      ($235C) BRANCH IF NOT
        PHA             SAVE REST OF I/O DIST BYTE
        TXA             AND DEVICE NUMBER FOUND
        PHA             I/O DEVICE NOW IN A
        JSR IODISP      GO DO I/O
        PLA             RESTORE A AND X
        TAX
        PLA
DONXIO  BNE DOIO+4      ($234F) IF ANY BITS STILL ON
;
; RSTAXY : RESTORE A,X,Y (USED AFTER SAVAXY)
; WARNING! THIS ROUTINE MASKS OUT THE UPPER BIT IN A
;
RSTAXY  LDX **          RESET X
        LDY **          RESET Y
        LDA **          RESET A
        AND #$7F        KILL UPPER BIT IN A
        RTS             BACK WE GO
;
; SAVE A,X,Y FOR LATER
;
SAVAXY  STA A_HOLD      SAVE A
        STY Y_HOLD      SAVE Y
        STX X_HOLD      SAVE X
        RTS
;
; PATCH TO SET I/O OFFSET
;
PATCHI  STY IOOFS       STORE I/O OFFSET
        BNE DOIO+4      ($234F) GO BACK
;
; IODISP : I/O DISPATCH ROUTINE
;
IODISP  ASL A           MULTIPLY I/O DEVICE BY 2
        ADC **          I/O OFFSET (0=INPUT $10=OUTPUT)
        TAX             GET SET TO GET I/O ADDRESS
        LDA IOTABL+1,X  GET HI BYTE
        PHA             PUSH ON STACK
        LDA IOTABL,X    GET THE LOW BYTE
        PHA             PUSH ON STACK
        LDA A_HOLD      RESTORE A FOR OUTPUT
        RTS             JUMP TO ROUTINE
;
; NULLIN: NULL INPUT ROUTINE (BASIC DEVICE 4)
;
; WHILE THE NULL INPUT ROUTINE IN ITSELF IS NOT THAT USEFUL,
; SINCE IT IS 3 BYTES LONG IT COULD BE USED AS A JUMP TO A
; USER DEFINED INPUT ROUTINE.
;
NULLIN  LDA #400
        RTS
;.
; MEMIN : INPUT FROM MEMORY ROUTINE (BASIC DEVICE 5)
; THIS ROUTINE IS ALSO USED FOR THE INDIRECT FILE FUNCTION.
;
MEMIN   LDA **          GET BYTE FROM MEMORY
;                       MODIFIED BY COMINC
        LDX #$000       SET OFFSET
        BEQ COMINC      GO TO COMMON INCREMENT ROUTINE
;
; MEMOT : MEMORY OUTPUT ROUTINE (BASIC DEVICE 5)
; THIS ROUTINE IS ALSO USED BY THE INDIRECT FILE FUNCTION.
;
MEMOT   STA **          PUT BYTE IN MEMORY
;                       MODIFIED BY COMINC
        LDX #$07        SET OFFSET
;
; COM INC : COMMON INCREMENT ROUTINE
; THE FOLLOWING ROUTINE IS USED BY THE DISK 1 AND 2 INPUT
; AND OUTPUT ROUTINES AS WELL AS THE MEMORY INPUT AND OUTPUT
; ROUTINES. THIS IS AN EXTREME CASE OF SELF MODIFING CODE WHICH
; SHOULD NORMALLY BE AVOIDED. X IS USED AS THE INDEX
; AND IS SET BY EACH INDIVIDUAL ROUTINE BEFORE CALLING THIS ROUTINE.
;
COMINC  STA A_HOLD      SAVE A
        INC MINADR,X    INCREMENT MEMORY ADDRESS
        BNE *+5         ($23A0)
        INC MINADR+1,X
        RTS
;
; DK1IN : DISK 1 INPUT ROUTINE (BASIC DEVICE 6)
;
DKIIN   LDY #$00        SET Y OFFSET
        JSR CKBFEN-2    CHECK FOR END OF BUFFER
        BNE *+5         ($23AB) IF NOT END OF BUFFER, CONT
        JSR DK1NXT      READ NEXT TRACK
        LDA **          LOAD BYTE (MODIFIED BY COMINC)
        LDX #$22        SET THE OFFSET
        BNE COMINC      GO USE COMMON INCREMENT HOUTINE
;
; DKIOUT : DISK 1 OUTPUT ROUTINE (BASIC DEVICE 6)
;
; THIS ROUTINE WILL ALLOW YOU TO PRINT ANY CHARACTERS TO DISK EXCEPT
; A LINE FEED ($0A). SOMETIMES IT IS USEFUL TO BE ABLE TO WRITE A
; LINE FEED TO DISK, I.E. CREATING A WORD PROCESSOR OR ASSEMBLER
; FILE WITH BASIC. IF YOU WISH TO DO SO, YOU CAN CHANGE THE FOURTH
; BYTE OF EITHER DISK OUTPUT ROUTINE TO A NULL (HEX 0). JUST BE SURE
; YOU DON'T DO A "NORMAL" WRITE TO DISK WHILE THE CHANGE IS IN EFFECT
; OR THE CARRIAGE RETURN WILL BE FOLLOWED BY A LINE FEED.
;
DKI0UT  CMP #$0A        IF LINE FEED THEN RETURN
        BEQ DK1IN-1     ($23A0)
        PHA             SAVE BYTE TO BE WRI'£TEN
        LDY #$17        SET Y FOR OFFSET
        JSR CKBFEN-2    CHECK FOR END OF BUFFER
        BNE *+5         ($23C1) CONTINUE IF NOT AT END
        JSR DK1NXT      WRITE THIS TRACK, READ NEXT
        PLA             RESTORE THE OUTPUT BYTE
        STA **          PUT IN BUFFER (MODIFIED BY COMINC)
        LDX #$39        SET OFFSET FOR COMMON INCREMENT
        STX D1BFDR      SET BUFFER DIRTY FLAG
        BNE COMINC      BRANCH TO COMMON INCREMENT
;
; DKINXT : DISK 1 NEXT TRACK READ, USED BY DK1IN AND DK1OUT
;
DKINXT  LDA D1BFDR      GET BUFFER 'DIRTY' FLAG
        BEQ *+7         ($2306) IF NOT 'DIRTY' CONTINUE
        LDX #$00        SET OFFSET
        JSR WTDKBF      GOSUB TO WRITE DISK BUFFER
        LDA D1BFLO      RESET READ/WRITE ADDRESS
        STA D1IADR      AND MEMORY ADDRESS TO START
        STA D10ADR      OF DISK BUFFER
        STA MEMLO
        LDA D1BFLO+1
        STA D1IADR+1
        STA D1OADR+1
        STA MEMHI
        LDX #$00        SET OFFSET
        BEQ BDRDNX      ALWAYS BRANCH
;
; DK2IN : DISK 2 INPUT ROUTINE (BASIC DEVICE 7)
;
DK2IN   LDX #$08        SET OFFSETS
        LDY #$51
        JSR CKBFEN      CHECK FOR END OF BUFFER
        BNE *+5         ($23FC) IF NOT END, CONTINUE
        JSR DK2NXT      WRITE THIS BUFFER, READ NEXT
        LDA **          LOAD BYTE FROM BUFFER
;                       MODIFIED BY COMINC
        LDX #$73        SET OFFSET
        BNE COMINC      BRANCH TO COMMON INCREMENT
;
; DK20UT : DISK 2 OUTPUT ROUTINE (BASIC DEVICE 7)
; SEE NOTE @$23B2 ABOUT LINE FEED
DK20UT  CMP #$0A        IF LINE FEED THEN RETURN
        BEQ $2476
        PHA             SAVE BYTE TO BE WRITTEN
        LDX #$08        SET OFFSETS
        LDY #$6A
        JSR CKBFEN      CHECK FOR END OF BUFFER
        BNE *+5         ($2414) IF NOT END THEN CONTINUE
        JSR DK2NXT      WRITE BUFFER, READ NEXT TRACK
        PLA             GET BYTE TO BE WRITTEN
        STA **          PUT IN BUFFER (MODIFIED BY COMINC)
        LDX #$8C        SET OFFSET FOR COMINC
        STX D2BFDR      SET BUFFER 'DIRTY' FLAG
        JMP COMINC      DO INCREMENT FOR POINTER
;
; DK2NXT : DISK 2 NEXT TRACK READ, USED BY DK2IN AND DK20UT
;
DK2NXT  LDA D2BFDR      GET BUFFER 'DIRTY' FLAG
        BEQ *+7         ($242A) CONTINUE IF NOT 'DIRTY'
        LDX #$08        SET OFFSET
        JSR WTDKBF      GO WRITE THIS BUFFER
        LDA D2BFLO      RESET READ/WRITE ADDRESSES
        STA D2IADR      AND MEMORY ADDRESS TO
        STA D2OADR      START OF BUFFER
        STA MEMLO
        LDA D2BFLO+1
        STA D2IADR+1
        STA D2OADR+1
        STA MEMHI
        LDX #$08        SET OFFSET
;
; THE NEXT GROUP OF ROUTINES ARE USED BY BOTH DISK 1 & DISK 2
; X IS SET TO 0 FOR DISK 1 AND TO 8 FOR DISK 2.
;
; BDRDNX : BUFFERED DISK I/O READ NEXT TRACK
;
BDRDNX  LDA DICRTK,X    GET CURRENT TRACK NUMBER
        CLC             GET SET TO ADD 1 TO CURRENT TRACK
        SED             SET DECIMAL (TRACK# IN BCD)
        ADC #$01        DO THE ADD
        CLD             CLEAR DECIMAL MODE
        STA D1CRTK,X    SAVE THE TRACK NUMBER
        JSR BDMHTK      MOVE HEAD TO TRACK
        JMP CALL+12     ($2B1D) READ DISK, UNLOAD HEAD
;                       AND RETURN
;
; BDMHTK : : BUFFERED DISK I/O MOVE HEAD TO TRACK
;
BDMHTK  LDA #$00        CLEAR BUFFER 'DIRTY' FLAG
        STA D1BFDR,X
        LDA D1CRTK,X    COMPARE CURRENT TRACK
        CMP D1LAST,X    WITH LAST TRACK
        JSR INCTKN+10   ($2C8D) MOVE HEAD TO TRACK, IF
;                       PAST END OF FILE, ERROR D
        INY             SET Y TO 1
        BNE PATCH2      ALWAYS BRANCH TO PATCH2
        BRK             (NOT USED)
        BRK             (NOT USED)
;
        LDX #$00        SET OFFSET
;                       USED BY DK1IN AND DK1OUT
;
; CKBFEN : CHECK FOR END OF BUFFER
;
CKBFEN  LDA D1IADR,Y    LOW ADDRESS OF BYTE TO BE READ
        CMP D1BFHI,X    LOW ADDRESS OF END OF BUFFER
        BNE *+8         ($2476) IF NOT THE SAME THEN RETURN
        LDA DQIADR+1,Y  HI ADDRESS OF BYTE TO BE READ
        CMP D1BFHI+1,X  HI ADDRESS OF END OF BUFFER
        RTS             RETURN WITH Z FLAG SET IF END
;
; WTDKBF : WRITE DISK BUFFER
;
WTDK8F  LDA D1BFHI+1,X  HI ADDR OF BUFFER HI ADDR
        SEC
        SBC D1BFLO+1,X  HI ADDR OF BUFFER LOW ADDR
        STA PGCNT       NUMBER OF PAGES
        LDA D1BFLO,X    SET MEMORY ADDRESS TO LOW
        STA MEMLO       BUFFER ADDRESS
        LDA D1BFLO+1,X
        STA MEMHI
        JSR BDMHTK      MOVE HEAD TO TRACK
        JMP DSKWRT      WRITE TO DISK AND RETURN
;
; PATCH2 (FROM $2462)
;
PATCH2  STY SECTNM      SET SECTOR NUMBER TO 1
        JMP LDHEAD      LOAD HEAD AND RETURN
;
; MODMIN : MODIFY MEMORY INPUT ADDRESS
;
; THIS ROUTINE IS USED ONLY BY THE INPUT FROM INDIRECT FILE
; FUNCTION (CTRL X). IF YOU WANT TO CHANGE THE LOCATION OF
; THE INDIRECT FILE, YOU MUST CHANGE THE ADDRESS HERE AND IN
; THE ROUTINE @$2551.
;
MODMIN  LDA #$80        HIGH ADDRESS FOR INDIRECT FILE
        STA MINADR+1    SAVE IT
        LDA #$00        LOW ADDRESS OF INDIRECT FILE
        RTS
;
; PTROUT : PARALLEL PRINTER OUTPUT DEVICE (BASIC DEVICE 4)
;
; NOTE: SOME OF THE NEWER PRINTERS ON THE MARKET ARE EQUIPPED WITH
; GRAPHICS AND NEED THE FULL 8 BITS OF AN OUTPUT BYTE TO USE
; THIS FEATURE. CHANGING THE INSTRUCTION AT $24A7 AND $24A8 TO
; NOP'S ($EA) WILL ALLOW THIS.
;
PTROUT  PHA             SAVE BYTE TO BE PRINTED
        LDA PTRPIA      CHECK PIA STATUS REGISTER
        LSR A
        BCS PTROUT+1    ($24A0) NOT CLEAR, KEEP WAITING
        PLA             RESTORE THE OUTPUT BYTE
        AND #$7F        KILL THE UPPER BIT
        STA PTRPIA+2    OUTPUT THE BYTE
        LDA PTRPIA+$20  STROBE THE BYTE TO THE PRINTER
        RTS
;
; BEFORE USING EITHER OF THE CA10X ROUTINES, THE PORT NUMBER MUST
; BE SET IN X16DEV ($2323)
;
; X16INP : CA10X INPUT ROUTINE (BASIC DEVICE 8)
;
X16INP  LDX X16DEV      GET ACIA DEVICE#
        LDA X16ACI,X    GET ACIA STATUS REGISTER
        LSR A           SHIFT STATUS BIT TO CARRY
        BCC X16INP      TRY AGAIN IF NOT READY
        BCS PATCH3      ($2508) GO TO PATCH3 TO INPUT
        BRK             (NOT USED)
        BRK             (NOT USED)
;
; X16OUT : CA10X OUTPUT ROUTINE (BASIC DEVICE 8)
X160UT  PHA             SAVE THE OUTPUT BYTE
        LDX X16DEV      GET THE CURRENT DEVICE NUMBER
        LDA X16ACI,X    GET THE STATUS REGISTER
        LSR A
        LSR A
        BCC X16OUT+1    ($24BE) IF NOT READY, TRY AGAIN
        PLA             GET THE BYTE TO BE OUTPUT
        STA X16ACI+1,X  WRITE IT
        RTS
;
; TERMOT : TERMINAL OUTPUT ROUTINE (BASIC DEVICE 1)
;
TERMOT  PHA             SAVE THE BYTE TO OUTPUT
        LDA TERMAC      GET THE ACIA STATUS
        LSR A
        LSR A
        BCC TERMOT+1    ($24CE) IF NOT READY, TRY AGAIN
        PLA             GET THE BYTE TO PRINT
        STA TERMIO      OUTPUT IT
        PHA             SAVE IT AGAIN
        LDA TERMAC      GET THE STATUS AGAIN
        LSR A           CHECK FOR INPUT READY
        BCC TORTN       NO KEY PRESSED, GO BACK
        JSR TERMIN      INPUT A CHARACTER
        STA KPDO        SAVE IT
        CMP #$13        CONTROL S?
        BNE TORTN       NO, GO BACK
        JSR TERMIN      YES, INPUT A BYTE
        CMP #$11        CONTROL Q?
        BNE *-5         ($24EA) NO, TRY AGAIN
TORTN   PLA             RESTORE THE OUTPUT BYTE
        STA A_HOLD      SAVE IT
        RTS
;
; TERMIN : SERIAL TERMINAL INPUT ROUTINE (BASIC DEVICE 1)
TERMIN  LDA TERMAC      GET ACIA STATUS
        INC RNDSED      BUMP THE RANDOM SEED
        LSR A           CHECK RCV READY
        BCC TERMIN      IF NOT TRY AGAIN
        LDA TERMIO      INPUT THE BYTE
        AND #$7F        KILL THE UPPER BIT
        STA A_HOLD      SAVE THE CHARACTER
        RTS
;
; PATCH3 : ADDED TO X16INP ROUTINE (FROM $24B9)
;
PATCH3  LDA X16ACI+1,X  GET BYTE FROM ACIA
        BCS TIRTN       PUT IN A.HOLD AND RETURN
;
; SEROUT : 430 BOARD UART OUTPUT (BASIC DEVICE 3)
;
SEROUT  PHA             SAVE THE BYTE TO OUTPUT
        LDA UART+5      GET UART STATUS
        BPL SEROUT+1    ($250E) NOT READY, TRY AGAIN
        PLA             RESTORE THE OUTPUT CHARACTER
        STA UART+4      AND OUTPUT IT
        RTS
;
; SERINP : 430 BOARD UART INPUT (BASIC DEVICE 3)
;
SERINP  LDA UART+5      GET THE UART STATUS
        LSR A
        BCC SERINP      NOT READY, TRY AGAIN
        LDA UART+3      INPUT A BYTE
        STA UART+7      ACKNOWLEDGE INPUT
        STA A_HOLD      SAVE THE BYTE
        RTS
;
; THE FOLLOWING IS A "WHO KNOWS" INSTRUCTION
; THIS IS ANOTHER CASE OF HOW TO USE UP COMPUTER TIME
;
        JSR KIRTN       JUMP SUBROUTINE TO RTS
;
; KBINP : POLLED KEYBOARD INPUT ROUTINE (BASIC DEVICE 2)
;
; THIS ROUTINE USES THE SAME ROUTINE AS THE ROM BASED MACHINES.
; UNFORTUNATELY, THE DISK BASIC USES SOME OF THE SAME MEMORY
; LOCATIONS AS THE ROUTINE AT $FD00. INSTEAD OF DOING THE CORRECT
; THING, WRITING A NEW ROUTINE FOR THE DOS, OSI MADE ANOTHER PATCH.
; EVERY TIME YOU INPUT FROM THE 540 KEYBOARD YOU MUST FIRST SWAP
; OUT 4 BYTES, CALL THE ROUTINE IN ROM @$FD00, AND THEN RESTORE
; THE 4 BYTES. HIGHLY INEFFICIENT!
;
KBINP   JSR SWAP4       SAVE $213-$216
        INC RNDSED      BUMP THE RANDOM SEED
        JSR KPOLL       CALL THE ROUTINE IN ROM
        BEQ KBINP+3     ($252E) IF NULL THEN TRY AGAIN
;
; THIS IS ANOTHER STRANGE INSTRUCTION. THE PRESENT KEYBOARD ROUTINE
; WAITS UNTIL A KEY IS PRESSED AND THEN RETURNS IT'S ASCII VALUE.
; A NULL IS NEVER RETURNED FROM THE PRESENT KEYBOARD ROUTINE SO
; IT MAKES NO SENSE TO CHECK FOR IT.
;
        STA A_HOLD      SAVE THE INPUT CHARACTER
        JSR SWAP4       RESTORE $213-$216
        LDA A_HOLD      GET THE INPUT CHARACTER
KIRTN   RTS
;
; PATCH 4 : USED BY 540 VIDEO DRIVER FOR KEY PRESSED DURING OUTPUT
; (FROM $25F2)
;
PATCH4  STA KPDO        SAVE THE CHARACTER
        PLA
        JMP TIRTN       SAVE A AND RETURN
;
; THIS IS AN UNDOCUMENTED RE-ENTRY POINT TO THE OS. ON VIDEO SYSTEMS
; WHEN YOU EXIT TO THE MONITOR AND THEN RE-ENTER THE OS AT $2A51, YOU
; WILL NORMALLY HAVE PROBLEMS WITH THE POLLED KEYBOARD ROUTINE. BY
; ENTERING AT $2547, THE 4 BYTES FROM $0213-$0216 ARE RESTORED AND THE
; KEYBOARD ROUTINE WILL WORK CORRECTLY.
;
        JSR SWAP4       SWAP THE 4 BYTES
        JMP OS65D3      JUMP TO THE OS
;
; CKINP : CHECK INPUT FOR INDIRECT FILE COMMANDS AND CONTROL P.
;
; THE CONTROL P IS A NICE FEATURE THAT WE HAVE NEVER SEEN DOCUMENTED
; BY OSI. UNDER VERSION 3.0 IT WAS A CONTROL T, WHILE UNDER
; VERSION , 3.2 IT HAS BEEN CHANGED TO A CONTROL P. THIS CONTROL
; CHARACTER, WHICHEVER ONE IT IS, FLIP-FLOPS A FLAG THAT CONTROLS
; PRINTER OUTPUT. THE FIRST TIME THE CONTROL CHARACTER IS ENCOUNTERED
; IT TURNS ON THE PRINTER DEVICE AND THE NEXT TIME IT TURNS IT OFF.
; WARNING! SOME OF THE SOFTWARE PROVIDED ON THE SYSTEM USES THIS
; FUNCTION. WHEN USING WP2 IF YOU USE THIS FEATURE DURING OUTPUT
; THE WORD PROCESSOR TURNS IT OFF WHEN DONE. HOWEVER THE ASSEMBLER
; DOES NOT AFFECT IT AND IT REMAINS ON UNTIL THERE IS ANOTHER
; CONTROL (T/P) INPUT FROM THE KEYBOARD. THE PRINTER DEVICE BIT
; IS AT LOCATION $2592.
;
CKINP   CMP #$5B        ([) START INDIRECT FILE?
        BNE CKIFND      NO, CONTINUE
        LDA #$80        SET UPPER ADDRESS FOR INDIRECT
        STA MOTADR+1    MODIFY MEMORY OUTPUT ROUTINE
        LDA #$00        SET LOWER ADDRESS FOR INDIRECT
        STA MOTADR      MODIFY MEMORY OUTPUT ROUTINE
        LDA OUTDST
        ORA #$10        SET MEMORY OUTPUT
        BNE CKIRTN      ALWAYS BRANCH TO EXIT
CKIFND  CMP #$5D        (]) CLOSE INDIRECT FILE?
        BNE CKCTLX      NO, CONTINUE
        JSR PRINT+3     PRINT 'J', BYPASS SAVAXY
        LDA DEFDEV      I/O DEFAULT DEVICE
        STA INDST       RESET INPUT POINTER
        LDA OUTDST      GET THE PRESENT OUTPUT DEVICE(S)
        AND #$EF        TURN OFF MEMORY OUTPUT
        STA OUTDST      SAVE THE OUTPUT DISTRIBUTOR
        LDA #$5D        PUT ']' BACK IN A
CKCTLX  CMP #$18        CONTROL X? (LOAD INDIRECT FILE)
        BNE CKCTLP      NO, CONTINUE
        LDA #$10
        STA INDST       SET FOR MEMORY INPUT
        JSR MODMIN      GOSUB TO SET INPUT HIGH ADDRESS
        STA MINADR      SET INPUT LOW ADDRESS
        BCS CKIRTN+3    ($2596) ALWAYS BRANCH TO EXIT
CKCTLP  CMP #$10        IS IT CONTROL P
        BNE CKIRTN+5    ($2598) NO, JUMP TO EXIT
        LDA OUTDST      GET THE OUTPUT DISTRIBUTOR
        EOR #$08        FLIP-FLOP THE PRINTER OUTPUT
CKIRTN  STA OUTDST      SAVE THE DISTRIBUTOR
        LDA #$00        DENOTES CONTROL CHARACT£H FOUND
        RTS
;
; VIDOUT : 540 VIDEO OUTPUT ROUTINE (BASIC DEVICE 2)
;
; AS DELIVERED WITH THE SYSTEM THE 540 VIDEO DRIVER IS NOTHING
; MORE THAN A "GLASS TELETYPE" WITH NON-DESTRUCTIVE BACKSPACE
; AND FORWARD SPACE. CONSIDERING THE SOFTWARE SUPPLIED WITH OTHER
; COMPARABLE SYSTEMS, THIS IS RIDICULOUS. THE ROUTINE WILL NOT EVEN
; ALLOW YOU TO PRINT ANY OF THE OSI GRAPHICS CHARACTERS AND
; FORCES YOU TO "POKE" THEM TO THE SCREEN. ONE CHANGE THAT YOU
; COULD MAKE WOULD BE TO CHANGE YHE INSTRUCTIONS FROM $25B9 TO
; $25C0 AND $25A1,$25A2 TO NOP'S. THIS WILL ALLOW YOU TO PRINT SOME
; GRAPHICS CHARACTERS. WARNING: THIS ROUTINE IS BAD ABOUT USING
; SELF MODIFYING CODE.
;
VIDOUT  TYA             SAVE Y FOR LATER
        PHA
        LDY LCHAR       GET CHARACTER 'UNDER' CURSOR
        LDA A_HOLD      GET OUTPUT CHARACTER
        AND #$7F        STRIP TO 7 BIT ASCII
        LDX **          GET OFFSET IN PRINT LINE
        CMP #$0D        IS IT A 'CR'
        BEQ CR          YES, DO IT
        CMP #$0A        IS IT A 'LF'
        BEQ LF          YES, DO IT
        CMP #$08        BACKSPACE? (non dest cut H)
        BEQ BSPACE      YES, DO IT
        CMP #$10        IS IT CNTRL P
        BEQ CNTLP       YES, DO IT
        CMP #$0C        IS IT CNTRL L (forward space non dest)
        BEQ CNTLP       YES, DO IT
        CMP #$20        IS IT < 'SPACE'
        BMI EXIT        YES, INVALID CHARACTER
        CMP #S7B        IS IT > '{'
        BPL EXIT        YES, INVALID CHARACTER
        STA PLINE,X     OUTPUT CHARACTER TO SCREEN
        INX             BUMP LINE POINTER
        CPX #$80        LAST CHARACTER ON LINE
        BEQ SCROLL      YES, DO SCROLL
EXIT    LDY PLINE,X     GET CHAR. 'UNDER' NEW CURSOR
        STY LCHAR       SAVE IT
        LDA #$5F        GET CURSOR CHARACTER
        STA PLINE,X     OUTPUT IT
        STX VOTOFS      SAVE OFFSET
        PLA             RESTORE Y
        TAY
        LDA #$01        CHECK FOR 'CNTRL'
        BVS KTRTN       NO, WE ARE DONE
        LDA #$08        CHECK FOR 'S'
        JSR KEYTST
        BPL KTRTN       NO, WE ARE DONE
        LDA A_HOLD      RESTORE OUTPUT CHARACTER
        PHA             AND SAVE
        JSR KBINP       INPUT FROM POLLED KEYBOARD
        CMP #$13        CNTRL S?
        BEQ *-5         ($25EB) YES, KEEP LOOPING
        JMP PATCH4      EXIT THE ROUTINE
BSPACE  TYA             RESTORE CHAR. 'UNDER' CURSOR
        STA PLINE,X     PRINT IT
        DEX             BUMP LINE POINTER BACK 1
        BCS EXIT        GO BACK
CNTLP   TYA             RESTORE CHAR. 'UNDER' CURSOR
        STA PLINE,X
        INX             BUMP LINE POINTER
        BCS EXIT        EXIT THIS ROUTINE
CR      TYA             RESTORE CHAR. 'UNDER' CURSOR
        STA PLINE,X
        LDX #$40        RESET LINE POINTER
        BNE EXIT        JUMP TO EXIT
SCROLL  LDX #$40        RESET LINE POINTER
        BNE *+6         ($2613) JUMP A LITTLE
LF      TYA             RESTORE CHAR. 'UNDER' CURSOR
        STA PLINE,X
        STX VLOSAV      SAVE LINE OFFSET
        LDA #$20        SET TO CLEAR LOWER LINE
        LDX #$80        SET OFFSET
        STA PLINE,X     OUTPUT IT
        INX             BUMP THE OFFSET
        BNE *-4         ($261A) LOOP UNTIL DONE
        LDY #$CF        GET SET TO SCROLL
SETNXT  INY             FIRST TIME THROUGH Y = $D0
        STY VLP1        ADJUST LINE POINTER
        STY VLP2        ADJUST LINE POINTER
        LDA **,X        MOVE UP 1 LINE AT A TIME
        STA **,X
        INX             BUMP THE LINE POINTER
        BEQ SETNXT      IF MOVED LINE, SET FOR NEXT
        BPL MOVE        KEEP LOOPING
        CPY #$D7        HAVE WE DONE THEM ALL
        BCC MOVE        NO, KEEP LOOPING
        LDX **          RESTORE LINE OFFSET
        BNE EXIT        JUMP TO EXIT
LCHAR = *               CHARACTER 'UNDER' CURSOR
;
; KEYTST : TEST POLLED KEYBOAHD FOR KEYDOWN IN ROW IN ACCUM
;
KEYTST STA KPORT        ENABLE THE ROW
       BIT KPORT        CHECK FOR KEY DOWN
KTRTN  RTS
;
; SWAP4 : PATCH ADDED TO ENABLE USE OF POLLED KEYBOARD R0UTINE
; @$FD00. SWAPS OUT 4 BYTES FROM $213-$216 TO $2657-$265A
;
SWAP4   LDX #$03        SET INDEX FOR 4 BYTES
        LDA SWAP4A,X    SWAP A BYTE
        LDY SWAP4B,X
        STA SWAP4B,X
        TYA
        STA SWAP4A,X
        DEX
        BPL SWAP4+2     ($2646) IF ANOTHER CONTINUE
        RTS
;
SWAP4B  = *+4           SWAP AREA FOR $0213-$0216
;
; DISK DRIVER ROUTINES AND STORAGE
;
        .BYTE $20       (UNKNOWN USAGE, IF ANY)
DSKDR   = *             PRESENT DISK DRIVE
TKNUM   = *             CURRENT TRACK NUMBER
SECTNM  = *             PRESENT SECTOR NUMBER
PGCNT   = *             PAGE COUNT
LAMB    = *             LOW ADDRESS OF MEMORY BLOCK
HAMB    = *             HI ADDRESS OF MEMORY BLOCK
TRKNM   = *             HEX TRACK NUMBER
;                       NOT USED, SEE NOTE @ $26A6
;
; HOME : HOMES HEAD TO TRACK 0 ON CURRENT DISK DRIVE
;
HOME    JSR STEPOT      STEP HEAD OUT
        JSR TENMS       DELAY 10 MS
        STY TKNUM       SET TRACK# TO 0
HOLOOP  LDA #$02        CHECK FOR TRACK 0
        BIT FLOPIN
        BEQ TENMS       DELAY 10MS AND RETURN IF TR 0
        JSR STEPIN      STEP HEAD IN
        BEQ HOLOOP      LOOP BACK AND THY AGAIN
;
; TENMS : 10 MS DELAY. ACTUALLY @ 1MHZ THE DELAY IS CLOSER TO 11 MS
;
TENMS   LDX #$0C
        LDY #$31        LOOP COUNT FOR  DELAY
        JSR DELAY       DO 1 MS DELAY
        DEX
        BNE TENMS+2     ($267A) NOT DONE, KEEP ON
        RTS
;
; STEP IN : STEP TOWARDS 'TRACK 0
; MOVES EEAD ONE TRACK
STEPIN  LDA FLOPOT      TURN ON STEPIN BIT
        ORA #$04
        BNE STEP        GO STEP IN
;
; STEPOT : STEP HEAD AWAY FROM TRACK 0
; MOVES HEAD ONE THACK.
;
STEPOT  LDA #$FB        TUHN OFF STEP IN BIT
        AND FLOPOT
STEP    STA FLOPOT
        JSR STEPIN-1    ($2682) KILLS 12 CLOCK CYCLES
        AND #$F7        TURN OFF STEP BIT
        JSR SETFLO      STA @ $C002 AND RETURN
        JSR DELAY+6     ($2706) KILL 14 CYCLES
        ORA #$08        TURN ON STEP BIT
        JSR SETFLO      STA @ $C002 AND RETURN
        LDX STEPRT      GET STEP RATE
        BNE TENMS+2     ($267A) DELAY STEP RATE MS
;
; (ROUTINE @ S26A6) THIS ROUTINE CONVERTS A HEX TRACK NUMBER
; AT S2662 TO BCD AND STORES IT AT $EE, THEN FALLS INTO THE SET
; TRACK ROUTINE. THE HOUTINE IS NOT USED BY THE OS, SO EITHER
; IT IS USED BY BASIC, OR IT'S LEFT OVER FROM AN OLDER VERSION.
;
CNVHTN  LDA TRKNM
        SEC
        LDX #$FF        INIT X TO COUNT 10'S
        INX
        SBC #10         SUBTRACT 10 FROM TRACK#
        BCS *-3         ($26AC) IF >=0 BUMP X AND DO AGAIN
        ADC #10         ADD BACK LAST 10 FOR REMAINDER
        STA TKNHLD      SAVE REMAINDER
        TXA             GET NUMBER OF TENS
        ASL A           SHIFT TO HIGH NIBBLE
        ASL A
        ASL A
        ASL A
        ORA TKNHLD      COMBINE WITH REMAINDER
;
; SETTK : CHECK FOR VALID TRACK NUMBER AND MOVE HEAD THERE
; TRACK NUMBER IN ACCUMULATOR
;
SETTK   STA TKNHLD      SAVE TRACK NUMBER
        PHA
        BIT $269E       CHECK FOR 8 BIT
        BEQ ERR8-2      (S26CB) IF NOT, CONTINUE
        AND #$06        CHECK FOR 4 BIT OR 2 BIT
        BNE ERR8        YES, LOW NIBBLE > 9 : ERROR 8
        PLA             RESTORE TRACK NUMBER
        CMP #$77        TRACK < 77?
        BCC MOVEHD      YES, CONTINUE
ERR8    LDA #$08        ERROR 8, BAD TRACK NUMBER
        BNE ERR5+2      (S26DE) JUMP TO ERROR HANDLER
MOVEHD  LDA  DSKDR      GET DISK DRIVE
        AND  #$01       TOP DRIVE=1, BOTTOM DRIVE=0
        TAY
        JSR CKRDY       SEE IF DRIVE IS READY
        BCC CKTK        YES, CONTINUE
ERR6    LDA #$06        DRIVE NOT READY : ERROR 6
        JMP ERRENT      JUMP TO OS ERROR ROUTINE
CKTK    LDA TKNHLD      RETRIEVE TRACK NUMBER
        CMP TKNUM       SAME AS PRESENT TRACK NUMBER?
        BEQ STCCNT      YES, DON'T MOVE THE HEAD
        BCS *+9         ($26F1) BRANCH IF > PRESENT TRACK
        JSR STEPIN      STEP HEAD IN ONE TRACK
        LDA #$99        SET TO SUBTRACT 1 FROM TKNUM
        BCC *+6         ($26F5) JUMP
        JSR STEPOT      MOVE HEAD OUT 1 TRACK
        TXA             X=1 : SET TO ADD 1 TO TKNUM
        SED
        ADC TKNUM       ADD OR SUBTRACT 1 FROM TKNUM
        STA TKNUM       AND SAVE
        CLD
        JMP CKTK        GO SEE IF WE ARE DONE
;
; DELAY : DELAY=18*Y+14 CYCLES (DELAY=896us IF Y=$C1)
;
DELAY   JSR COMINC+6    ($239B) BNE AND RTS : 14 CYCLES
        DEY
        BNE DELAY       IF NOT DONE DO IT AGAIN
        NOP
        RTS
;
; SET TRACK CODE CONTINUED FROM $26E6
;
STCCNT  CMP #$43        ARE WE PAST TRACK 42
        LDA FLOPOT
        AND #$BF        RESET LOW CURRENT BIT
        LDY #$00        WHO KNOWS?
        NOP
        BCS SETFLO      IF PAST TRACK 42, CONTINUE
        LDA #$40
        ORA FLOPOT      (PIA2) SET LOW CURRENT BIT
        STA FLOT        STORE IT
        RTS
;
; WAITIH : WAIT FOR INDEX HOLE
;
WAITIH  LDA FLOPIN      GET DISK STATUS
        BMI WAITIH      IF BIT 7 ON, GO TEST AGAIN
        LDA FLOPIN      GET DISK STATUS
        BPL *-3         ($2722) IF BIT 7 OFF, TRY AGAIN
        RTS
;
; LDHDWI : LOAD HEAD AND WAIT FOR INDEX HOLD
;
LDHDWI  JSR LDHEAD      LOAD HEAD
;
; RSACIA : RESET DISK ACIA, WAIT FOR INDEX HOLE
;
RSACIA  JSR WAITIH      WAIT FOR THE INDEX 1I0LE
        LDA #$03
        STA ACIA        MASTER RESET FOR ACIA
        LDA #$58        SET FOR /1, RTS=1, NO INTERUPT
        STA ACIA
        RTS
;
; EXAMCN : EXAM COMMAND CONTINUED , FIRST SECTION AT $2B37
;
EXAMCN  JSR LDHDWI      LOAD HEAD, WAIT FOR INDEX HOLE
        LDA FLOPIN      GET THE STATUS
        BPL UNLDHD      IF AT INDEX HOLE, UNLOAD HEAD
        LDA ACIA        GET ACIA STATUS
        LSR A
        BCC EXAMCN+3    ($273C) NOT READY, WAIT FOR INDEX
        LDA ACIAIO      READ A BYTE
        STA (MEMLO),Y   STORE IT IN MEMORY
        BNE EXAMCN+3    ($273C) IF MORE IN THIS PAGE
        INC MEMHI       BUMP MEMORY ADDRESS
        JMP EXAMCN+3    ($273C) CONTINUE
;
; LDHEAD : LOAD HEAD TO DISK
;
LDHEAD  LDA #$7F
        AND FLOPOT      SET BIT 7 TO 0
        STA FLOPOT
        LDX #$28        SET FOR 32 ms DELAY
        JMP TENMS+2
;
; UNLDHD : UNLOAD HEAD FROM DISK
;
        LDA #$80
        ORA FLOPOT      SET BIT 7 TO 1
        BNE LDHEAD+5    ($2759) JUMP
;
; INITAL : INITIALIZE ALL TRACKS (EXCEPT ZERO) ON CURRENT DRIVE
;
INITAL  LDA #$76        SET HIGHEST TRACK NUMBER
        STA HSTK
        JSR HOME        HOME THE HEAD
        JSR INCTKN      INCREMENT TRACK
        JSR INITTK      INITIALIZE THIS TRACK
        LDA TKNUM       GET CURRENT TRACK NUMBER
        CMP #$76        AT 76 YET?
        BNE INITAL+7    ($276F) NO, KEEP ON
        RTS
;
; INITTK : INITIALIZE TRACK
;
INITTK  LDA #$02
        BIT FLOPIN      CHECK FOR TRACK 0
        BNE *+6         ($2788) NO, CONTINUE
ERE3    LDA #$03        DO ERROR #3
        BNE ERR4+2      JUMP TO ERROR HANDLER
        LDA #$20
        BIT FLOPIN      CHECK FOR WRITE PROTECT
        BNE ERR4+5      ($2794) NO, CONTINUE
ERR4    LDA #$04        DO ERROR #4
        JMP ERRENT      JUMP TO ERROR HANDLER
        JSR LDHDWI      LOAD HEAD AND WAIT FOR INDEX
        LDA #$FC        GET SET TO TURN ON
        AND FLOPOT      WRITE ENABLE AND ERASE ENABLE
        STA FLOPOT
        LDX #$01        DO 1 ms DELAY
        JSR TENMS+2
        LDX #$43        TRACK START CODE BYTE1

JSR DKWTX
LDX IS57
JSR DKWTX
LDX TKNUM
JSR DKWTX
LOX .S58
JSR DKWTX
LDA FLOPIN
BMI *-3
LOA iS83
BNE UNLDHD+2
WRITE IT
THACK START CODE BYTE2
WRITE IT
GET THE TRACK NU~ISER
WRITE IT
TRACK TYPE CODE
WRITE I'f
WAIT FOR INDEX, ERASE IS ON
(S27B9) NOT YET, TRY AGAIN
TURN OFF WRITE ENABLE, ERASE
(S2763) ENABLE, UNLOAD HEAD & RET
;
; DKWTX : Iml'rE X 'fO DISK
,
27C2
27C5
27C6
27C7
27C9
27CC
AD Ie ce DKWTX
4A
4A
93 F9
8E 11 C0
60
; DSKBYT
)
LDA ACIA
LSR A
LSR A
BCC DKWTX
STX ACIAIO
RTS
GET ACIA STA'fUS
NOT READY, TRY AGAIN
WRITE X TO DISK
GET BYTE FROM DISK
27CD AD 10 CU DSKBYT LDA ACIA
LSR A
27De 4A
BCC
FA
DSKBYT
2701 90
LDA
11
ce
ACIAIO
2703 AD
RTS
27D6 60
GET ACIA STATUS
NOT READY, TRY AGAIN
READ THE BYTE
;
; THE ,'OLLOWING IS NOT USED BY THE OS. MAY BE USED BY BASIC
;
27D7 AD 60 26
27DA 85 r'E
27DC AD 61 26
27DF 95 FF
LDA LAMB
STA MEMLO
LDA HAMB
STA MEMHI
GET LOW ADDRESS OF MENORY BLOCK
SAVE AT MEMORY ADDRESS
GET HIGH ADDRESS
AND SAVE
;
DSKWRT
WRITE SECTOR TO DISK ROUTINE
;
TO USE 'fHIS ROUTINE THE HEAD Mus'r ALREADY BE POSITIONED 'fO THE
; PROPER TRACK, THE NUMBER OF PAGES TO WRITE IN PGCNT ($265F), AND
; THE SECTOR NUMBER TO WRITE IN SEC'fNM (S265E). S'fARTING
; ADDRESS OF DATA MUST BE IN MEMLO,MEMUI (SFE,SFF).
,
)
1I .
27El AD
27E4 F0
27E6 10
27E8 A9
27EA D9
27EC C9
27EE 13
27F0 A9
27F2 2C
27F5 ~'U
SF 26 DSKWRT LDA PGCNT
BEQ ERRB
e2
llPL *+6
e4
0B
ERRS
LDA #S0B
AS
BNE ERR4+2
(lE
CMP #$3E
FB
BPL ERRB
LOA 'S1l2
02
BIT FLOP IN
00 C0
OF
SEQ DSKBYT+9
GET NUMBER OF PAGES
IF 0 DO ERROR IJ
(S27EC) IF BIT 7 IS ON DO EllROR B
ERROR B ROUTIt.E
($2791) JUMP
IF)D, THEN EHROR B
TEST FOR TRACK U
(S27D6)
IF TRACK U THEN RETURNPAGl::: 26
OS650 V3.2 DISASSEMBLY
)
------- - ----------------------- - ----- ------- ---------------------------
27Jn 4A
27F8 85 FA
27FA A9 20
C0
27FC 2C
27FF 00 04
28D1 A9 04
281'l3 DO E5
2805 A9 01
281'l7 85 F6
REWRT
2809 A9 03
281lB 85 F8
2800 20 C4 28
2810 20 9F 2B
2813 A9 FE
2815 20 1'l2 CO
2818 8D 112 C0
2B1B A2 02
281D 20 A2 28
2820 A9 FO
2822 20 02 C0
2825 80 02 C~
2828 20 9F 28
282B A2 76
2820 20 C2 27
2830 AE 5E 26
2833 20 C2 27
2836 AE 5F 26
2839 86 FO
283B 20 C2 27
283£ A0 00
WRTPG
2841) Bl FE
2842 AA
2843 21'1 C2 27
2846 C8
2847 00 F7
2849 £6 FF
284B cr, FO
2840 00 F1
284F A2 47
""
)
LSR A
STI\ SCTLEN
LOA IS20
BIT "LOPIN
BNE *+6
LOA IS04
BNE DSKWRT+8
LOA lSi'll
STA WRTRTY
LDA .S03
STA RDRTYN
JSR SETSCT
JSR DLYFA
LOAISFE
AND FLoPo'r
STA FLOPOT
LOX IS02
JSR IIUNOUS
LOA '$FO
AND FLOPOT
STA FLOPOT
JSR OLn'A
LOX 1$76
JSR OKWTX
LOX SECTNM
JSR OKWTX
LOX PGCNT
STX TS2
JSR DKWTX
LOY 1 $llIl
LOA MEMLO,Y
TAX
JSR OKWTX
INY
BNE WHTaG
INC MEMIII
DEC 'rS2
BNE WRTPG
LOX 1$47
;
2851 20 C2 27
2854 A2 53
JSR DK\,/TX
LOX 1$53
;
)
2856 20 C2 27
2859 AD SF 26
285C 0A
2850 85 FO
285F 0A
286~ 65 PO
2862 AA
2863 20 A2 28
2866 1\0 02 C0
2869 09 01
JSR OKWTX
LDA PGCNT
ASL A
S1'A 'fS2
ASL A
AOC TS2
TAX
JSR HUNOUS
LOA FLO POT
ORA IS01
PUT 1 IN SECTOR LENGTH
TEST ~'OR WRITE PROTECT
(S2805) NOT WRITE PROTECT, CONT~IIUE
WRITE PROTECT IS 011, ERROR 4
(S27EA) JUMP
SET RETRY COUNT
READ VERIFICATION RETHY COUNT
POSITION TO START OF SECTOR
DO 81l0us DELAY (SCTLEII = 1)
SET WRITE ENABLE
DELAY
20~us
TURN ON ERASE eNABLE
ANOTIIER 800us OELI\Y
WRITE SEc'rOH S'I'AHT COOl::
GET SECTOR NUMBEH
WRI'rE IT
Gr:T THE PAGE COUNT
SAVE IT
WRITE PAGE COUNT
SET INDEX
WRITE PAGE OF MEMOHY 'ro DISK
WHITE TO DISK
($2840) No'r DONE, LOOP BACK
BUMP IIIGH MEMOHY ADDHESS
DROP PAGE COUNT
IF ANOTHEH PAGE THEN CONTINUE
WRITE ' G' TO DISK
(SECTOR START CODE)
WRITE ' S' TO DISK
(SECTOR STAllT CODE)
GET PI\G~; COUNT
MULTIPLY BY 2
SAVE IT
MULTIPLY BY 2 AGAIN
ADD TOGETHEH, = 6*PAGE COUNT
10~us
'rUR,~
DELAY· PAGE COUNT
OFF \~HITE
~;NABLE
~i
i
I,
I
OS65D Vl.2
5TA fLOPOT
286B aD 02 CIl
LDX #$05
286E A2 05
JSR
HUNDUS
2870 2(1 A2 28
LDA
#$02
2873 A9 02
JSH SETPLO-3
2875 20 16 27
RTYCMP
CLC
2878 18
TXA
2879 8A
ADC MEMHI
287A 65 PP
SEC
287C 38
;
287D ED Sf 26
2880 85 FP
2882 20 07 29
SBC PGCN'l"
STA MEMHI
JSR RDCDSK
DISA55EM~LY
5~0us
PAGE: 27
DELAY
($2716) TURN OFF ERASE ENABLE
ADD X TO HIGH MEMORY ADDRESS
x-a FIRST TIME WE COMPARE
X-I OF SECTORS NOT COMPARED
IF THIS IS A RETRY
HESEt HIGH MEMORY ADDRESS
COMPARE DATA WRItTEN TO DISK
;
; I"IARIIING! IF WRI'fE STARTED FROM PAGE 0, ABOVE ROUTINE WILL
; READ FROM DISK INSTEAD OF COMPARE.
·•
)
2885 B0 28
2887 C6 F8
2889 D0 ED
288B C6 F6
2880 30 0C
288F 8A
2890 65 FF
2892 38
2893 ED SF 26
2896 85 FF
2898 4C 09 28
289B A9 H2
ERR2
289D D0 22
BCS DKBT9-1
DEC RDRTYN
BNE HTYCMP
DEC WRTRTY
BMI ERR2
TXA
ADC MEMHI
SEC
SBC PGCNT
5TA MEMHI
JMP REWRT
LDA #$02
BNE ERR9+2
($28AF) NO fAULT SO RETURN
DROP COMPAnE HETR'l COUNT
IF NOT H THEN TRY AGAIN
DROP WRITE RETRY COUNT
IF DONE THEN ERHOR 12
RESET MEMOHY ADDRESS
WRITE 'ro DISK AGAIN
ERROR #2
($28Cl) ALWAYS JUMP
;
; DLYFA : 800us DELAY TIMES VALUE IN SCTLf;N ($FA)
•
289F 2U 56 29 DLYFA
,
JSll DLYFAI
GO COMPUTE VALUE FOH X
; HUNDUS : APPROXIMATELY 100us DtLA'l PER X
;
28A2 AD 78 26 HUNDUS LDA NMHZ
28A5 24 00
BIT PAGE0
28A7 38
SEC
28A8 E9 05
SBC 11$05
28AA B0 F9
BCS HUNDUS+3
28AC CA
DEX
28AD D0 F3
BNE HUNDUS
28AF 60
HT 5
GET DELAY COUNT
KILl. 3 CYCLES
SUBTHACT 5 FROM DELAY COUNT
($28A5) IF )-r. THEN DO AGAIll
DO X TIMES
;
; DKBT9 : GET KYTE FROM DISK, EHHOH
,
28BO AD 00 C0 DKBT9
28B3 10 OA
);
LDA FLOPIN
BPL ERR9
~9
IF INDEX HOLE
GET DISK STATUS
IF INDEX HOLE THEN EHROR 1 9
; WARNING: 52884 IS MODIFIED BY THE 09 COMMAND 0 $ 2823
;OS65D V3.2 DISASSEMBLY
PAGE: 28
-----------------------------------------------------------------------
)
LOA ACIA
LSR A
BCC DKBT9
LOA ACIAIO
RTS
LOA 1$119
JMP ERRENT
28B5 AD 10 CII
28B8 4.0.
28B9 90 F5
28BB AD 11 CII
28BE 60
28Bt' A9 119
ERR9
28C1 4C 4B 2.0.
CHECK ACIA STA'fUS
NOT READY, KEEP LOOKING
GET BYTE FROM DISK
ERROR .9, CAN'T FIND SECTOR
;
; SETSCT : SETUP FOR SECTOR IN SECTNM
.
,
)
SETSC'f LOA 1$05
28C4 .0.9 05
STA SCTRTY
28C6 85 F5
JSR RSACIA
28C8 211 213 27
JSR DKBT9
28CB 20 Bil 2B
CMP I'C 4~
28CE C9 43
BNE *-5
28011 Oil F9
' JSR .DKBT9
2802 211 Be 28
CMP I ·'w S.,
2805 C9 57
BNE *-9
F5
2807 00
t31l
28
JSR
DKBT9
2809 20
EOR
TKNHLD
EE
280C 45
BEQ SSOK
28DE Fi! liB
115
ERRS
2BE!! .0.9
LDA '$115
DEC SCTRTY
28E2 C6 F5
BPL SEEKRT
28E4 lI1J 61
CMP
$0AA9
28E6 CD .0.9 0.0. ERRA
SET RETRY COUNT
WAIT FOR INDEX HOLE
GET FIRS'f BYTE FR0f4 DISK
CHECK FOR TRACK START CODE
($28C8r IF .NOT 'C' TRY AGAIN
GET SECOND BYTE FROM DIS~
CHECK FOR TRACK START CODE
($28CE) IF NOT 'w· THEN CHECK FOR 'C'
GET ANOTHER BYTE FROM DISK
IS THIS THE RIGHT TRACK?
YES, CONTINUE
SET FOR ERROR 15, SEEK ERROR
BUT FIRST CHECK RETRY COUNT
FLIP SEEK RATE AND TRY AGAIN
;
;
;
;
;
;
I
;
I
;
;
;
;
;
;
;
THE INSTRUCTION AT $28E6 IS AN OLD ASSEMBLER PROGRAMMING TRICK
THAT SHOULD NORMALLY BE AVOIDED BECAUSE OF THE DANGERS INVOLVED.
THIS IS A PRIME EXAMPLE OF MISUSE. THE TRICK IS TO TAKE A TWO
BYTE INSTRUCTION; IN THIS CASE, LOA 1$0.0. (.0.9 0.0.); AND ADD A BYTE
TO THE FRONT WHICH CREATES A "HARMLESS" THREE BYTE INSTRUCTION.
THEN YOU CAN FALL THROUGH FROM PRECEEDING CODE WITH NO EFFECT, OR
BRANCH TO THE SECOND BYTE OF THIS INSTRUCTION FOR A DIFFERENT
Et'FECT, AS IS · DONE AT $28FC. 'fIllS ALLOWS REPORTING AN ERROR IS
ON FALL THROUGH, OR ERROR A WHEN ENTERING AT $2BE7. THE RATIONALE
FOR USING THIS TRICK IS TO SAVE ONE LOUSY BYTE OF CODE. THE DANGER
IS THAT QUITE OFTEN THE "HARMLESS· THREE BYTE INSTRUCTION CAN CAUSE
CONSIDERABLE HARM. SUCH IS THE CASE HERE. SINCE OSI CHOSE TO USE A
CMPINSTRUCTION, IF THE VALUE AT $0AA9 IS EQUAL TO 5, THE TEST AT
$28E9 WILL FAIL AND THE PROGRAM WILL FALL INTO THE CODE USED WHEN
Til ERE IS .NO SEEK ERROR. ALSO $F9 WILL BE INITrALlZEO TO 5 INSTEAD
OF 0. ANOTHER ERROR, SUCH AS ERROR A, WILL PROBABLY OCCUR, BUT TO
US PROBAt3LY IS NOT NEARLY GOOD ENOUGH.
;
)
BNE ERR9+2
STA SCTBYP
JSR DKBT9
LOA SECTNM
SBC 1$91
BEQ RDCDSK-1
PHA
JSR BPSECT
28£9 00 D6
2BEB B5 F9
SSOK
28 ED 20 B0 28
2BF'" AD 5E 25
28F3 E9 01
2BF5 t"" OF
28F7 48
28F8 20 98 29
(S2BC1) GO REPORT ERROR 5 (OR A)
SET SECTORS BYPASSED TO "
GET FIRS'f BYTE FROM SEC'fOR
GET SECTOR NUMBER
SUBTRACT 1
($29"6) RETURN IF WANT SECTOR 1
SAVE SECTORS TO SKIP
SKIP A SECTOR
,
- - -..• _-- .. ..
---- ~-----I
I
I
,
0565D V3.2 DISASSEMBLY
!
) 28FB 68
28FC 90
28FE C5
2900 00
2902 C5
PLA
BCC $28E7
CMP SCTBYP
BNE *-9
CMP SCTNUM
E9
F9
F5
FB
;
29~4
29~6
00 El
60
BNE $28E7
RTS
PAGE: 29
GET BACK SECTORS TO SKIP
IF CARRY CLEAR, ERROR A
HAVE WE SKIPPED ENOUGH?
($28F7) NO, CONTINUE
SECTOR NUMBER JUST SKIPPED
SET @$29A4
IF NOT RIGHT ONE, ERROR A
;
; RDCDSKREAD (OR COMPARE)FROM DISK, THIS TRACK INTO MEMORY @($FE)
29D7 48RDCDSK PIIA, SAVE READ/COMPAHE FLAG
( II=READ)
POSITION HEAD
GET BYTE FROM DISK
IS IT A SECTOR S'fART CODE?
($290B) NO, TRY AGAIN
GET ANOTHER BYTE
IS THIS THE RIGHT SECTOR?
($2910) YES, CONTINUE
IF NOT, RETURN WITH CARRY
CLEAR AS FAULT FLAG
,
;
2908 20 C4
290B 211 BII
290E C9 76
2910 011 F9
2912 20 B0
2915 CD 5E
2918 FIl 03
291A 68
JSR SETSCT
JSR DKBT9
CMP '$76
BNE *-5
JSR DKBT9
CMP SECTNM
SEQ *+5
PLA
28
28
28
26
;
291B 18
291C 60
)
SETc'F '
CLC
RTS
;910 20 B0 28
JSR DKS'£9
TAX
2920 AA
2921 80 5F 26
STA PGCNT
2924 A0 110
LOY '$00
2926 68
PLA
ADC I$FE
2927 69 FE
RDCONT LOA 1$111
2929 A9 01
BIT ACIA
292B 2C 10 C0
BEQ *-3
292E FII FB
LOA ACIAIO
29311 AD 11 C0
BVS SETFF
2933 70 E6
BCC *+6
2935 90 114
CMP (MEMLO), Y
2937 01 FE
BNE SETFF
2939 00 E0
STA (MEMLO), Y
293B 91 FE
2930 C8
INY
BNE HDCONT
293E Oil E9
INC MENHI
2940 E6 FF
2942 CA
DEX
2943 00 E4
BNE HDCDNT
2945 38
SEC
RTS
2946 fie
GET SECTOR LENGTH FROM DISK
PUT PAGE COUNT IN X
STORE SECTOR LENGTH
SET Y FOR INDEXING
RESTORE READ/COMPARE FLAG
FORCE CARRY FLAG IF COMPARE
CHECK ACIA READY AND PARITY
($292B) IF NOT, TRY AGAIN
GET BYTE FROM ACIA,
PARITY ERROR, RETURN
($293B) CARRY CLEAH, THIS IS A READ
COMPARE TO BYTE IN MEMOHY
IF NOT THE SAME, ERROR
STORE BYTE IN ~lEMORY
BUMP THE,INDEX
H' MORE THIS PAGE, CONTINUE
SET ADDRESS FOil NEXT PAGE
DROP PAGE COUNT
IF ANOTHER PAGE, CONTINUE
SET CARRY AS NO FAULT FLAG
,
; SEEKRT
,
)
2947 A5 EF
2949 49 OE
294B 85 EF
SEEK RETHY
HOUTIN~
rOH ADAPTIVE STEP RATE
SEEKRT LDA STEPRT
EOR 3S0E
STA STEPRT
GET CURHENT STEP RATE
CHANGE 8 TO 6 Oil 6 TO 8
STORE NEW STEP RATEOS65D V3.2 DISASSEMBLY
)
294D 211 63 26
29511 20 D1 26
2953 4C C8 28
JSR HOME
JSR MOVEHD
JMP SE'fSCT+4
PAGE: 30
.''10VE HEAD TO TRACK 0
GO MOVE HEAD TO PROPER TRACK
AND TRY FOR SECTOR AGAIN
;
; DLYFA1 : COMPUTE 8 TIMES VALUE IN SCTLEN. USED BY DLYFA @ $289F
;
2956 A5 FA
2958 0A
2959 0A
295A IlA
295B AA
295C 60
DLYFA1 LOA SCTLEN
ASL A
ASL A
ASL A
TAX
RTS
GET SECTOR LENGTH
MULTIPLY BY EIGHT
PUT IN X (FOR HUNDUS)
;
; SET MEMORY ADDRESS POINTER 'fO DISK BUFFER ADDRESS
; NOT USED BY OS.
·
,
295D AD
2960 85
2962 AD
2965 85
,·
60 26
FE
61 26
FF
LOA LAMB
STA MEMLO
LDA HAMB
STA MEMIII
; READDK : READ DISK, THIS 'fRACK INTO MEMORY @($FE)
,·
2967 A9
2969 85
) 296B A9
296D 85
296F A9
2971 20
2974 9~
2976 60
READDK LDA 0$03
03
F7
STA RDRTYM
07
LDA #$07
F8
STA RDRTYN
RTYRD LDA 1$00
00
JSR RDCDSK
07 29
04
BCC DKRDRY+3
RTS
SET RETRY COUNT IvHEN HEAD MOVED
SET RETRY COUNT WIO MOVING HEAD
DENOTES READ
l~EAD SECTOR INTO NEMORY
($297A) IF FAULT OCCURED, RETRY
;
; DKHDHY : DISK READ RETRY
;
2977 C6 FF
DKRDRY DEC MEMHI
2979 E8
INX
297A EC 5F 26
CPX PGCNT
297D De F8
BNE DKRDRY
297F C6 F8
DEC RDRTYN
BNE RTYRD
2981 D0 EC
JSR STEPIN
2983 20 83 26
2986 20 78 26
JSR TENMS
JSR STEPO'f
2989 20 8A 26
298C 20 78 26
JSR TENMS
298F C6 F7
DEC RDRTYN
2991 10 D8
BPL READDK+4
2993 A9 131
ERR1
LDA '$01
2995 4C 48 2A
JMP ERRENT
)
HESET MEMORY ADDRESS
NOT DONE, CONTINUE
DROP RETRY COUNT
NOT '" TRY AGAI.~ 1,/0 MOVING HEAD
STEP HEAD IN·
ams DELAY
s'n;p HEAD OUT
DROP RETRY COUNT
($296B) IF >-Il THEN TRY AGAIN
ALL RETRIES FAILED, ERROR #1
: I3PSEC'1' : BYPASS SECTOR
2998 20 B6 29 BPSECT JSR DKBTCI
299B C9 76
CMP 1$76
GET BYTE FROM DISK
SECTOR START CODE?I
I
I
I
05650 V3.2 DISASSEMBLY
.~
)
PAGE : 31
-------------- -. _-------------------------------------------------------
2990 00
299F A2
29Al 20
29A4 95
liNE IlPSECT
LOX 1$"2
JSR OKBTCI
STA SCTNUM-2,X
F9
112
B6 29
F9
:
29A6 CA
29A7 09 F8
29M E6 F9
29AB A8
29AC 211 B6 29
29AF CA
29BII 09 FA
2982 88
29B3 Oil F7
2985 611
DEX
BNE *-6
INC SCTIlYP
TAY
JSR DKBTCI
DEX
BNE *-4
DEY
BNE *-7
RTS
NO, TRY AGAIN
SET TO READ 2 IlYTES
GET IlYTE FROM DISK
STORE SECTOR NUMBER IN $FB
STORE SECTOR LENGTH IN $FA (PAGES)
($29Al) BACK FOR SECOND BYTE
BUMP SECTORS BYPASSED
SECTOR LENGTH IN PAGES
GET ANOTHER BYTE FROM DISK
($29AC) IF NOT END OF PAGE, CONTINU
($29AC)
IF MORE PAGES TO GO,
~ONTIN
I
)
: DKBTCI : GET BYTE FROM DISK, H' INDEX HOLE SEEN POP STACK AND RETURN
:
GET ACIA STATUS
29B6 AD 19 C9 DKBTCI LOA ACIA
2969 4A
LSR A
($29C3) ACIA READY, GO AHEAD
29BA B0 U7
IICS SETDRV-3
29BC AD 1')0 CO
LOA FLOPIN
'rEST FOR INDEX HOLE
BMI DKBTCI
NO, 'fRY AGAIN
29BF 39 F5
PLA
PULL LAST KNOWN RETURN ADDRESS
29Cl 68
OFF OF STACK AND RETURN
29C2 68
PLA
29C3 4C BB 28
JMP DKBT9+ 11
($28BB) LOAD BYTE AND RETURN
,.
: SETDRV : SET t'OR DIUVE IN ACCUMULATOR
I
29C6 80 5C 26 SETDRV S'fA 'rKNUM
29C9 IIA
ASL A
29CA AA
TAX
29CB 29 112
AND 1$112
29CO AS
TAY
29CE BO E9 29
LOA DKINI'r-2,x
2901 80 110 CII
STA FLOPIN
2904 BD EA 29
LOA DKlNIT-l,X
2907 80 D2 CO
STA FLOPOT
SET TRACK NUMBER
MULTI BY 2 : A=2,B~4,C-6,D·8
ISOLATE DRIVE: A=1,B c ll,C=1,D- il
INITIALIZE PIA FROM IN IT TABLE
:
: CKRDY : CHECK FOR DiuVE HEADY, RETURNS WITH CARRY CLEAR It' READY
I
)
29DA AD D~ CD CKROY
2900 4A
290£ 118
29DF CU D~
29E1 00 06
291::3 28
2934 4A
2935 4A
29E6 4A
29E7 4A
29£8 60
29E9 28
,
LOA FLOPIN
LSR A
PHP
CPY ~$00
BNE DKINIT-2
PLP
LSR A
LSR A
PUT READY BIT IN CARRY FLAG
SAVE CARRY STATUS
IF TOP DRIVE THEN RETURN
($29E9)
RESTORE STATUS
PUT BIT 4 IN CARHY
Lsn A
LSR A
RTS
PLP
RESTORE STATUSOSG5D V3.2 DISASSEMBLY
PAGE: 32
) -----------------------------------------------------------------------
~
HTS
29EA 6"
·; DISK INITIALIZATION'TABLE
•
I
29EB 41!
29EC 1'1'
29ED
29EE 1'1'
29EF 411
29'" OF
291'1
291'2 OF
DKINIT , .BYTE $40
• BYTE $1'1'
.BYTE $""
• BYTE $1'1'
.BYTE $4a
.BYTE $01'
• BYTE $""
.BYTE $01'
""
;
""
I DIRCNT
,
DRIVE A
DRIVE B
DRIVE C
DRIVE 0
. DIR COMMAND CONTINUED (FROM $2B2C)
I
PUT TRACK NUMBER IN X
• 29P3 AA
DIRCNT TAX
BEQ
DKINIT-4
($29E7) IF II THEN RETURN
" 291'4 1'1 Fl
~
291'6 48
PHA
SAVE TRACK NUMBER
JSR SETTK
~IOVE HEAD TO TRACK
~
291'7 2" BC 26
JSR STROUT
PRINT THE FOLLOWING MESSAGE
~
29FA 20 73 20
.BYTE $0D,'$IIA,"TRACK ",II
""' _ 2.9.f..Q ,J'JUIA __H ___
2A"1! 52 41 43
2A"3 4B 2" 00 '
PLA
RESTORE Tilt:: TRACK NUMBER
-) 2AII6 68
JSR PRT211X
PRINT TRACK NUMBER
2A1J7 2" 92 20
2AIIA BA
SAVE STACK ADDRESS
TSX
2AIIB 86 FC
STX STKADR
LOAD HEAD TO DISK
2A"D 20 54 27
JSR LDHEAD
2AlIIE8
INX
2All 8E 5E 26
PUT 1 IN SECTOR NUMBt::H
STX SECTNM
POSITION FOR SECTon 1
2A14 211 C4 28
JSR SETSCT
CLEAR SECTORS BYPASSED COUNT
LOA '$011
2M7 A9 ""
2A19 85 F9
STA SCTBYP
BYPASS THIS SECTOR
2AIB 20 9B 29
JSR BPSECT
LOA SCTNUM
2AIE A5 1'B
SAVE SECTOR NUMBER
2A2Cl 48
PHA
2A21 AS FA
LOA SCTLEN
2A23 48
SAVE SECTOR LENGTH
PHA
($2AIB) IF WE DIDN'T HIT THE INDEX
2A24 BI! 1'5
BCS *-9
HOLE,
TRY AGAIN
•
2A26 A6 FC
GET ORIGINAL ' STACK ADDRESS
LOX STKADR
2A28 90 I!D
BCC *+15
1$2A37) 'AND JUMP
2A2A 211 6A 20
JSR CRLF
PRINT CRILl'
2A2D A9 211
LOA '$20
PRINT SPACE AND SECTOR NUMBER
2A2F 211 41 2A
JSR DCPRNT
2A32 A9 20
LOA '$2D
PRINT - AND SECTOR LENGTH
2A34 2g 41 2A
JSR DCPRNT
2A37 C6 1'9
DEC SCTBYP
DROP SECTORS BYPASSED COUNT
2A39 III EF
BPL *-15
1$2A2A) IF MORE TO DO, CONTINUE
2A3B
AG
FC
STKADR
RESET
STACK ADDRESS
LOX
)
2A3D 9A
TXS
2A3E 4C 61 27
JMP UNLDHD
UNLOAD HEAD ·AND RETURN
2A41 2(1 43 23 DCPRNT JS,R PRINT
PRINT ACCUMULATOR
.
·
- --
- --"-------
-
- --- -- - -I
I
!
I
OS65D V3.2
DISAS 5 EM~LY
PAG~:
)
2M4 BO 00 el
2M7 CA
2MB.4C 92 20
11
I
I
)
)
LOA STACK,X
OEX
JSR PRT2HX
GET NEXT BYTE OFF STACK
GET SET FOR THE: NEXT ONE
PRINT AS 2 HEX CHAR. AND RETURN
33OS65Ll V3. 2 DISASSEMBLY
PAGE: 34
-----------------------------------------------------------------------
; ** KERNEL **
;
; ERRENT : OS ERHOR ENTRY. ERROR t IN ACCUMULATOR
,.
2A4S 20 C4 2A ERRENT JSR OSERR
2A4E 4C 51 2A
JMP **
(~4C4)
;
; I-IHILE IT MAKES LITTLE SENSE TO DO A DIREC'j' JU~IP TO THE NEXT
MEMORY LOCATION, THIS MAKES IT POSSIBLE TO ALTER 'rHE EXIT
; FROM THE OS ERROR ROUTINE SO THAT IT WILL RETUHN TO ANOTHER
; PLACE OTHER THAN THE OS. THIS CAN BE DONE WITH 'THE SETERR
; ROUTINE @ $2A7D. IF YOU ARE USING THE OS FROM YOUR OWN PROGRAM,
; YOU MAY ALSO WISH TO MODIFY THE OSERR ROUTINE TO NOT PRINT THE
; ERROR MESSAGE, IN WHICH CASE YOU WOULD NEED TO SET A FLAG TO INFORM
; YOUR PROGRAM THAT AN ERROR HAD OCCURED.
; OS65D3 : ENTRY POINT FOR OS65D MAIN LOOP
;
2A51 A2 28
2A53 9A
OS65D3 LDX '$28
TXS
SET STACK
;
)
; THE TOP OF STACK IS SI:":T 'ro $28 SINCE THE NON-MASKABLE INTERRUPT
; VECTOR IS SI:":T TO $013D. WE WON"r EVEN COMMENT ON HOW ASININE IT
; IS TO PUT THE IN'rERRUPT VECTORS IN THE STACK AREA.
;
2A54 A9 51
2A56 M 2A
2A58 20 7D 2A
2A5B 20 6A 2D
2A5E AD 5C 26
2A61 18
2A62 69 40LOA i$51
LOY 1$2A
JSR SETERR
JSR CHLF
LOA DSKDR
CLC
ADC 1$40
2A64 20 43 23
2A67 A9 2A
2A69 20 43 23
2A6C 20 9B 2C
2A6F A9 2E
2A71 85 E2
2A73 A9 1E
2A75 85 E1
2A77 20 84 2A
2A7A 4C 51 2AJSR PRINT
LOA ,'*
JSR PRINT
JSR OSINP
LOA 1$21:":
STA OSI8AD+1
LOA l$lE
STA OSISAD
JSR EXCOM
JMP OS65D3
,
SET OS ERROR RETURN TO OS
GET PRESENT DISK DRIVE
ACCUM NOW HAS LETTER OF
PRESENT DISK DRIVE
PRINT IT
PRINT ,*,
DO INPUT TO OS BUFFER
OS INPUT BUFFER HI ADDRESS
OS INPUT BUFFER LOW ADDRESS
GO EXECUTE COMMAND
LOOP SACK FOR ANOTHER CON~IAND
;
; SETERR : SET OS ERROR RETURN, LOW ADDRESS IN A
;
HIGH ADOHESS IN Y
,
)
2A7D 80 4F 2A SETERR s'rA ERRENT+4
STY ERRENT+5
2A80 8C 50 2A
RTS
;A83 60
($2A4F)
($2A50)
; EXCON : f:XECUTE OS COMMAND SUBROUTINE
;OS65D V3. 2 DISASSEMBLY
PAGE: 35
)
;
;
;
;
,.
TO EXECUTE OS COMMANDS FROM OTHER PROGRAMS EITHER PLACE THE COMMAND
IN THE OS BUFFER (@$2E1E) AND DO A JSR TO EXCOM, OR PUT TilE COMMAND
IN MEMORY, SET THE BUFFER POINTeR ($El,E2) TO YOUR BUFFER. THEN DO
A JSR TO EXCOM. YOU WOULD PRDBABLY ALSO WANT TO SET THE OS ERROR
RETURN TO YOUR OWN PROGRAM •
2A84 A2 co
EXCOM
2A86 8E E5 2C
LDX '$00
STX BUFOFS
;
LOY t $0'0
LOA DSPTBL,X
2A89 AI! ~~
2ABB BD 3D 2E
;
)
XsOFFSET INTO DISPATCH TABLE
CLEAR BUFFER OFFSET
USED BY BUFBYT
Y=OFFSET INTO BUFFER
FIRST CHARACTER IN DISPATCH
TABLE ENTRY
IF 0 THEN DO ERROR '7
COMPARE TO BUFFER
IF NOT GO CHECK NEXT ENTRY
BUMP BUFFER INDEX
SECOND CHAR. IN TABLE ENTRY
COMPARE TO BUFFER
IF NOT CHECK NEXT ENTRY
GET HIGH ADDRESS FROM TABLE
BEQ ERR7
2A8E FB 3~
CMP
(OSIBAD),Y
2A90 Dl E1
BNE NXTENT
2A92 DB 26
INY
2A94 C8
LOA DSPTBL+1,X
2A95 BD 31 2E
CMP (OSIBAD),Y
2A98 01 E1
BNE NXTENT
2A9A 00 1E
LDA DSPTBL+3,X
2A9C BD 33 2£
PHA
2A9F 48
LOA DSPTBL+2,X
2MB BD 32 2E
PHA
2AA3 48
JSR BUFBYT
2AM 20 E4 2C
2AA7 C9 0D
CMP '$00
BEQ NXTENT-1
2M9 F0 ~E
2MB C9 2~
CMP t$2~
2AAD D~ F5
8NE *-9
JSR BUFBYT
2AAF 20 E4 2C
2AB2 C9 20
CMP 1$20
2AB4 F0 F9
BEQ *-5
DEC IlUFOFS
2AB6 CE E5 2C
RTS
2AB9 6"
NXTENT INX
2ABA E8
INX
2ASS E8
INX
2ABC E8
INX
2ABD E8
BNE EXCOM+5
2ABE D0 C9
<:RR7
LDA 1$07
2Ace A9 07
BNE ERRENT
2AC2 Dill 87(S2A89) GO BACK IF MORE 'fABLE
SYNTAX ERROR t7
JUMP TO OS ERROR ENTRY (:t.-?q 0 )
; OSERR : OS ERHOR ROUTINE, ERROR IIN ACCUMULATOR
GET LOW ADDRESS
GET BYTE FROM BUFFER
CHECK FOR ',CR'
($2AB9) IF IT IS, EXECUTE COMMAND
CHECK FOR A 'SPACE'
(S2AA4) IF NOT, TRY AGAIN
GET BYTE FROM BUFFER
CHECK FOR A 'SPACE'
($2MF) IF SO, LOOK AGAIN
POINT TO FIRST NONSPACE
JUMP TO ADDRESS FROM TABLE
INCREMENT TO NEXT TABLE ENTRY
EACH ENTRY IS 4 BYTES
;
,
)
ALWAYS CALLED FROM $2A48. NOTE THAT THE I/O DISTRIBUTORS ARE
RESET TO THE DEFAULT DEVICE ON ANY ERROR.
2AC4 48
2AC5 A9 01
2AC7 aD 21
2ACA 80 22
2ACD 20 73
2ADe 2" 45
2AD) 52 20
OS ERR
23
23
20
52
PHA
LDA 1S01
STA INDST
STA OUTDST
JSR STROUT
.BYTE ' ERR
GET DEFAULT I/O DISTRISUTOl1
AND RESE'f
PRINT THE FOLLOWI NG
j
',0OS65D V3.2 DISASSEMHLY
PAGE: 36
---------------------------------------- -------------------------------
2AD5
2AD7
2ADB
2ADB
23 ~0
68
20 9B 2D
4C 61 27
·
,·
2ADE A9 05
,
PLA
JSR PRTHEX
JMP UNLDHD
PRINT THE ERROR NUMBEH
UNLOAD HEAD AND RETURN
; ASM : ASSEMBLER COMMAND
ASM
2AE0 20 EE 2A
2AE3 4C 00 13
,
LDA 1$05
JSR LDCMN
JMP STAS1~
FIRST TRACK NUMBER
COMMON CODE
JUMP TO START OF ASSEMBLER
; BASIC : BASIC COMMAND
;
2AE6 A9 02
BASIC
2AEB 20 EE 2A
2AEB 4C E4 2'"
LDA 1$"2
JSR LDCMN
JMP STBAS
FIRST TRACK NUMBER
COMMON CODE
JUMP TO START OF BASIC
,
; LDCMN : LOAD LANGUAGE COMMON ROUTINE
; LOADS 3 TRACKS STARTING WITH TRACK IN ACCUM INTO MEMORY @ $0200 & UP
;
)
2AEE 20 BC
2AF1 A2 02
2AF3 B6 E0
2AF5 86 FF
2AF7 CA
2AFB BE 5E
2AFS CA
2AFC 86 FE
2AFE CA
2AFF B6 E5
2B01 20 54
2B04 20 67
2B07 C6 Ell
2H09 30 15
2B0B 20 B3
2B0E 4C 04
26 LDCMN
26
27
29
2C
28
JSR SETTK
LDX '$02
STX TS1
STX MEMHI
DEX
STX SECTNM
DEX
STX MEMLO
DEX
STX HSTTK
JSR LDHEAD
JSR READDK
DEC TS1
BMI D9-3
JSR INCTKN
JMP *-10
POSITION HEAD TO FIRST TRACK
# OF TRACKS-1 TO READ
MEMORY ADDRESS HIGH=2
SET SECTOR TO 1
MEMORY ADDRESS LOW= O
HIGHEST TRACK = $FF
LOAD HEAD TO DISK
READ TRACK INTO MEMORY
($2820) IF NO MORE TRACKS, DONE
BUMP TRACK NUMBER AND SET HEAD
($2804) CONTINUE
;
; CALL : CALL COMMAND, READ SECTOR INTO .MEMORY
;
2Bl1 20
2B14 20
2817 20
2B1A 20
2BID 20
2B20 4C
23
58
60
54
67
61
2D CALL
2D
2C
27
29
27
JSR GETADR
JSR CKEQL
JSR GETTK
JSR LDHEAD
JSR READDK
JMP UNLDHD
MEMORY ADDRESS @$FE,FF
LOOK FOR s SIGN
GET TRACK 1 AND SECTOR
LOAD HEAD TO DISK
READ DISK INTO MEMORY
UNLOAD HEAD AND RETURN
,
; D9 : DISABLE ERROR 9
•
)
2B23 A9 Oil
D9
2B25 BD B4 28
2B28 Gil
LDA #$00
STA DK8T9+4
RTS
($2BB4) CHANGE DKBT9 ROUTINE
;
; DIR : DIRECTORY COMMAND, PRINT SECTOR MAP OF TRACKOS650 V3.2 DISASSEMBLY
j
)
PAGE; 37
,
2B29 2B 2E 20 OIR
2B2C 4C F3 29
J5R BLDHEX
JMP DIRCNT
GET TRACK NUMBER FROM BUFFER
GOTO ACTUAL CODE
;
; EM ; CALL AND ENABLE EXTENDED MONITOR
,
2B2F A9 e5
EM
2B31 2e EE 2A
2 B34 4C ell 17
LOA IS05
JSR LDCMN
JMP STEM
GET FIRs'r TRACK NUMBER
COMMON CODE
GOTO START OF EXTENDED MONITOR
;
; EXAM ; EXAM THACK INCLUDING FORMATTING INFORMATION
;
THIS IS A REALLY NICE COMMAND, EXCEPT THEY DON'T GIVE YOU ANY
; EASY WAY TO PUT THE DATA BACK ONTO THE DISK.
;
2B37 20
2B3A 20
2B3D 20
2B40 20
2B43 4C
23
58
2E
BC
39
20 &XAM
20
20
26
27
JSR GETADR
JSR CKEQL
JSR BLDHEX
JSR SETTK
JMP EXAMCNMEMORY ADDRESS @SFE,FF
LOOK FOR EQUAL SIGN
GET TRACK NUMBER
MOVE HEAD TO TRACK
JUMP TO REST OF CODE
JSR BLDHEX
STA GOADR+2
JSH flLDHEX
STA GOADR+l
JMP **GET HIGH ORDEH ADDRESS
($2B54) SAVE IT
GET LOW ORDER ADDRESS
($2B53) SAVE IT
GO TD ADDRESS ENTERED
,
; GO ; GO COMMAND
;
)
2B46 2~ 2E 20 GO
2B49 80 54 2B
2B4C 20 2E 20
2B4F 80 53 2B
2B52 4C oe ee GOADR
;
; INIT ; INITIALIZATION COMMAND
;
2B55 20 E4 2C INIT
2B58 C9 0D
2B5A F0 0C
JSR BUFBYT
CMP tSeD
S&Q FULINT
GET BYTE FROM
BUFF~R
I~ 'CR' THEN DO ENTIHE DISK
OT.HERWISE, DO ONE TRACK
DEC SUFOFS
2B5C CE E5 2C
RESET SUFFER POINTER
GET TRACK NUMBER
2B5F 2e 2E 20
JSR BLDHEX
2B62 211 BC 26
JSR SETTK
MOVE HEAO TO TRACK
2B65 4C 70 27
JNP INITTK
INITIALIZE TRACK AND RETURN
2B68 20 73 20 FULl NT JSR S'fROUT
PRINT THE MESSAGE
• BYTE 'ARE YOU SURE?', e
2B6B 41 52 45
2B6F 2e 59 4F
2B71 55 2e 53 55
2B75 52 45 3F
2B78 e0
2B79 20 40 23
JSR INECHO
INPUT AND ECHO 1 CHARACTER
2B7C C9 59
CMP t'Y
2B7E De 26
BNE LOAD-l
(S2BA6) IF NOT 'Y' THEN RETURN
2B80 4C 68 27
JMP INITAL
DO REST OF CODE
;
)
; 10 ; I/O COMMAND (SEE NOTE AT $2339)
,
2B83
2~
E4 2C 10
JSR SUFBYT
GET
~YTE
FROM BUFFER.
OS65D V3.2 DISASSEMBLY
)
CMP ' ,
BEQ ONLYO
DEC BUFOFS
JSR BLDHEX
STA INDST
JSR BUFBYT
CMP .seD
BEQ LOAD-1
DEC BUFOFS
JSR CKEQL+3
JSR BLDHEX
STA OUTDST
RTS
2B86 C9 2C
2B8S Fe 16
2BSA CE E5 2C
2BSD 2e 2E 2D
2Bge SD 21 23
2B93 2e E4 2C
2B96 C9 0D
2B98 Fe "C
2B9A CE E5 2C
289D 2e 5B 2D
2BM 2e 2E 2D ONLYO
2BA3 SD 22 23
2BA6 6e
,.
PAGE: 38
IF ' , ' DO OUTPUT ONLY
RESET BUFFgR POINTER
GE1' INPUT FLAG
SAVE IT
GET BYTE FROM BUFFER
($2BA6) IF 'CR' THEN RETURN
RESET BUFFER POINTER
CHECK FOR COMMA
GET OUTPUT FLAG
STORE IT
; LOAD : LOAD COMMAND
;
)
2BA7 20 A6 2D LOAD
2BAA 20 70 2C
2BAD 86 EO
2BAF FO 03
2BB1 20 83 2C
2BB4 2e 67 29
2BB7 E6 EO
2BB9 CE 7D 31
2BBC D0 F3
2BBE A5 E0
2Bce 8D 7D 31
2BC3 4C 61 27
JSR FNDFL
JSR SETPGM
STX TS1
SEQ *+5
JSR INCTKN
JSR HEADDk
INC TS1
DEC S317D
SNE *-11
LDA TS1
STA $317D
JNP UNLDHD
FIND FILE NAME IN DIRECTORY
SET MEMORY ADDRESS & LOAD HEAD
x=e USED AS # OF TRACKS READ
(S2BB4) SKIP NEXT INSTR 1ST TIME
BUMP TRACK NUMBER
READ TRACK INTO MEMORY
BUMP TRACKS READ
DROP NUMBER OF TRACKS TO READ
(S2BB1) IF MORE TRACKS, CONTINUE
RESET NUMBER OF TRACKS IN FILE
UNLOAD HEAD AND RETURN
;
; MEM : MEMORY COMMAND
2BC6 A2 0e
MEM
2BC8 20 De 2B
2BC8 2e 5B 2D
2BCE A2 07
2BDe 20 2E 2D
2BD3 9D SB 23
2BD6 2e 2E 2D
2BD9 9D SA 23
2BDC 6e
.
LDX iS0"
JSR *+8
JSH CKCOMA
LDX tse7
JSR BLDHEX
STA MINADR+1, X
JSH BLDHEX
STA MINADR,X
RTS
SET OFFSET FOR INPUT ADDRESS
($2BDe) GET FROM BUFFER AND SAVE 1'1'
CHECK FOR COMMA
SE'f OFFSET FOR OUTPUT ADDRESS
GET HIGH ORDER ADDRESS
SAVE IT
GET LOW ORDER ADDRESS
SAVE IT
,
PUT : PUT COMMAND
;
)
;
;
;
;
;
;
;
;
THERE IS A SERIOUS ~'LAW IN THE PUT COMMAND. IT ALWAYS WRITES WHOLE
TRACKS STARTING @ $3179. IF YOU IlAVE A VERY LARGE FILE IN MEMORY,
SUCH AS A WORD PROCESSOR FILE, AND IT GOES BEYOND $B578 THEN THE
LANGUAGES (8ASIC, ASSEMBLER, WORD PROCESSOR) WILL COMPUTE 13
TRACKS TO BE PUT TO DISK. UNFORTUNATELY, ATTEMPTING TO PUT OUT
13 TRACKS WILL CAUSE THE SYS1'EM TO WRITE THE DISK CONTROLLER
MEMORY TO DISKI!! THE READ AFTER WRITE CHECK WILL FAIL AND YOU
IHLL GET AN ERROR 2. IF YOU DON'T SEE THE ERROR WHEN IT OCCURS,
AND ATTEMPT TO LOAD THE FILE LATER, VERY CURIOUS ERRORS IlAPPE~.
THE SIMPLEST FIX FOR THIS PROBLEM IS TO LIMIT THE AMOUNT OF MEMORYI
1
I
OS65D V3.2 DISASSEMBLY
I
;
;
'I
THE COMPUTER THINKS YOU HAVE BY CHANGING HIMEM @ $2300 TO $B4.
2BDD 20 A6 2D PUT
2BE0 211 70 2C
2BE3 AD 7D 31
2BE6 85 Ell
2BE8 A9 liB
I
PAGE: 39
JSR FNDFL
JSR SETPGM
LDA ~3.i7j)
STA TS1
LDA .$0B
FIND FILE NAME IN DIRECTORY
SET M~MORY ADDRESS, LOAD HEAD
.::?'!'
~I~,~ .q~q
OF T'RACKS
SAVE IT
NUMBER OF PAGES
·; YET ANOTHER EXAMPLE OF AN OSI BLUNDER. EACH TRACK ON THE DISK
•
;
;
;
;
;
;
;
;
;
;
;
;
;
;
)
IS CAPABLE OF HOLDING 13 SECTORS BUT THE PROGRAMMERS AT OSI
ONLY USE 11 IN THE PUT COMMAND. THERE IS NO LOGICAL REASON
TO DO THIS, MAYBE THEY THOUGHT THAT THIS WOULD HELP THEM TO
SELL MORE DISKS. YOU MAY CHANGE THIS, AS WE HAVE, TO USE 12
OR 13 SECTORS PER TRACK BY CHANGING THE PREVIOUS LDA '$0B TO
LDA '$0C OR $IlD. IF YOU DO DECIDE TO UTILIZE THE WASTED
SECTORS WE WOULD ADVISE YOU TO GO TO A 12 SECTOR PER TRACK
FORMAT AS THIS IS THE MOST THAT BASIC WILL RECOGNIZE.
THIS WILL NOT HELP YOU WHEN SAVING BASIC OR ASSEMBLER PROGRAMS
OR WORD PROCESSOR FILES AS ALL OF THESE LANGUAGES CALCULATE
THE NUMBER OF TRACKS TO BE WRITTEN TO DISK BASED ON 11
SECTORS PER TRACK. HOWEVER, IF YOU ARE DOING DISK I / O FROM
YOUR OWN MACHINE LANGUAGE PROGRAMS, SUCH AS THE TEXT EDITOR
USED TO PREPARE THIS DOCUMENT. YOU CAN USE 12 SECTORS PER TRACK
WITHOUT ANY PROBLEM.
;
2BEA 8D SF 26
2BED 20 E1 27
2BFD C6 E0
2BF2 F0 06
2BF4 20 83 2C
2BF7 4C ED 2B
2BFA 4C 61 27
;
;
STA PGCNT
JSR DSKWRT
DEC TS1
BEQ *+8
JSR INCTKN
JMP *-19
JMP UNLDHD
SAVE IT
WRITE TO DISK
DROP TRACK COUNT
($2BFA) IF NO MORE THEN DONE
BUMP TRACK NUMBER AND STEP HEAD
($2BED) LOOP BACK & ,WRITE THIS TRAC~
UNLOAD HEAD AND RETURN
RET : RESTART COMMAND
; (*) NOTE, NOT ALL OF THESE WILL BE SET AT THE SAME TIME.
; EACH LANGUAGE SE'rS IT'S OWN RESTART ADDRESS AND SETS THE
; OTHERS TO REPORT AN ERROR. OF COURSE, THE ASSEMBLER/EXTENDED MONITOR
; SETS BOTH RETURN ADDRESSES .
•
)
2BFD 20 E4 2C RET
2C01l C9 41
2C02 DD 03
2C04 4C 03 13
2C07 C9 42
2C09 D0 03
2CIlB 4C C4 20
2CIlE C9 45
2C10 D0 03
2C12 4C 00 17
2C15 C9 4D
2C17 D0 06
2C19 20 44 26
JSR BUFBYT
CMP I'A
BNE *+5
JMP RTASM
CMP #'B
BNE *+5
JMP RTBAS
CMP I'E
BNE *+5
JMP STEM
CMP t'M
BNE *+8
JSR SWAP4
GET BYTE FROM BUFFER
($2Ce7) NOT 'A' THEN CONTINUE
REENTER ASSEMBLER (*)
($2C0E) NOT '8' THEN CONTINUE
REENTER BASIC (*)
($2C15) NOT 'E' THEN CONTINUE
ENTER EXTENDED MONITOR (*)
($2CIF) NOT 'M ' THEN ERROR '7
SWAP 4 BYTES FOR VIDEO ROUTINEOS65D V3.2 DISASSEMBLY
2CIC 6C FC FE
2CIF 4C C0 2A
JMP ($FEFC)
JMP ERR7
PAGE: 40
JUMP TO RESET VECTOR
DO ERROR t7
;
; XQT : LOAD FILE AND GO @$317E
;
;
;
;
;
;
ONE USEFUL CHANGE TO THIS ROUTINE IS TO MAKE THE JUMP AT $2C25
INTO AN INDIRECT JUMP TO $3179 (6C 79 31). SINCE THE PROGRAM MUST
BE IN LOAD FORMAT ANYWAY, THIS WOULD ALLOW YOU TO HAVE A DISK
BUFFER OR TWO AT THE FRONT OF THE WORKSPACE AND USE THE BASIC
DISK I/O ROUTINES IN A STRAIGHTFORWARD FASHION.
;
2C22 20 A7 2B XQT
2C25 4C 7E 31
,
JSR LOAD
JMP $317E
DO LOAD
JUMP TO START OF PROGRAM
; SAVE : SAVE COMMAND, WRITE SECTOR TO DISK
;
2C28 20 60 2C SAVE
2C2B 20 58 2D
2C2E 20 23 2D
2C31 20 5E 2D
2C34 20 3D 2D
2C37 aD 5F 26
2C3A 20 54 27
2C3D 20 E1 27
2C40 4C 61 27
JSR GETTK
JSR CKEQL
JSR GETADR
JSR CKEQL+6
JSR GETHEX
STA PGCNT
JSR LDHEAD
JSR DSKWRT
JMP UNLDHD
) ,; SELECT : SELECT DISK DRIVE
GET TRACK! AND POSITION HEAD
CHECK FOR =
GET MEMORY ADDRESS AND PUT @$FE,FF
CHECK FOR 'I'
GET NUMBER OF PAGES FROM BUFFER
SAVE IT
LOAD HEAD
WRITE TO DISK
UNLOAD HEAD AND RE'rURN
; SETS PARAMETERS FOR DRIVE AND HOMES HEAD
,.
2C43 20 E4 2C SELECT JSR BUFBYT
2C46 C9 41
CMP i'A
2C48 30 0E
BMI ERR6-3
2C4A C9 45
CMP i'E
2C4C 10 0A
BPL ERR6-3
2C4E 29 0F
AND #$0F
2C50 20 C6 29
JSR SETDRV
2C53 B0 06
BCS ERR6
2C55 4C 63 26
JMP HOME
2C58 4C C0 2A
JMP ERR7
2C5B A9 06
ERR6
LDA #$06
2C5D 4C 4B 2A
JMP ERRENT
GET BYTE FROM BUFFER
CHECK FOR A-D
($2C48) LESS THAN 'A', ERROR #7
($2C58) )= 'E', ERROR #7
KILL UPPER 4 BITS : A= 1, D=4
SET FOR DRIVE
ERROR #6 IF DRIVE NOT READY
HOME HEAD AND RETURN
DO ERROR t7
DO ERROR t6
)
------,
I
I
I
I
I
0565D V3.2
DISASS~MBLY
PAGB: 41
--------------- - -------------------------------------------------------
) ; COMMON ROUTINES USED ~Y KERNEL
;
; GETTK : GET TRACK NUMBER & SECTOR FROM BUFFER & POSITION HEAD
;
2C60 20 2E 2D GETTK
2C63 20 BC 26
2C66 20 5B 2D
2C69 20 3D 2D
2C6C BD 5E 26
2C6F 611
,·
JSR BLDHEX
JSR SETTl(
JSR CKCOMA
JSR GETHEX
STA SECTNM
RTS
GET TRACK NUMBER
CHECK TRACK AND MOVE HEAD THERE
CHECK FOR COM~IA
GET SECTOR NUMBER
SAVE IT
; SETPGM : SET UP FOR PROGRAM
,·
2C79 211 BC 26 SETPGM JSR SETTK
2C73 A9 31
LDA 1$31
2C75 85 FF
STA MEMHI
2C77 A9 79
LDA 1$79
2C79 B5 FE
STA MEMLO
2C7B A9 III
LDA 1$111
2C7D BD 5E 26
STh SECTNM
2C811 4C 54 27
JMP LDHEAD
SET HEAD TO TRACK
SET MEMORY ADDRESS TO $3179
SET SECTOR NUMBER TO 1
LOAD HEAD AND RETURN
;
; INCTKN : INCREMENT TRACK NUMBER
,
2C83 AD 5D 26 INCTKN LOA TKNU~I
) 2C86 IB
CLC
2C87 FB
SED
2C88 69 el
ADC #$01
2C8A 08
CLD
2CBB C5 E5
CMP HSTTK
2C8D FII 02
BEQ *+4
2C8F BIl 03
BCS *+5
2C91 4C BC 26
JMP SETTK
2C94 A9 00
ERRD
LDA 1$00
BNE ERR6+2
2C96 0" C5
GET TRACK NUMBER
ADD 1 IN DECIMAL
IS THIS HIGHES'r 'rRACK NUMBER?
($2C91) YES, LET'S CONTINUE
$(2C94) HIGHER, DO ERROR D
SET HEAD AT TRACK AND RETURN
ERROR 0
($2C5D) JUMP TO ERROR
;
2C98 211 6A 20 NXTOSN JSR CRLF
SET FOR NEXT OS INPUT
;
; OSINP : OS INPUT ROUTINE
·
,
; NOTE: -THIS ROUTINE DOES NOT TRAP ILLEGAL CONTROL CHARACTERS.
; IF YOU PRESS' BACKSPACE' ($08), THE PREVIOUS CHARACTER WILL
; BE ERASED, BUT BOTH THE 'BACKSPACE' AND THE CHARACTER WILL
STILL BE IN THE BUFFER AND YOU WILL GET AN ERROR 17 EVEN
; THOUGH THE INPUT COMMAND LOOKS CORRECT.
;
2C9B A9
2C9D 80
2CAe A2
2CA2 2~
) 2CA5 C9
2CA7 Oil
2CA9 CA
11
OSINP
ED 2C
00
40 23 NXT05I
SF
13
LOA #$11
S'I'A ~tAXBUF
LDX 1$03
J5R INECHO
CMP 1$5t'
liNE OSIOK
DEX
SET BUFFER SIZE
X=CHARACTER COUNT
GET A CHARACTER
IS IT THE 'UNDERLINE'
CONTINUE IF NOT
MOVE BACK ONE CI!ARAC'fEI{OS65D V3.2 DISASSEMBLY
PAGE: 42
-----------------------------------------------------------------------
)
3~ ECBMI NXTOSN
2CAC 90 1E 2E
2CAF 20 73 20STA OSBUF,X
JSR STROUT
2CAA
,
TRY AGAIN
BACKSPACED AT FIRST CHARACTER
PUT IT IN BUFFER
DO BACKSPACE
;
;
;
;
;
;
;
;
;
.
,
)
THIS PRINT FIRST DOES 2 BACKSPACES TO POSITION THE CURSOR
AT THE CHARACTER TO BE DELETED. THE FIRST IS NECESSARY TO GET
PAST THE UNDERLINE OR LEFT ARROW AND THE SECOND TO GET TO THE
CHARACTER THAT WAS INPUT. THE ROUTINE THEN PRINTS 2 SPACES, 1
TO ELIMINATE THE CHARACTER THAT WAS ENTERED AND ANOTHER TO
ELIMINATE THE UNDERLINE OR LEFT ARROW. THE CURSOR IS THEN
BACKSPACED TWICE TO REPOSITION IT SO YOU ARE READY TO
ENTER THE CORRECT CHARACTER •
2CB2 08 08 20
2CB5 20 08 08
2CB8 00
2CB9 4C A2 2C
2CBC C9 15
OSIOR
2CBE F0 08
2CC0 90 lE 2E
2CC3 C9 00
2CC5 F0 09
2CC7 E8
2CC8 E0 11
2CCA 00 06
2CCC A9 00
2CCE Oil F0
2CD0 4C 6A 20
2CD3 110
2CD4 00
2CD5 ""
.BYTE 8,8,'
·,8,8,0
JMP NXTOSI
CMP ISiS
BEQ NXTOSN
STA OSBUF,X
CMP IS0D
BEQ *+11
INX
CPX .S11
IlNE NXTOSI
LOA 0$00
BNE OSIOK+4
JMP CRLF
BRK
BRK
BRK
CONTINUE
CHECK FOR CONTROL U
IF SO IGNORE INPUT UP TO NOW
PUT IN BUFfER
CHECK FOR • CR'
(S2CD0) IF SO THEN WE ARE DONE
BUMP INDEX
CHECK FOR MAXIMUM LENGTH
NOT DONE SO CONTINUE
IlUFFER FULL, STOP INPUT AND PROCESS
(S2CC0) JUMP
( UNUSED)
(UNUSED)
( UNUSED)
;
; INPUT: INPUT ROUTINE. CIIECKS FOR CONTROL CHARACTERS.
;
(SEE NOTE AT S2339)
; WHEN WRITING YOUR ONI~ INPUT 1l0UTINES TO IlE USED WITH THE as
; YOU SHOULD STORE THE INPUT CHAIlACTER IN A.HOLD BEFORE RETURNING
; FROM YOUR ROUTINE SINCE THE INPUT ROUTINE RESTORES A,X,Y
WHEN IT RETURNS. If YOU DO NOT DO THIS YOUR INPUT IVILL BE THE
; CHARACTER IN A WHEN THE ROUTINE WAS CALLED.
,
2CD6
2CD9
2CDC
2CDF
2CE1
20 67
2~ 39
20 4D
F0 t"S
4C 5E
23 INPUT
23
25
23
JSR SAVAXY
JSR DOINP
JSR CKINP
BEQ DIPUT+3
JMP RSTAXY
GO DO INPUT
CHECK FOR CONTROL CHARACTERS
(S2CDF) IF SO CONTINUE INPUT
IIESTORE REGIS'fERS AND GO BACK
;
; BUFBYT : GET BYTE FIlOH BUFFER
.
;
) ~CE4 A0 07
•
2CE6 In E1
BUFBYT LDY tBUFOFS
LDA (OSIBAD).Y
GET OFFSET INTO BUFFER
MORE SELF MODI tYING CODE
LOAD BYTE
~OS65D V3.2 DISASSEMBLY
) 2CE8 C9 ~D
2CEA Fe 07
2CEC CIl 11
2CEE F0 04
2CF0 EE E5 2C
2CF3 60
2CF4 A9 OD
2CF6 60
•·
CMP
BEQ
CPY
BEQ
INC
RTS
LDA
RTS
'$0D
*+9
'$11
*+6
BUFOFSCHECK FOR 'CR'
($2CF3) IF SO WE ARE DONE
CHECK FOR END OF BUFFER
($2CF4) IF SO THEN RETURN
BUMP THE OFFSET
'$0DLOAD A 'CR'
RE'rURN, IlUFFEH IS FULL
PAGE: 43
; SWAP : SWAP PAGE '" AND 1 WITH $2F79 AND UP (USED BY BASIC)
; THIS ROUTINE IS NOT CALLED ANYWHERE BY THE OS
;
SWAP
PLA
2CF7 68
CLC
2CF8 18
ADC 1$01
2CF9 69 III
STA GE'rADR-2
2CFB 8D 21 2D
PLA
2CFE 68
ADC 1$00
2CFF 69 Oil
STA GETADR-1
2D01 80 22 2D
LDX '$01l
2D"2 A2 Oil
2D06 BD 00 01 SWAPLP LDA STACK,X
LDY SWAP1,X
2D09 BC 79 30
STA SWAP1,X
2D0C 9D 79 30
TYA
2D0F 98
STA STACK,X
.) 2D10 9D 00 01
LDA PAGE0,X
2D13 B5 00
2015 BC 79 2F
LDY SWAP",X
STA SWAPIJ,X
2D18 90 79 2~'
STY PAGEIl,X
2D1B 94 00
INX
2010 EB
2D1E D0 E6
BNE SWAPLP
2D20 4C C7 14
JMP **
CHANGE RETURN ADDRESS
INTO JUMP @$2D21l
($2021)
($2022)
SET THE OFFSET
GET BYTE FRDM PAGE 1
GET BYTE FROM SWAP AREA
SAVE THE BYTE FROM PAGE 1
SAVE THE BYTE FROM SWAP AREA
GET BYTE FROM PAGE 0
GET BYTE FROM SWAP AREA
SAVE BYTE FROM PAGE "
SAVE BYTE FROM SWAP AREA
BUMP THE OFFSET
NOT DONE, KEEP ON
ADDRESS FOR JUMP IS CHANGED ABOVE
;
; GETADR : GET MEMOHY ADORESS FROM BUFFER
·
•2D23 20 2E 2D GETAOR JSR IlLDHEX
2026
2D28
2D2B
2D2D
,·
85 FF
20 2E 2D
85 FE
6"
STA MEMHI
JSR BLDHEX
STA MEMLO
RTS
HIGH ORDER BYTE
LOW ORDER BYTE
; BLDHEX : BUILD HEX BYTE FROM BUFFER
; RESULT IS IN ACCUM
;
2D2E 20
2D31 OA
2D32 (JA
2D33 0A
2D34 IJA
2035 85
) 2037 20
203A 35
2D3C 60
3D 2D BLDHEX JSfl GETHEX
ASL A
ASL A
ASL A
ASL A
Ell
S'rA TSI
3D 2D
JSfl GETHEX
ORA TS1
E3
HTS
GET BYTE FROM BUFFER
SAVE UPPER FOUR BITS
GET SECOND BYTE
COMBINE WITH FIRST BYTEOSG5D V3.2 DISASSEMBLY
PAGE: 4 4
-----------------------------------------------------------------------
)
;
,· GETHEX
: GET 1 HEX DIGIT FROM BUFFER
;
2D3D 20
2D40 38
2041 E9
2D43 C9
2045 9(}
2041 E9
2D49 C9
204B B0
204D 69
204F 60
E4 2C GETHEX JSR tlUFBYT
SEC
SBC 1$30
30
CMP I$BA
0A
BCC *+10
08
SBC '$11
11
CMP 1$06
116
BCS *+10
(}8
ADC 1$0A
0A
RTS
GET BYTE FROM BUFFER
($2D4F)
IF <10 THEN RETURN
($2055) IF > F THEN ERROR
·; THIS CODE USED BY BASIC AND POSSIBLY THE OTHER LANGUAGES
,·
LDA PAGE0
DO WE NEED TO SWAP PAGES Il/l
2050 A5 00
,
2052 Fe A3
2D54 60BEQ SWAP
RTSYES, GO DO IT
2D55 4C C0 2AJMP ERR1GOT HERE FROM $2D4B
·
,
;
; CKEQL 0 CHECK FOR '=' OR ' , ' OR ' / '
;
THREE ENTRY POIN 'rs -> CKEQL=$2058 : CKCOMA- $2D5B : CKSLSH=$2D5E
ANOTHI': R EXAMPLE OF TURNING A TWO BYTE INSTRUCTION IN'ro A THREE
o BYTE 'HARMLESS' INSTRUCTION. (SEE NOTE @ $28E6)
; FORTUNATELY, THIS TIME THEY ARE HARMLESS.
0
)
0
0
CKEQL
2D58 A9 3D
2D5A 2C A9 2C
2D5D 2C A9 2F
2D60 85 E0
2062 20 E4 2C
2D65 C5 E0
2D61 D0 EC
2D69 60
LDA t':
BIT $2CA9
BIT $2FA9
STA TSI
JSR BUFBYT
CMP TSI
BNE CKEQL-3
RTS
SAVE CHARACTER TO TEST
GET BYTE FROM BUFFER
( $2D55) IF NOT THEN ERROR 17
· CRLF : PRINT CR,LF TO ALL ACTIVE DEVICES
,
0
;
2D6A A9
206C 20
2D6F A9
2011 00
0
CRLF
00
43 23
0A
3"
,· STROUT :
LDA '$0D
JSR PRINT
LDA '$BA
BNE FNDFL-3
DO ' CRt
DO I LFr
($2DA3) JUMP TO PRINT
PRINT STRING FOLLOWING J SH THAT GOT US HERE
THE STRING CAN BE ANYTHING, BUT MUST BE TERMINATED BY A NULL.
o STRING LENGTH IS LIMITED TO 255 CHARACTERS.
-,l THI S IS A VERY USEFUL ROUTINE, BUT tiE WARNED THAT IT CAN III':ALLY
# PLAY HAVOC WITH YOUR PROGRAM IF YOU FORGET TO PUT 1'1It: /lULL
; DELIMITER ON YOUR STRING.
,·I
1
I
OS65D V3.2 DISASSEMBLY
I
PAGE: 45
I
)
'I
I
I
I
STROUT PLA
2D73 68
STA STROAD
2D74 85 &3
PLA
2D76 68
2D77 85 &4
STA STROAD+ 1
LDY ISII1
2D79 A0 01
LDA (STROAD) ,Y
2D7B B1 E3
BEQ *+8
2D7D FII 116
JSR PRINT
2D7F 21l 43 23
INY
2D82 C8
2D83 D0 F6
BN& *-8
TYA
2D85 98
SEC
2D86 38
ADC STROAD
2D87 65 E3
STA STROAD
2D89 85 E3
BCC *+4
2D88 911 112
INC STROAD+1
2D8D E6 E4
JMP (STROAD)
2D8F 6C E3 110
.
,
; PRT2HX
PULL RETURN ADDRESS OFF STACK
STORE LOW ADDRESS
STORE HIGH ADDRESS
SET TO INDEX THROUGH STRING
GET 8YTE FROM STRING
(S2D85) IF NULL THEN WE ARE DONE
PRINT IT IF NOT
GET SET FOR NEXT CHARACTER
(S2D7B) JU~IP AND CONTINUE
GET SET TO FIND RETURN ADDRESS
ADD LENGTH OF STRING TO ADDRESS
SAVE IT
($2D8F) NO CARRY SO UPPER BYTE I~ 0 1
SUMP THE UPPER BYTE
JUMP PAST PRINTED STRING
PRINT 2 HEX CHARACTERS OF ACCUMULATOR
;
)
PRT2HX PHA
2D92 48
LSR A
2D93 4A
LSR A
2D94 4A
LSR A
2D95 4A
LSR A
2096 4A
JSR PRTHEX
2097 211 9B 2D
PLA
2D9A 68
.
,
SAVE THE CHARACTER
PUT UPPER NIBBLE IN LOWER NIBBLE
PRINT THE UPPER 4 BITS
RESTORE THE CHARACTER
; PRTHEX : PRINT HEX OF LOW NIBBLE IN ACCUMULA'rOR
; GOOD HEX TO ASCII CONVERSION
;
2D9B 29 IIF
2D9D C9 OA
PRTHEX AND 'S0F
CMP 1$0A
;
2D9F F8
2DA0 69 30
SED
ADC '$30
;
2DA2 08
2DA3 4C 43 23
MASK UPPER 4 BITS
SET CARRY IF >9 AND CLEAR
CARRY IF <10
IF CARRY SET THEN A;$41
IF CARRY CLEAR 9;$39
CLD
JMP PRINT
;
; FNDFL : FIND FILE NAME IN DIRECTORY
ONE OF TilE MOST USEt'UL ROUTINES IN THE OS IF YOU ARE WRITTING
YOUR OWN MACHINE LANGUAGE PROGRAMS. PUT TH~ NAME OF THE FILE YOU ARE
LOOKING FOR IN A BUFFER, EITHER THE OS BUFFER @ $2E1E OR YOUR OWN.
THE t'ILE NAME SHOULD BE DELIMIT~D BY A CR IF IT IS SHORTER THAN
SIX CHARACTERS. IF YOU ARE USING YOUR OWN BUFFER, IT'S ADDRESS
SHOULD BE PUT IN $E1,$E2. THE BUFFER OFFSET @ $2CE5 MUST BE
SET, EITHER TO ZERO IF THE FILE NAME IS AT THE B~GINNING OF THE
BUFFER, OR TO WHATEVER OFFSET IN THE BUFFER THE FIRST CHARACTER
; OF THE FILE NAME IS AT. THEN CALL 'fHIS ROUTINE.
; RETURNS WITH STARTING TRACK IN A, LAST TRACK @ $E5 .
;
;
;
;
;
;
)
;OS65D V3.2 DISASSEMBLY
2DA6 A9 76
FNDFL
2DA8 85 E5
2DM 20 E4 2C
2DAD CE E5 2C
2DBIl C9 41
2DB2 III IlA
2DB4 A2 IIIl
2DB6 A9 76
2DB8 9D 7A 2E
2DBB 4C 2E 2D
PAGE: 45
LDA 'S76
STA HSTTK
SET HIGHEST 'fRACK NUMBER
JSR IlUFBYT
GET BYTE FROM BUFFER
DEC BUFOFS
SET POINTER BACK
CMP ,S41
BPL *+12
($2DBE) IF ALPHA THEN LOOK FOR NAME
LDX .S00
HERE IF TRACK NUMBER ENTERED .
LDA 1$76
STA SCRIlUF+ 1. X
JMP BLDHEX
· GET TRACK. IN A AND RETURN
;
; LOAD BY NAME
;
)
LDA BUFOFS
2DBE AD E5 2C
STA TSI
2DCl 85 Ell
2DC3 A9 118
LDA .S08
JSR SETTK
2DC5 211 BC 26
STY SECTNM
2DC8 8C 5E 26
JMP NEWDS
2DCB 4C Illl 2E
2DCE A2 0111
LDX 'S01l
2DD" 2" E4 2C NXTCHR JSR BUFBYT
2DD3 C9 IlD
CMP 'SIlD
BNE *+4
2DD5 Dil 112
2DD7 A9 2111
LDA IS20
CMP SCRIlUF.X
2DD9 DO 79 2E
BNE NXTDE
2DDC D0 11
2DDE E8
INX
TXA
2DDF 8A
2DEIl 29 07
AND #S07
2DE2 C9 06
CMP 'S06
SNE NXTCHR
2DE4 DIl EA
.
•
).
2DE6 liD 7 A 2E
2DE9 85 E5
2DEB BD 79 2E
2DEE 60
2DEF 8A
NXTDE
2DF0 29 F8
2DF2 18
2DF3 69 08
2DF5 AA
2DF6 FIl 118
2DF8 AS Ell
NXTDS
2DFA 8D E5 2C
2DFD 4C DI!I 2D
2EI!I0 EE 5E 26 NEWDS
2E03 AD 5E 26
2E06 C9 113
2EIl8 31l 05
2EIlA A9 0C
ERRC
2EI!IC 4C 4B 2A
2E0F A9 79
2Ell 85 FE
GET POINTER
SAVE IT
TRACK NUMBER FOR DIRECTORY
HOVE TO TRACK 8
SECTNM-0
JUMP AROUND A LITTLE
GET BYTE FROM BUFFER
(S2DD9) IF NOT 'CR' THEN CONTINUE
IF 'CR' USE 'SPACE' FOR COMPARE
COMPARE TO DIREC'fORY ENTRY
IF NOT = TRY NEXT ENTRY
BUMP OFFSET
IF WE HAVEN'T LOOKED AT ALL
6 CHARACTERS THEN CONTINUE
LDA SCRBU F+ 1 • X MATCH! GET LAST TRACK'
STA HSTTK
SAVE IT
LDA SCRBUF.X
GET STA~TING TRACK'
RTS
~'XA
NEXT DIR ENTRY SETUP
KILL LOWER 3 BITS IN Ot't'SET
AND 'SF8
CLC
ADC .S08
SET TO NEXT DIR ENTRY
TAX
BEQ NEWDS
U' END Ot' SECTOR GET NEXT
LDA TSI
RESTORE BUFFER OFFSET
S'fA BUFOFS
JMP NXTCHR
JUMP IlACK AND TRY AGAIN
INC SEC'fNM
BUMP SECTOR NUMBER
LDA SECTNM
CMP ISIl3
BMI *+7
($2EI!IF) IF < 3 THEN CONTINUE
LDA .SIlC
ERROR C. FILE NOT FOUND
JMP ERRENT
LDA IS79
SET MEMORY ADDRESS TO $2E79
STA MEMLO
(SCRATCH IlUFFER, 256 BYTES)OS65D V3.2 DISASSEMBLY
2E13 A9 2E
2E15 85 FF
2E17 21il 1A 28
LDA 1$2E
STA MEMHI
JSR CALL+9
;
2E1A A2 Iillil
2E1C FI! DA
LDX i$1il1il
BEQ NXTDS
PAGE: 47
( $2B1A) LOAD HEAD, READ DISK,
UNLOAD HEAD
BUFFER OFFSET
SEARCH THIS DIRECTORY SECTOR
)
)
---------OS65D V3.2 DISASSEMBLY
i
PAGE: 48
; TABLES AND STORAGE FOR OS65D
;
; OS65D INPUT BUFFER eS2E1E TO S2E2F
;
2E1E
OSBUF
= *+17
; OS65D DISPATCH TABLE
;
; ADDRESS IN TABLE = ACTUAL ADDRESS OF ROUTINE - 1
; ADDRESS IN TABLE IS PUSHED ON · STACK AND THEN CALLED
; BY DOING AN RTS.
;
)
2E3e 41 53
2E32 DD 2A
2E34 42 41
2E36 E5 2A
2E38 43 41
2E3A 13 2B
2E3C 44 39
2E3E 22 2B
2E49 44 49
2E42 28 2B
2E44 45 4D
2E46 2E 2B
2E48 45 58
2E4A 36 2B
2E4C 47 4F
2E4E 45 2B
2E50 48 4F
2E52 62 26
2E54 49 4E
2E56 54 2B
2E58 49 4F
2E5A 82 2B
2E5C 4C 4F
2E5E A6 2B
2E60 4D 45
2£62 CS 2B
2E64 59 55
2 E66 DC 2B
2E68 52 45
2E6A FC 2B
2E6C 58 51
2E6E 21 2C
n7~ 53 41
2E72 27 2C
2E74 53 45
2£76 42 2C
2 E78 00
;
DSPTBL .BYTE 'AS'
.WORD ASM-1
.BYTE 'BA'
.WORD BASIC-1
.BYTE 'CA'
.WORD CALL-1
• BYTE '09'
.WORD 09-1
• BYTE 'DI'
.WORD DIR-1
.BYTE 'EM'
.WORD EM-1
.BYTE 'EX'
.WORD EXAM-1
.BY1'E 'CO'
.WORD GO-1
• BYTE 'HO'
.WORD HOME-1
.BYTE 'IN'
.WORD INIT-1
.BYTI:: '10'
.WORD 10-1
.BYTE 'LO'
.WORD LOAD-1
• BYTE 'ME'
.WORD MEM-l
.BYTE 'PU'
• WORD PU'C-l
.BYTE 'RE'
• WOIW RE1'-1
.BYTE 'XQ'
.WORD XQT-1
• BYTE 'SA'
.WORD SAVE-l
.BYTE 'SE'
.WORD SELECT-l
.BYTE "
-, ; THE REST OF THE OS MEMORY AREA IS WORKING STORAGE LOCATIONS
.
•
2E79
SCRIlUF = *+256
SCRATCH BUFFER FOR DIREC'CORYI
I
I
I
OS65D V3.2 DISASSEMBLY
I
PAGE: 49
;
;
;
;
;
;
;
1
\
.
•
THIS AREA IS ALSO USED BY THE BASIC GET/PUT LOGIC.
YOU CAN USE THIS PAGE FOR TRANSIENT CODE By CALLING IT HERE.
JUST BE SURE THAT YOU DON'T DO A DIRECTORY SEARCH OR USE BASIC'S
RANDOM DISK I/O. A GOOD PLACE TO PUT SUCH CODE IS ON TRACK 8
IN SECTORS 6 & UP SINCE THIS AREA IS NOT USED FOR ANY OTHER
PURPOSE •
2F79
3979
SWAP0
SWAPl
= *+256
= *+256
PAGE 9 HOLD AREA (USED BY BASIC)
STACK
""
II
II
"
;
; AND THAT (FINALLYl) BRINGS US UP TO THE STAR'r OF THE BASIC WORKSPACE.
)
)PAGE 1
OS-65D v3.2 CROSS REFERENCE
------------------------------------------------------------------------- .......
)
$eAM28E6$ 22M221H$228322M22A7
$22C722M22AA
$24762405$269E26BF$28£728FC$2CA92D5A$2FA92D5D$317D2889$317E2C25$F1l222297$FE012285$FEFC2CIC**
2904
2BC02BE3235E
26292360
262C2362
26382377
2ME2389
28522390
2D21!23A823C223FC241525A3
A.HOLD*236323672382239524F2250425242536253C259E25E7
ACIA*C01027302735274127C227CD2885292B2986ACIAIO*C0ll274727C927D328B82930ASH*2ADE2E32BASIC*2AE622832E36BDMHTK*2453244D24888DRDNX*244223EEBLDIlEX*2D2E
2D232829
?D282B3D
?DBB213462il4C2651"288D213M2BD026D62C60
8PSECT*2998281"8299D2A16) BSPACE*25F525AfBUF8YT*2CE42AM2AAF26552883289326FD2C432D3D2D622DAA
)I
I
PAGE 2
05-650 V3.2 CROSS REFERENCE
------------------------- ------------ ------------------------- .. ----------
2001)
*2CE52A862AB62B5CCALL*2B1124502E172E3ACKBFEN*246823A323B923F4240C
CKCOMA2BCB2C66CKCTLP*258A257BCKCTLX*25792564CKEQL*20582B142B3A2B90CKH' NO*2562254FCKINP"25402COCCKI R'I'N*259325602 5 88258CCKROY"290A2 6 07CKTK* 26 El2 6 0A2 6 FOCLRVIO" 2 26A22 602272CLRX16*2 2 512 25 CCNTLP*2 5 FC2 5B 32 5 tl7CNVHTN"26A6COMINC* 2 39 523 8 E23 8 0CR*26032 5A7CRLF*206A2A2AolBFOR*232001BFIlI2B9A2CFU
2C2B2C312067
23CA24 0 124 10270e
2A5 B2C982C002 3c72 3CC24 5 5" 232824 6B247 3247701BFLO* 2 3262 3 0623E l247B01CRTK*232C24 422 44 A2 45801FRST*232A) OlIADR*23AC23092 3E424 6 BOlLAST*23 2132 45B
)
l
BUFOFS
2B8A
2481
247 3
2486
20AO
20BE
20FAPAGE 3
OS-650 V3.2 CROSS REFERENCE
)
)
)
-------------------------------------------------------------------------
010AOR*23C3230C231::7U21:1~'DR*2335241A242002BFHI*2330D2BFLO*232E242/\2435D2CRTK*2334D2FRST*2332D2IAOR*23FO24202438D2LAST*2333020AOR*24162430243B09*28232B092E31::DCPRNT*2A412A2F2A34DEFOEV*2AC6228132569DELAY*270~267C26911OIR*28292E42OIRCNT*29F32B2COKlIN*231112311823114OK1NXT*23CC23A8238EOK lOUT*23822318OK2IN*23F02300OK2NXT*242023F9OK20UT*24032310OKBT9*2880
211252885288928CB2802
OKBTCI*29B629982911129AC298F
OKINIT*29EB29CE290429E129F4
OKRORY*297729742970OKWTX*27C2
28562 7A627A8
---
2704
2411
2809
28EO
290B
2912
2910
29C3
.......
27B1
27B6
27C7
282D
2833
2831;
2843
-~
2USl
. ---I
I
I
OS-65D V3.2 CROSS REFERENCE
PAGE 4
-------------------------------------------------------------------------
,
DLYFA*289F281 ~DLYFA1*2956289FDOINP*23392CD9I
I,DOlO*234B233EDONXIU*235C2351IIDSKBYT*27CD27D127.'5DSKDR*265C26D12A5EDSKWRT*27E1248E281'132BED2C3D
DSPTBL*2E3~2A882A952A9C2AA0
EM*282F2E46ERR1*2993ERR2*2898) ERR3* 2784ERR4*278F2786278D2 7£AERRS*28EI'IERR6*26DC *2C5826CF2C482C4C
ERR7*2ACI'I2A8E2CIF2C582D55
<:RR8*26CD26 C226 C6t:RR9*288F289D28B 3ERRA*28E6ERRB*27<:827E427E£ERRC*2E0A<:RRD*2C94ERR<:NT*2A4826DE279 128CI299 5
J::XAM*28372 t:4A)"XAMCN*27392745274D27512843
EXCOM*2A842A772ABE
~
i
,i
1
,
i
.
2828
235C
2374
288D
2C532C96
2A7D2A81'1
2 8E9
2AC2
2C5D
2 E ~C05-650 V3.2 CKOSS
PAGE 5
R~F~RENCE
----------------------------_._-------------------------------------------
EXI'r*25C92581.l258F25FA263126~9263AfLOPIN*CIl"''''
27F22235
27FC223A
28802230
298C266E
29012710
290A2722273C277f278A2789
FLOPOT*Cllll2
279C2683
2815268C
2818268F
282227~A2716
28662719
28682756
29072759276327 99
2825FNOFL*20A628A72BOO2071fULINT*2868285AGETAOR*20232B112B372C2£2Cf82001GETH£X*20302C342C69202£2037GET'rK*2C602B172C28GO*2B462E4EGOAOR*28522849GOBAS*22832294) HAMB*2661270CHIMEM*23002280HMFNO* 2280227BHOLOOP*266C2676HOME*2663276C2HO2C552E52HSTTK*00E5276A2AFF2CaH20A820E9HUNOUS*28A228102863287028M28AOINl*23362340INCTKN*2C83245E276F2B0S2B812BF4I NOS'r*2321233825GC257F2AC72890INECHO*234"28792CA2INIT*28552£56INITAL*2768277A2B80INITTK*277027722865INPUT*2C0623362COF
)
284F
2962
~05-650 V3.2 CROSS REFERENCE
)
------------------------------------------------------- .---------------- --
10*2B832E5A1001SP*2376235610m's*23782371IOTABL*2301237A237EKBINP*252B23032534KEYTST*2630250B25E2KIRTN*253F2528KPDO*232524E3KPOLL*FDIlIl2531KPORT*DF0e22212630KTRTN*2643250E25E5LAMB*256\127072950LCHAR*263C259B25CCLDCMN*2AEE2M;"2AE8LOHDWI*272827392794LDHEAD*27542211C249427282766
LF*260F25ABLOAD*2BA72B7E2B982C222E5E
MAXBUF*2CED2C90MEM*2BC62E62MEMCHK*22EC2.2782290MEMHI*00FF
287A22M
28802262
2890226F
2896MEMIN*23892309MEMLO*0~FE221lF
2640226G27DA226A
2938) MEMOT*23902319MEMTST*27.76227E
)
PAGE 6
25EB
2540
2937
2G4~
2B31
2A0D2B012BIA2C3A2C8022EC
2940231lA
2965243E
29772489
2AF527H'
2C75270f
20262849
2E15
22EE
296022F4
2AFC22F8
2C79230F
20282433
2Ell2484274 APAGE 7
OS-650 V3.2 CROSS REFERENCE
------------------------------------------------------ -------------------~
MINAOR*238A2398
2390
MODMIN*24972582MOTADR*239125532558
MOVE*262926322636
MOVEHD*26D126CB2950
NEWDS*2Een20CB2DF6
NI'IHZ*267B28A2NULLIN*23862307NXTCHR*200A20E4NXTOE*20EF20DCNXTOS*20F82E1CNXTENT*2ABA2A922A9A
) NXTOSI*2CA22CB92CCA
NXTOSN*2C982CAA2C13E
ONLYO*28AB2888OS6503*2A51254A2A7A
OSBUF*2EH~2CAC2CC0
OSERR*2AC42MBOSI8AD*00E12A71OSINP*2C982A6COSIOK*2C8C2CA72CCE
OUTOST*23222346PAGE0*011002274PATCH0*221362202PATCH1*23712341))PATCH2*24912462PATCH3*25082489
2499
25852B03
2M"2MB2CE6
2558256F2574258E
28A5201320182050
2809
20~'0
2A75
2AA9
2593
2ACA
28A3
".
.
(-'
:I
I
I
05-650 V3.2 CROSS
I
)
I
I
I
I
)
)
1
\
,
".
PAGE 8
REFER~NCE
-------------------------------------------------------------------------
PATCH4*254025F2PGCNT*265F2471:":27E128362859287028932921297A
PLINE*070025C125C9250125F625FO26042610261A
PRINT*234325662M12A642A69206C207F20A3PRT2HX*20922A072MBPRTHEX*209B2A082097PTROUT*249F231724MPTRPIA*t'4""2217221A22ln2224222F223224A0PUT*2BOO2E66ROCOSK* 2907288228F52971RDCONT*2929293E2943RORTYM*"eF72969298FRORTYN* 0l!F8280B28872960297FREADOK*29672211299128042B10RET*2BFD2E6AREWRT*281192898RNOSED*232424F9RSACIA*272B28C8RSTAXY*235£2CE1HTASM*13032C04RTBAS*20C42C0BRTYCMP*28782889RTYRO*296F2981SAVAXY*23672343SAVE*2C282E72SCRBUl'*2E7920B82DE620EBSCROLL*260B25C7
252E
2C06
2009
2BB4
24A9
2BEA
24AC
2C37OS-65D V3.2 CROSS
----------------- - ---_ ..
)
)
R~FER~NC~
PAGE 9
_----------------------------- --------------------~
SCTBYP*""F928E!!28FE29A9
SCTLEN*0"FA27F829562A21
SCTNUM*0~FB290229M2A1E
SCTRT'l*00F528C628E2SECTNM*265E
2E002286
2£032491SEEKRT*294728E4SELECT*2C432E76SERINP*25182305251CSEROUT*250D23152511SETDRV*29C6224229BASETERH*2A7021158SET~'F*291B29332939SETFLO*27192697269FSETNXT*26222630SETPGM* 2C702BAA2BE"SETSCT*28C42800SETTK*26BC22USSSOK*28EB280ESTACK*llle02M4STASM*13\)02AE3STBAS* 20 E42AE8STCCNT* 27 0826E6STEM*17002B34S'l'EP*268F2688STEPIN*26832673269226EA
STEPO'f*268A266326F12989
283D
2A192113728F029152A112AF82C6C2C7D
2B622C632C702C9120CS
2C50
27122875
290829532A14
29F72AEE2B40
20062010
2C12
2983
2OC8I
I
I
I,
I
,
PAGE
05-650 V3.2 CROSS REFERENCE
)
-------------------------------------------------------------------------
STEPRT*00EF22111126A22947STKAOR*0IlFC2AIlB2A262A3BSTROAO*00E320742077207B2087STROUT*207329FA2ACO2B682CAFSWAP*2CF72052SWAP0*2F7920152018SWAP1*30792009200CSWAP4*2644252B2539254726542C19
SWAP4A*021326462650SWAP4B*26572649264CSWAPLP*2006201ETENMS*267826662671268026M275E
TERMAC*FC002247224C24CE240A24F6
T ERI'I IN*24F623C124E024EA24FOTERMIO*FC01240624FFTERMOT*24CO23112403TIRTN*2504250B2544TKNHLD*0BEE26B3261lA26BC26E1280C
TKNUM*2650266926E326F626F9TORTN*24F1240E24£8TRKNM*266226MTS1* 00 Ell
20652AF3
20C121107
20F82BAOTS2*00FO22F622~' CUART*FB002227)UNLOHO*2761VIOOUT*2599
I
I
I
I
I
)
1~
294B
2080208F27A12986298C277527AE29C62C832111172BBE2BE62BF02035203A
2839284B28502860222A250£25142518251E25212214273F27C02A3E2ADB2B2021lC32BFA2C40
22AO2313
2089
2060OS-650 V3.2 CROSS REFERENCE
PAGE 11
------------------------------------------------------------------------- ........
)
.)
VIOSIZ*DEe~2291VLOSAV*26392613VLP1*2621:12623VLP2*262E2626VOTOFS*25A42504WAITIH*271027211272B
WRTPG*284"28472840
WRTRTY*""F628e72881:1
W'l'DKBF*247723032427
X.HOLO*235F2360X16ACI*CFee22512255
X160EV*232324B024B£
X16lNP* 24 B"23liH'24B7
X160UT*24BO231F24C6
XQT*2C222E6EY.HOLO*2361236A
24B3
24C1
24C9
25e82528 2i~~25 ~S~ ~25~~
EE2423 IN~ $2324
252E ADilDf LOA $Dfel
2531 3tf5
8MI $2528
2533 8D6323 STA $2363
2536 EA
NOP
'-4" ft1"-
2537 EA
!'IOF
2538 EA
NOF
2539 EA
!'lOP
253A EA
NOP
253B 2f~425 ~SR $25~4
~
253E "DeiDf LOA $DI'fJJ.
~ " . y -"f'
25'11 1... 8
BPL $253~"<A p~""
2543 5e
RTS
.
2544 A276
LOX *S76J .
25,,6 CA
OEX
J.I......
2547 2e .. ~25 ~SR $25"C
~-· o
254A DiFA
BNE $25,,6
~2528
-.-,~~~g ~~5B
~~~ *$5B
25", Deli
BNE $2562
2551 A98e
LOA *$8i
2553 809223 STA i2392
2556 "9Je
LDA *see
2558 809123 ST.'. $2391
255B "02223 LOA $2322
255E f91'
OR" *$1.
2561 Di31
BNE $2593
2562 C950
CMP *$50
256 .. De13
BNE $2579
2566 2~ .. 623 ~SR $23,,6
2569 "DC62" LDA $2AC6
256C 8D2123 STA $2321
256i AD2223 LOA $2322
2572 29Ef
AND *$Ei
257" 802223 STA $2322
2577 A95D
LDA *$5D
2579 C918
eMP *$16
257B DnO
BNE $258"
257D A911
LDA *$10
257F 802123 STA $2321
2582 2e972 .. ~SR $2497
2585 808A23 ST" $238"
2588 B~~C
BCS $2596
.. C
~.~ ph
La" J
{I t -t
2
------- --------------------54-0 vid eo
TH
2599 98
FHA
259A '18
2598 A(;5826 LDY $265B
259£ AD5323 LDA $2353
AND *$7i
25Al 29H
LilX *$52
25A3 A2",7
(;MF *seO
25A5 CgeD
8EQ $2521
2,A 7 )-.78
25A9 COl 118
eMP *$.8
BEQ $ 2513
25A8 ;e55
(;MP *$ a
2,AO COla
BEQ $251A
25AI f i59
CMP *$/1(;
25B 1 C9 IlC
BEQ $2 61A
25B3 .&55
258, COlZA
eMF *:> IIA
BEQ $2620
25B7 feH
(;MP *:l.2e;
2589 cne
BMI $2509
25B8 3i!C
CMF .. $78
2580 C978
8PL $2509
25Bf lei8
25(;1 90U07 5TA $07ee,X
INX -
25(; .. E8
CPX *$J!j
25C5 Eesr
Illlld ...... (.u tt"'lt.
A
/fa cJ
strip bit 7
- cA CA
cr
back up
contrl ' P _ pr-I'I r ,,. o"/d f
contr ol L
LF
spg" e
(
£. 'I-,T"
'> 1-
E ~I r
ro
5<. 0 .. (11\
fA
f ro
;;A
EA
S c..fH LL
25C7 Fe50
BEQ $2629
25C9 Delli
BNE S2 ,CB
25C8 BCel07 LOY $D7ZI,X i,AkJ' .... c;.<tffiD/'L
25CE 8C5B26 5TY $2658
<:'1.I f/!,.oA..
LDA *~5f
2501 A95i
2503 90e207 5TA $07Ie,X
25D6 3EA~25 STX ~25 A~
2509 58
FLA
250A A8
TAY
2,D8 A06323 LOA $2353
25DE 'IS
PHA
2,DI AOelOf LOA SOl e.
25£2 3el1
8MI 525i5
_
.5G1IJ~ I<f>YP "f'~:5·· J
25£~ g02'23 5T ... $2325
,"o",,1ROL S
25£7 C913
CMf *$ 13
25£9 OUA
BNE $25'5
25£B 2e,.~25 JSR $25~ ..
25££ AOliO. LOA 10f~1
2511(;911
I,;MP .. $ l1
2513 Oil9
BNE $25££
2515 4CI12", JMP $2 _fl
251s 51
RTS
2519 8A
TXA
