; Port of Apple II monitor to Apple 1
;
; Original port by Winston Gayler with additional adaptations by
; Wendell Sander. Source code reverse-engineered and ported to CA65
; assembler by Jeff Tranter <tranter@pobox.com>.

; Define to get Apple 1 version, otherwise generates original Apple II
; code.
APPLE1 = 1

; ***********************
; *                     *
; * APPLE-II            *
; * MINI-ASSEMBLER      *
; *                     *
; * COPYRIGHT 1977 BY   *
; * APPLE COMPUTER INC. *
; *                     *
; * ALL RIGHTS RESERVED *
; *                     *
; * S. WOZNIAK          *
; * A. BAUM             *
; ***********************
; TITLE "APPLE-II MINI-ASSEMBLER"
FORMAT = $2E
LENGTH = $2F
MODE =   $31
PROMPT = $33
YSAV =   $34
L =      $35
PCL =    $3A
PCH =    $3B
A1H =    $3D
A2L =    $3E
A2H =    $3F
A4L =    $42
A4H =    $43
FMT =    $44
IN =     $200
; INSDS2 = $F88E
; INSTDSP = $F8D0
; PRBL2 =  $F94A
; PCADJ =  $F953
; CHAR1 =  $F9B4
; CHAR2 =  $F9BA
; MNEML =  $F9C0
; MNEMR =  $FA00
CURSUP = $FC1A
GETLNZ = $FD67
COUT =   $FDED
BL1 =    $FE00
A1PCLP = $FE78
BELL =   $FF3A
GETNUM = $FFA7
TOSUB =  $FFBE
ZMODE =  $FFC7
CHRTBL = $FFCC
.ifdef APPLE1
        .ORG $7500
.else
        .ORG $F500
.endif
REL: SBC #$81 ; IS FMT COMPATIBLE
  LSR ; WITH RELATIVE MODE?
  BNE ERR3 ; NO.
  LDY A2H
  LDX A2L ; DOUBLE DECREMENT
  BNE REL2
  DEY
REL2: DEX
  TXA
  CLC
  SBC PCL ; FORM ADDR-PC-2
  STA A2L
  BPL REL3
  INY
REL3: TYA
  SBC PCH
ERR3: BNE ERR ; ERROR IF >1-BYTE BRANCH
FINDOP: LDY LENGTH
FNDOP2: LDA A1H,Y ; MOVE INST TO (PC)
  STA (PCL),Y
  DEY
  BPL FNDOP2
.ifdef APPLE1
  NOP
  NOP
  NOP
  NOP
  NOP
  NOP
.else
  JSR CURSUP
  JSR CURSUP ; RESTORE CURSOR
.endif
  JSR INSTDSP ; TYPE FORMATTED LINE
  JSR PCADJ ; UPDATE PC
  STY PCH
  STA PCL
  JMP NXTLINE ; GET NEXT LINE
FAKEMON3: JSR TOSUB ; GO TO DELIM HANDLER
  LDY YSAV ; RESTORE Y-INDEX
FAKEMON: JSR GETNUM ; READ PARAM
  STY YSAV ; SAVE Y-INDEX
  LDY #$17 ; INIT DELIMITER INDEX
FAKEMON2: DEY ; CHECK NEXT DELIM
  BMI RESETZ ; ERR IF UNRECOGNIZED DELIM
  CMP CHRTBL,Y ; COMPARE WITH DELIM TABLE
  BNE FAKEMON2 ; NO MATCH
  CPY #$15 ; MATCH, IS IT CR?
  BNE FAKEMON3 ; NO, HANDLE IT IN MONITOR
  LDA MODE
  LDY #$0
  DEC YSAV
  JSR BL1 ; HANDLE CR OUTSIDE MONITOR
  JMP NXTLINE
TRYNEXT: LDA A1H ; GET TRIAL OPCODE
  JSR INSDS2 ; GET FMT+LENGTH FOR OPCODE
  TAX
  LDA MNEMR,X ; GET LOWER MNEMONIC BYTE
  CMP A4L ; MATCH?
  BNE NEXTOP ; NO, TRY NEXT OPCODE.
  LDA MNEML,X ; GET UPPER MNEMONIC BYTE
  CMP A4H ; MATCH?
  BNE NEXTOP ; NO, TRY NEXT OPCODE
  LDA FMT
  LDY FORMAT ; GET TRIAL FORMAT
  CPY #$9D ; TRIAL FORMAT RELATIVE?
  BEQ REL ; YES.
NREL: CMP FORMAT ; SAME FORMAT?
  BEQ FINDOP ; YES.
NEXTOP: DEC A1H ; NO, TRY NEXT OPCODE
  BNE TRYNEXT
  INC FMT ; NO MORE, TRY WITH LEN=2
  DEC L ; WAS L=2 ALREADY?
  BEQ TRYNEXT ; NO.
ERR: LDY YSAV ; YES, UNRECOGNIZED INST.
ERR2: TYA
  TAX
  JSR PRBL2 ; PRINT ^ UNDER LAST READ
  LDA #$DE ; CHAR TO INDICATE ERROR
  JSR COUT ; POSITION.
RESETZ: JSR BELL
NXTLINE: LDA #$A1 ; '!'
  STA PROMPT ; INITIALIZE PROMPT
  JSR GETLNZ ; GET LINE.
  JSR ZMODE ; INIT SCREEN STUFF
  LDA IN ; GET CHAR
  CMP #$A0 ; ASCII BLANK?
  BEQ SPACE ; YES
  INY
  CMP #$A4 ; ASCII '$' IN COL 1?
  BEQ FAKEMON ; YES, SIMULATE MONITOR
  DEY ; NO, BACKUP A CHAR
  JSR GETNUM ; GET A NUMBER
  CMP #$93 ; ':' TERMINATOR?
ERR4: BNE ERR2 ; NO, ERR.
  TXA
  BEQ ERR2 ; NO ADR PRECEDING COLON.
  JSR A1PCLP ; MOVE ADR TO PCL, PCH.
SPACE: LDA #$3 ; COUNT OF CHARS IN MNEMONIC
  STA A1H
NXTMN: JSR GETNSP ; GET FIRST MNEM CHAR.
NXTM: ASL A
  SBC #$BE ; SUBTRACT OFFSET
  CMP #$C2 ; LEGAL CHAR?
  BCC ERR2 ; NO.
  ASL A ; COMPRESS-LEFT JUSTIFY
  ASL A
  LDX #$4
NXTM2: ASL A ; DO 5 TRIPLE WORD SHIFTS
  ROL A4L
  ROL A4H
  DEX
  BPL NXTM2
  DEC A1H ; DONE WITH 3 CHARS?
  BEQ NXTM2 ; YES, BUT DO 1 MORE SHIFT
  BPL NXTMN ; NO
FORM1: LDX #$5 ; 5 CHARS IN ADDR MODE
FORM2: JSR GETNSP ; GET FIRST CHAR OF ADDR
  STY YSAV
  CMP CHAR1,X ; FIRST CHAR MATCH PATTERN?
  BNE FORM3 ; NO
  JSR GETNSP ; YES, GET SECOND CHAR
  CMP CHAR2,X ; MATCHES SECOND HALF?
  BEQ FORM5 ; YES.
  LDA CHAR2,X ; NO, IS SECOND HALF ZERO?
  BEQ FORM4 ; YES.
  CMP #$A4 ; NO,SECOND HALF OPTIONAL?
  BEQ FORM4 ; YES.
  LDY YSAV
FORM3: CLC ; CLEAR BIT-NO MATCH
FORM4: DEY ; BACK UP 1 CHAR
FORM5: ROL ; FMT FORM FORMAT BYTE
  CPX #$3 ; TIME TO CHECK FOR ADDR.
  BNE FORM7 ; NO
  JSR GETNUM ; YES
  LDA A2H
  BEQ FORM6 ; HIGH-ORDER BYTE ZERO
  INX ; NO, INCR FOR 2-BYTE
FORM6: STX L ; STORE LENGTH
  LDX #$3 ; RELOAD FORMAT INDEX
  DEY ; BACKUP A CHAR
FORM7: STX A1H ; SAVE INDEX
  DEX ; DONE WITH FORMAT CHECK?
  BPL FORM2 ; NO.
  LDA FMT ; YES, PUT LENGTH
  ASL A ; IN LOW BITS
  ASL A
  ORA L
  CMP #$20
  BCS FORM8 ; ADD "$" IF NONZERO LENGTH
  LDX L ; AND DON'T ALREADY HAVE IT
  BEQ FORM8
  ORA #$80
FORM8: STA FMT
  STY YSAV
  LDA IN,Y ; GET NEXT NONBLANK
  CMP #$BB ; '' START OF COMMENT?
  BEQ FORM9 ; YES
  CMP #$8D ; CARRIAGE RETURN?
  BNE ERR4 ; NO, ERR.
FORM9: JMP TRYNEXT
GETNSP: LDA IN,Y
  INY
  CMP #$A0 ; GET NEXT NON BLANK CHAR
  BEQ GETNSP
  RTS

; Add filler bytes up to documented Mini-Assembler entry point at
; address $X666
.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0

;        .ORG $F666
MINIASM: JMP RESETZ

; Apple 1 specific code
.ifdef APPLE1

  LDA   ($3A,X)
  TAY
  LSR
  BCC   $7675
  LSR
  ORA   #$80
  JMP   $7893
  JMP   $789B
  LDA   #$7F ; Initialize 6820
  STA   $D012
  LDX   #$A7
  STX   $D011
  STX   $D013
  LDX   #$8B ; Initialize Serial Card 300 Baud
  STX   $D004
  LDX   #$96
  STX   $D005
  RTS
  BIT   $D012 ;Character Out
  BMI   $7690
  STA   $D012
  RTS
  CMP   #$9B ; Use Esc for line kill
  BNE   $769F
  LDA   #$98
  CMP   #$88 ; Use Control h for Backspace
  BNE   $76A5
  LDA   #$DF ; Underscore out
  RTS

.else

; Add filler bytes up to documented SWEET16 entry point at
; address $X689
.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

.endif

; ***********************
; *                     *
; * APPLE-II PSEUDO     *
; * MACHINE INTERPRETER *
; *                     *
; * COPYRIGHT 1977      *
; * APPLE COMPUTER INC  *
; *                     *
; * ALL RIGHTS RESERVED *
; * S. WOZNIAK          *
; *                     *
; ***********************
; TITLE "SWEET16 INTERPRETER"
R0L = $0
R0H = $1
R14H = $1D
R15L = $1E
R15H = $1F
SW16PAG = $F7
SAVE = $FF4A
RESTORE = $FF3F
;  .ORG $F689
SW16: JSR SAVE ; PRESERVE 6502 REG CONTENTS
  PLA
  STA R15L ; INIT SWEET16 PC
  PLA ; FROM RETURN
  STA R15H ; ADDRESS
SW16B: JSR SW16C ; INTERPRET AND EXECUTE
  JMP SW16B ; ONE SWEET16 INSTR.
SW16C: INC R15L
  BNE SW16D ; INCR SWEET16 PC FOR FETCH
  INC R15H
SW16D: LDA #SW16PAG
  PHA ; PUSH ON STACK FOR RTS
  LDY #$0
  LDA (R15L),Y ; FETCH INSTR
  AND #$F ; MASK REG SPECIFICATION
  ASL A ; DOUBLE FOR TWO BYTE REGISTERS
  TAX ; TO X REG FOR INDEXING
  LSR A
  EOR (R15L),Y ; NOW HAVE OPCODE
  BEQ TOBR ; IF ZERO THEN NON-REG OP
  STX R14H ; INDICATE'PRIOR RESULT REG'
  LSR A
  LSR A ; OPCODE*2 TO LSB'S
  LSR A
  TAY ; TO Y REG FOR INDEXING
  LDA OPTBL-2,Y ; LOW ORDER ADR BYTE
  PHA ; ONTO STACK
  RTS ; GOTO REG-OP ROUTINE
TOBR: INC R15L
  BNE TOBR2 ; INCR PC
  INC R15H
TOBR2: LDA BRTBL,X ; LOW ORDER ADR BYTE
  PHA ; ONTO STACK FOR NON-REG OP
  LDA R14H ; 'PRIOR RESULT REG' INDEX
  LSR A ; PREPARE CARRY FOR BC, BNC.
  RTS ; GOTO NON-REG OP ROUTINE
RTNZ: PLA ; POP RETURN ADDRESS
  PLA
  JSR RESTORE ; RESTORE 6502 REG CONTENTS
  JMP (R15L) ; RETURN TO 6502 CODE VIA PC
SETZ: LDA (R15L),Y ; HIGH-ORDER BYTE OF CONSTANT
  STA R0H,X
  DEY
  LDA (R15L),Y ; LOW-ORDER BYTE OF CONSTANT
  STA R0L,X
  TYA ; Y-REG CONTAINS 1
  SEC
  ADC R15L ; ADD 2 TO PC
  STA R15L
  BCC SET2
  INC R15H
SET2: RTS
OPTBL: .BYTE <SET-1 ; 1X
BRTBL: .BYTE <RTN-1 ; 0
  .BYTE <LD-1 ; 2X
  .BYTE <BR-1 ; 1
  .BYTE <ST-1 ; 3X
  .BYTE <BNC-1 ; 2
  .BYTE <LDAT-1 ; 4X
  .BYTE <BC-1 ; 3
  .BYTE <STAT-1 ; 5X
  .BYTE <BP-1 ; 4
  .BYTE <LDDAT-1 ; 6X
  .BYTE <BM-1 ; 5
  .BYTE <STDAT-1 ; 7X
  .BYTE <BZ-1 ; 6
  .BYTE <POP-1 ; 8X
  .BYTE <BNZ-1 ; 7
  .BYTE <STPAT-1 ; 9X
  .BYTE <BM1-1 ; 8
  .BYTE <ADD-1 ; AX
  .BYTE <BNM1-1 ; 9
  .BYTE <SUB-1 ; BX
  .BYTE <BK-1 ; A
  .BYTE <POPD-1 ; CX
  .BYTE <RS-1 ; B
  .BYTE <CPR-1 ; DX
  .BYTE <BS-1 ; C
  .BYTE <INR-1 ; EX
  .BYTE <NUL-1 ; D
  .BYTE <DCR-1 ; FX
  .BYTE <NUL-1 ; E
  .BYTE <NUL-1 ; UNUSED
  .BYTE <NUL-1 ; F
SET: BPL SETZ ; ALWAYS TAKEN
LD: LDA R0L,X
BK = LD+1
  STA R0L
  LDA R0H,X ; MOVE RX TO R0
  STA R0H
  RTS
ST: LDA R0L
  STA R0L,X ; MOVE R0 TO RX
  LDA R0H
  STA R0H,X
  RTS
STAT: LDA R0L
STAT2: STA (R0L,X) ; STORE BYTE INDIRECT
  LDY #$0
STAT3: STY R14H ; INDICATE R0 IS RESULT NEG
INR: INC R0L,X
  BNE INR2 ; INCR RX
  INC R0H,X
INR2: RTS
LDAT: LDA (R0L,X) ; LOAD INDIRECT (RX)
  STA R0L ; TO R0
  LDY #$0
  STY R0H ; ZERO HIGH-ORDER R0 BYTE
  BEQ STAT3 ; ALWAYS TAKEN
POP: LDY #$0 ; HIGH ORDER BYTE = 0
  BEQ POP2 ; ALWAYS TAKEN
POPD: JSR DCR ; DECR RX
  LDA (R0L,X) ; POP HIGH ORDER BYTE @RX
  TAY ; SAVE IN Y-REG
POP2: JSR DCR ; DECR RX
  LDA (R0L,X) ; LOW-ORDER BYTE
  STA R0L ; TO R0
  STY R0H
POP3: LDY #$0 ; INDICATE R0 AS LAST RESULT REG
  STY R14H
  RTS
LDDAT: JSR LDAT ; LOW-ORDER BYTE TO R0, INCR RX
  LDA (R0L,X) ; HIGH-ORDER BYTE TO R0
  STA R0H
  JMP INR ; INCR RX
STDAT: JSR STAT ; STORE INDIRECT LOW-ORDER
  LDA R0H ; BYTE AND INCR RX. THEN
  STA (R0L,X) ; STORE HIGH-ORDER BYTE.
  JMP INR ; INCR RX AND RETURN
STPAT: JSR DCR ; DECR RX
  LDA R0L
  STA (R0L,X) ; STORE R0 LOW BYTE @RX
  JMP POP3 ; INDICATE R0 AS LAST RSLT REG
DCR: LDA R0L,X
  BNE DCR2 ; DECR RX
  DEC R0H,X
DCR2: DEC R0L,X
  RTS
SUB: LDY #$0 ; RESULT TO R0
CPR: SEC ; NOTE Y-REG = 13*2 FOR CPR
  LDA R0L
  SBC R0L,X
  STA R0L,Y ; R0-RX TO RY
  LDA R0H
  SBC R0H,X
SUB2: STA R0H,Y
  TYA ; LAST RESULT REG*2
  ADC #$0 ; CARRY TO LSB
  STA R14H
  RTS
ADD: LDA R0L
  ADC R0L,X
  STA R0L ; R0+RX TO R0
  LDA R0H
  ADC R0H,X
  LDY #$0 ; R0 FOR RESULT
  BEQ SUB2 ; FINISH ADD
BS: LDA R15L ; NOTE X-REG IS 12*2!
  JSR STAT2 ; PUSH LOW PC BYTE VIA R12
  LDA R15H
  JSR STAT2 ; PUSH HIGH-ORDER PC BYTE
BR: CLC
BNC: BCS BNC2 ; NO CARRY TEST
BR1: LDA (R15L),Y ; DISPLACEMENT BYTE
  BPL BR2
  DEY
BR2: ADC R15L ; ADD TO PC
  STA R15L
  TYA
  ADC R15H
  STA R15H
BNC2: RTS
BC: BCS BR
  RTS
BP: ASL A ; DOUBLE RESULT-REG INDEX
  TAX ; TO X REG FOR INDEXING
  LDA R0H,X ; TEST FOR PLUS
  BPL BR1 ; BRANCH IF SO
  RTS
BM: ASL A ; DOUBLE RESULT-REG INDEX
  TAX
  LDA R0H,X ; TEST FOR MINUS
  BMI BR1
  RTS
BZ: ASL A ; DOUBLE RESULT-REG INDEX
  TAX
  LDA R0L,X ; TEST FOR ZERO
  ORA R0H,X ; (BOTH BYTES)
  BEQ BR1 ; BRANCH IF SO
  RTS
BNZ: ASL A ; DOUBLE RESULT-REG INDEX
  TAX
  LDA R0L,X ; TEST FOR NON-ZERO
  ORA R0H,X ; (BOTH BYTES)
  BNE BR1 ; BRANCH IF SO
  RTS
BM1: ASL A ; DOUBLE RESULT-REG INDEX
  TAX
  LDA R0L,X ; CHECK BOTH BYTES
  AND R0H,X ; FOR $FF (MINUS 1)
  EOR #$FF
  BEQ BR1 ; BRANCH IF SO
  RTS
BNM1: ASL A ; DOUBLE RESULT-REG INDEX
  TAX
  LDA R0L,X
  AND R0H,X ; CHECK BOTH BYTES FOR NO $FF
  EOR #$FF
  BNE BR1 ; BRANCH IF NOT MINUS 1
NUL: RTS
RS: LDX #$18 ; 12*2 FOR R12 AS STACK POINTER
  JSR DCR ; DECR STACK POINTER
  LDA (R0L,X) ; POP HIGH RETURN ADDRESS TO PC
  STA R15H
  JSR DCR ; SAME FOR LOW-ORDER BYTE
  LDA (R0L,X)
  STA R15L
 RTS
RTN: JMP RTNZ

; ***************************
; *                         *
; * APPLE II                *
; * SYSTEM MONITOR          *
; *                         *
; * COPYRIGHT 1977 BY       *
; * APPLE COMPUTER, INC.    *
; *                         *
; * ALL RIGHTS RESERVED     *
; *                         *
; * S. WOZNIAK              *
; * A. BAUM                 *
; *                         *
; ***************************
; TITLE "APPLE II SYSTEM MONITOR"
LOC0 = $00
LOC1 = $01
WNDLFT = $20
WNDWDTH = $21
WNDTOP = $22
WNDBTM = $23
CH = $24
CV = $25
GBASL = $26
GBASH = $27
BASL = $28
BASH = $29
BAS2L = $2A
BAS2H = $2B
H2 = $2C
LMNEM = $2C
RTNL = $2C
V2 = $2D
RMNEM = $2D
RTNH = $2D
MASK = $2E
CHKSUM = $2E
; FORMAT = $2E
LASTIN = $2F
; LENGTH = $2F
SIGN = $2F
COLOR = $30
; MODE = $31
INVFLG = $32
; PROMPT = $33
; YSAV = $34
YSAV1 = $35
CSWL = $36
CSWH = $37
KSWL = $38
KSWH = $39
; PCL = $3A
; PCH = $3B
XQT = $3C
A1L = $3C
; A1H = $3D
;A2L = $3E
;A2H = $3F
A3L = $40
A3H = $41
;A4L = $42
;A4H = $43
A5L = $44
A5H = $45
ACC = $45
XREG = $46
YREG = $47
STATUS = $48
SPNT = $49
RNDL = $4E
RNDH = $4F
ACL = $50
ACH = $51
XTNDL = $52
XTNDH = $53
AUXL = $54
AUXH = $55
PICK = $95
; IN = $0200
USRADR = $03F8
NMI = $03FB
IRQLOC = $03FE
IOADR = $C000
KBD = $C000
KBDSTRB = $C010
TAPEOUT = $C020
SPKR = $C030
TXTCLR = $C050
TXTSET = $C051
MIXCLR = $C052
MIXSET = $C053
LOWSCR = $C054
HISCR = $C055
LORES = $C056
HIRES = $C057
TAPEIN = $C060
PADDL0 = $C064
PTRIG = $C070
BASIC = $E000
BASIC2 = $E003
; ORG $F800 ROM START ADDRESS
PLOT: LSR ; Y-COORD/2
  PHP ; SAVE LSB IN CARRY
  JSR GBASCALC ; CALC BASE ADR IN GBASL,H
  PLP ; RESTORE LSB FROM CARRY
  LDA #$0F ; MASK $0F IF EVEN
  BCC RTMASK
  ADC #$E0 ; MASK $F0 IF ODD
RTMASK: STA MASK
PLOT1: LDA (GBASL),Y ; DATA
  EOR COLOR ; EOR COLOR
  AND MASK ; AND MASK
  EOR (GBASL),Y ; XOR DATA
  STA (GBASL),Y ; TO DATA
  RTS
HLINE: JSR PLOT ; PLOT SQUARE
HLINE1: CPY H2 ; DONE?
  BCS RTS1 ; YES, RETURN
  INY ; NO, INCR INDEX (X-COORD)
  JSR PLOT1 ; PLOT NEXT SQUARE
  BCC HLINE1 ; ALWAYS TAKEN
VLINEZ: ADC #$01 ; NEXT Y-COORD
VLINE: PHA ; SAVE ON STACK
  JSR PLOT ; PLOT SQUARE
  PLA
  CMP V2 ; DONE?
  BCC VLINEZ ; NO, LOOP
RTS1: RTS
CLRSCR: LDY #$2F ; MAX Y, FULL SCRN CLR
  BNE CLRSC2 ; ALWAYS TAKEN
CLRTOP: LDY #$27 ; MAX Y, TOP SCREEN CLR
CLRSC2: STY V2 ; STORE AS BOTTOM COORD
; FOR VLINE CALLS
  LDY #$27 ; RIGHTMOST X-COORD (COLUMN)
CLRSC3: LDA #$00 ; TOP COORD FOR VLINE CALLS
  STA COLOR ; CLEAR COLOR (BLACK)
  JSR VLINE ; DRAW VLINE
  DEY ; NEXT LEFTMOST X-COORD
  BPL CLRSC3 ; LOOP UNTIL DONE
  RTS
GBASCALC: PHA ; FOR INPUT 000DEFGH
  LSR
  AND #$03
  ORA #$04 ; GENERATE GBASH=000001FG
  STA GBASH
  PLA ; AND GBASL=HDEDE000
  AND #$18
  BCC GBCALC
  ADC #$7F
GBCALC: STA GBASL
  ASL A
  ASL A
  ORA GBASL
  STA GBASL
  RTS
NXTCOL: LDA COLOR ; INCREMENT COLOR BY 3
  CLC
  ADC #$03
SETCOL: AND #$0F ; SETS COLOR=17*A MOD 16
  STA COLOR
  ASL A ; BOTH HALF BYTES OF COLOR EQUAL
  ASL A
  ASL A
  ASL A
  ORA COLOR
  STA COLOR
  RTS
SCRN: LSR A ; READ SCREEN Y-COORD/2
  PHP ; SAVE LSB (CARRY)
  JSR GBASCALC ; CALC BASE ADDRESS
  LDA (GBASL),Y ; GET BYTE
  PLP ; RESTORE LSB FROM CARRY
SCRN2: BCC RTMSKZ ; IF EVEN, USE LO H
  LSR A
  LSR A
  LSR A ; SHIFT HIGH HALF BYTE DOWN
  LSR A
RTMSKZ: AND #$0F ; MASK 4-BITS
  RTS
INSDS1: LDX PCL ; PRINT PCL,H
  LDY PCH
  JSR PRYX2
  JSR PRBLNK ; FOLLOWED BY A BLANK
  LDA (PCL,X) ; GET OP CODE
INSDS2: TAY
  LSR A ; EVEN/ODD TEST
  BCC IEVEN
  ROR ; BIT 1 TEST
  BCS @ERR ; XXXXXX11 INVALID OP
  CMP #$A2
  BEQ @ERR ; OPCODE $89 INVALID
  AND #$87 ; MASK BITS
IEVEN: LSR A ; LSB INTO CARRY FOR L/R TEST
  TAX
  LDA FMT1,X ; GET FORMAT INDEX BYTE
  JSR SCRN2 ; R/L H-BYTE ON CARRY
  BNE GETFMT
@ERR: LDY #$80 ; SUBSTITUTE $80 FOR INVALID OPS
  LDA #$00 ; SET PRINT FORMAT INDEX TO 0
GETFMT: TAX
  LDA FMT2,X ; INDEX INTO PRINT FORMAT TABLE
  STA FORMAT ; SAVE FOR ADR FIELD FORMATTING
  AND #$03 ; MASK FOR 2-BIT LENGTH (P=1 BYTE, 1=2 BYTE, 2=3 BYTE)
  STA LENGTH
  TYA ; OPCODE
  AND #$8F ; MASK FOR 1XXX1010 TEST
  TAX ; SAVE IT
  TYA ; OPCODE TO A AGAIN
  LDY #$03
  CPX #$8A
  BEQ MNNDX3
MNNDX1: LSR A
  BCC MNNDX3 ; FORM INDEX INTO MNEMONIC TABLE
  LSR A
MNNDX2: LSR A ; 1) 1XXX1010-&gt00101XXX
  ORA #$20 ; 2) XXXYYY01-&gt00111XXX
  DEY ; 3) XXXYYY10-&gt00110XXX
  BNE MNNDX2 ; 4) XXXYY100-&gt00100XXX
  INY ; 5) XXXXX000-&gt000XXXXX
MNNDX3: DEY
  BNE MNNDX1
  RTS
  .BYTE $FF,$FF,$FF
INSTDSP: JSR INSDS1 ; GEN FMT, LEN BYTES
  PHA ; SAVE MNEMONIC TABLE INDEX
PRNTOP: LDA (PCL),Y
  JSR PRBYTE
  LDX #$01 ; PRINT 2 BLANKS
PRNTBL: JSR PRBL2
  CPY LENGTH ; PRINT INST (1-3 BYTES)
  INY ; IN A 12 CHR FIELD
  BCC PRNTOP
  LDX #$03 ; CHAR COUNT FOR MNEMONIC PRINT
  CPY #$04
  BCC PRNTBL
  PLA ; RECOVER MNEMONIC INDEX
  TAY
  LDA MNEML,Y
  STA LMNEM ; FETCH 3-CHAR MNEMONIC
  LDA MNEMR,Y ; (PACKED IN 2-BYTES)
  STA RMNEM
PRMN1: LDA #$00
  LDY #$05
PRMN2: ASL ; RMNEM SHIFT 5 BITS OF
  ROL LMNEM ; CHARACTER INTO A
  ROL ; (CLEARS CARRY)
  DEY
  BNE PRMN2
  ADC #$BF ; ADD "?" OFFSET
  JSR COUT ; OUTPUT A CHAR OF MNEM
  DEX
  BNE PRMN1
  JSR PRBLNK ; OUTPUT 3 BLANKS
  LDY LENGTH
  LDX #$06 ; CNT FOR 6 FORMAT BITS
PRADR1: CPX #$03
  BEQ PRADR5 ; IF X=3 THEN ADDR.
PRADR2: ASL FORMAT
  BCC PRADR3
  LDA CHAR1-1,X
  JSR COUT
  LDA CHAR2-1,X
  BEQ PRADR3
  JSR COUT
PRADR3: DEX
  BNE PRADR1
  RTS
PRADR4: DEY
  BMI PRADR2
  JSR PRBYTE
PRADR5: LDA FORMAT
  CMP #$E8 ; HANDLE REL ADR MODE
  LDA (PCL),Y ; SPECIAL (PRINT TARGET,
  BCC PRADR4 ; NOT OFFSET)
RELADR: JSR PCADJ3
  TAX ; PCL,PCH+OFFSET+1 TO A,Y
  INX
  BNE PRNTYX ; +1 TO Y,X
  INY
PRNTYX: TYA
PRNTAX: JSR PRBYTE ; OUTPUT TARGET ADR
PRNTX: TXA ; OF BRANCH AND RETURN
  JMP PRBYTE
PRBLNK: LDX #$03 ; BLANK COUNT
PRBL2: LDA #$A0 ; LOAD A SPACE
PRBL3: JSR COUT ; OUTPUT A BLANK
  DEX
  BNE PRBL2 ; LOOP UNTIL COUNT=0
  RTS
PCADJ: SEC ; 0=1-BYTE, 1=2-BYTE
PCADJ2: LDA LENGTH ; 2=3-BYTE
PCADJ3: LDY PCH
  TAX ; TEST DISPLACEMENT SIGN
  BPL PCADJ4 ; (FOR REL BRANCH)
  DEY ; EXTEND NEG BY DEC PCH
PCADJ4: ADC PCL
  BCC RTS2 ; PCL+LENGTH(OR DISPL)+1 TO A
  INY ; CARRY INTO Y (PCH)
RTS2: RTS
; FMT1 BYTES: XXXXXXY0 INSTRS
; IF Y=0 THEN LEFT HALF BYTE
; IF Y=1 THEN RIGHT HALF BYTE
; (X=INDEX)
FMT1: .BYTE $04,$20,$54,$30,$0D
  .BYTE $80,$04,$90,$03,$22
  .BYTE $54,$33,$0D,$80,$04
  .BYTE $90,$04,$20,$54,$33
  .BYTE $0D,$80,$04,$90,$04
  .BYTE $20,$54,$3B,$0D,$80
  .BYTE $04,$90,$00,$22,$44
  .BYTE $33,$0D,$C8,$44,$00
  .BYTE $11,$22,$44,$33,$0D
  .BYTE $C8,$44,$A9,$01,$22
  .BYTE $44,$33,$0D,$80,$04
  .BYTE $90,$01,$22,$44,$33
  .BYTE $0D,$80,$04,$90
  .BYTE $26,$31,$87,$9A ; $ZZXXXY01 INSTR'S
FMT2: .BYTE $00 ; ERR
  .BYTE $21 ; IMM
  .BYTE $81 ; Z-PAGE
  .BYTE $82 ; ABS
  .BYTE $00 ; IMPLIED
  .BYTE $00 ; ACCUMULATOR
  .BYTE $59 ; (ZPAG,X)
  .BYTE $4D ; (ZPAG),Y
  .BYTE $91 ; ZPAG,X
  .BYTE $92 ; ABS,X
  .BYTE $86 ; ABS,Y
  .BYTE $4A ; (ABS)
  .BYTE $85 ; ZPAG,Y
  .BYTE $9D ; RELATIVE
CHAR1: .byte ",),#($"
CHAR2: .BYTE $D9,$00,$D8,$A4,$A4,$00
; CHAR2: "Y",0,"X$$",0
; MNEML IS OF FORM:
; (A) XXXXX000
; (B) XXXYY100
; (C) 1XXX1010
; (D) XXXYYY10
; (E) XXXYYY01
; (X=INDEX)
MNEML: .BYTE $1C,$8A,$1C,$23,$5D,$8B
  .BYTE $1B,$A1,$9D,$8A,$1D,$23
  .BYTE $9D,$8B,$1D,$A1,$00,$29
  .BYTE $19,$AE,$69,$A8,$19,$23
  .BYTE $24,$53,$1B,$23,$24,$53
  .BYTE $19,$A1 ; (A) FORMAT ABOVE
  .BYTE $00,$1A,$5B,$5B,$A5,$69
  .BYTE $24,$24 ; (B) FORMAT
  .BYTE $AE,$AE,$A8,$AD,$29,$00
  .BYTE $7C,$00 ; (C) FORMAT
  .BYTE $15,$9C,$6D,$9C,$A5,$69
  .BYTE $29,$53 ; (D) FORMAT
  .BYTE $84,$13,$34,$11,$A5,$69
  .BYTE $23,$A0 ; (E) FORMAT
MNEMR: .BYTE $D8,$62,$5A,$48,$26,$62
  .BYTE $94,$88,$54,$44,$C8,$54
  .BYTE $68,$44,$E8,$94,$00,$B4
  .BYTE $08,$84,$74,$B4,$28,$6E
  .BYTE $74,$F4,$CC,$4A,$72,$F2
  .BYTE $A4,$8A ; (A) FORMAT
  .BYTE $00,$AA,$A2,$A2,$74,$74
  .BYTE $74,$72 ; (B) FORMAT
  .BYTE $44,$68,$B2,$32,$B2,$00
  .BYTE $22,$00 ; (C) FORMAT
  .BYTE $1A,$1A,$26,$26,$72,$72
  .BYTE $88,$C8 ; (D) FORMAT
  .BYTE $C4,$CA,$26,$48,$44,$44
  .BYTE $A2,$C8 ; (E) FORMAT
  .BYTE $FF,$FF,$FF
STEP: JSR INSTDSP ; DISASSEMBLE ONE INST
  PLA ; AT (PCL,H)
  STA RTNL ; ADJUST TO USER
  PLA ; STACK. SAVE
  STA RTNH ; RTN ADR.
  LDX #$08
XQINIT: LDA INITBL-1,X ; INIT XEQ AREA
  STA XQT,X
  DEX
  BNE XQINIT
  LDA (PCL,X) ; USER OPCODE BYTE
  BEQ XBRK ; SPECIAL IF BREAK
  LDY LENGTH ; LEN FROM DISASSEMBLY
  CMP #$20
  BEQ XJSR ; HANDLE JSR, RTS, JMP,
  CMP #$60 ; JMP (), RTI SPECIAL
  BEQ XRTS
  CMP #$4C
  BEQ XJMP
  CMP #$6C
  BEQ XJMPAT
  CMP #$40
  BEQ XRTI
  AND #$1F
  EOR #$14
  CMP #$04 ; COPY USER INST TO XEQ AREA
  BEQ XQ2 ; WITH TRAILING NOPS
XQ1: LDA (PCL),Y ; CHANGE REL BRANCH
XQ2: STA XQT,Y ; DISP TO 4 FOR
  DEY ; JMP TO BRANCH OR
  BPL XQ1 ; NBRANCH FROM XEQ.
  JSR RESTORE ; RESTORE USER REG CONTENTS.
  JMP XQT ; XEQ USER OP FROM RAM
IRQ: STA ACC ; (RETURN TO NBRANCH)
  PLA
  PHA ; **IRQ HANDLER
  ASL A
  ASL A
  ASL A
  BMI BREAK ; TEST FOR BREAK
  JMP (IRQLOC) ; USER ROUTINE VECTOR IN RAM
BREAK: PLP
  JSR SAV1 ; SAVE REG'S ON BREAK
  PLA ; INCLUDING PC
  STA PCL
  PLA
  STA PCH
XBRK: JSR INSDS1 ; PRINT USER PC.
  JSR RGDSP1 ; AND REG'S
  JMP MON ; GO TO MONITOR
XRTI: CLC
  PLA ; SIMULATE RTI BY EXPECTING
  STA STATUS ; STATUS FROM STACK, THEN RTS
XRTS: PLA ; RTS SIMULATION
  STA PCL ; EXTRACT PC FROM STACK
  PLA ; AND UPDATE PC BY 1 (LEN=0)
PCINC2: STA PCH
PCINC3: LDA LENGTH ; UPDATE PC BY LEN
  JSR PCADJ3
  STY PCH
  CLC
  BCC NEWPCL
XJSR: CLC
  JSR PCADJ2 ; UPDATE PC AND PUSH
  TAX ; ONTO STACH FOR
  TYA ; JSR SIMULATE
  PHA
  TXA
  PHA
  LDY #$02
XJMP: CLC
XJMPAT: LDA (PCL),Y
  TAX ; LOAD PC FOR JMP,
  DEY ; (JMP) SIMULATE.
  LDA (PCL),Y
  STX PCH
NEWPCL: STA PCL
  BCS XJMP
RTNJMP: LDA RTNH
  PHA
  LDA RTNL
  PHA
REGDSP: JSR CROUT ; DISPLAY USER REG
RGDSP1: LDA #ACC ; CONTENTS WITH
  STA A3L ; LABELS
  LDA #ACC/256
  STA A3H
  LDX #$FB
RDSP1: LDA #$A0
  JSR COUT
  LDA RTBL-$FB,X
  JSR COUT
  LDA #$BD
  JSR COUT
  LDA ACC+5,X
  JSR PRBYTE
  INX
  BMI RDSP1
  RTS
BRANCH: CLC ; BRANCH TAKEN,
  LDY #$01 ; ADD LEN+2 TO PC
  LDA (PCL),Y
  JSR PCADJ3
  STA PCL
  TYA
  SEC
  BCS PCINC2
NBRNCH: JSR SAVE ; NORMAL RETURN AFTER
  SEC ; XEQ USER OF
  BCS PCINC3 ; GO UPDATE PC
INITBL: NOP
  NOP ; DUMMY FILL FOR
  JMP NBRNCH ; XEQ AREA
  JMP BRANCH
RTBL: .BYTE $C1
  .BYTE $D8
  .BYTE $D9
  .BYTE $D0
  .BYTE $D3
PREAD: LDA PTRIG ; TRIGGER PADDLES
  LDY #$00 ; INIT COUNT
  NOP ; COMPENSATE FOR 1ST COUNT
  NOP
PREAD2: LDA PADDL0,X ; COUNT Y-REG EVERY
  BPL RTS2D ; 12 USEC
  INY
  BNE PREAD2 ; EXIT AT 255 MAX
  DEY
RTS2D: RTS
INIT: LDA #$00 ; CLR STATUS FOR DEBUG
  STA STATUS ; SOFTWARE
  LDA LORES
  LDA LOWSCR ; INIT VIDEO MODE
SETTXT: LDA TXTSET ; SET FOR TEXT MODE
  LDA #$00 ; FULL SCREEN WINDOW
  BEQ SETWND
SETGR: LDA TXTCLR ; SET FOR GRAPHICS MODE
  LDA MIXSET ; LOWER 4 LINES AS
  JSR CLRTOP ; TEXT WINDOW
  LDA #$14
SETWND: STA WNDTOP ; SET FOR 40 COL WINDOW
  LDA #$00 ; TOP IN A-REG,
  STA WNDLFT ; BTTM AT LINE 24
  LDA #$28
  STA WNDWDTH
  LDA #$18
  STA WNDBTM ; VTAB TO ROW 23
  LDA #$17
TABV: STA CV ; VTABS TO ROW IN A-REG
  JMP VTAB
MULPM: JSR MD1 ; ABS VAL OF AC AUX
MUL: LDY #$10 ; INDEX FOR 16 BITS
MUL2: LDA ACL ; ACX * AUX + XTND
  LSR A ; TO AC, XTND
  BCC MUL4 ; IF NO CARRY,
  CLC ; NO PARTIAL PROD.
  LDX #$FE
MUL3: LDA XTNDL+2,X ; ADD MPLCND (AUX)
  ADC AUXL+2,X ; TO PARTIAL PROD
  STA XTNDL+2,X ; (XTND)
  INX
  BNE MUL3
MUL4: LDX #$03
MUL5: .BYTE $76
  .BYTE $50
  DEX
  BPL MUL5
  DEY
  BNE MUL2
  RTS
DIVPM: JSR MD1 ; ABS VAL OF AC, AUX.
DIV: LDY #$10 ; INDEX FOR 16 BITS
DIV2: ASL ACL
  ROL ACH
  ROL XTNDL ; XTND/AUX
  ROL XTNDH ; TO AC.
  SEC
  LDA XTNDL
  SBC AUXL ; MOD TO XTND.
  TAX
  LDA XTNDH
  SBC AUXH
  BCC DIV3
  STX XTNDL
  STA XTNDH
  INC ACL
DIV3: DEY
  BNE DIV2
  RTS
MD1: LDY #$00 ; ABS VAL OF AC, AUX
  STY SIGN ; WITH RESULT SIGN
  LDX #AUXL ; IN LSB OF SIGN.
  JSR MD3
  LDX #ACL
MD3: LDA LOC1,X ; X SPECIFIES AC OR AUX
  BPL MDRTS
  SEC
  TYA
  SBC LOC0,X ; COMPL SPECIFIED REG
  STA LOC0,X ; IF NEG.
  TYA
  SBC LOC1,X
  STA LOC1,X
  INC SIGN
MDRTS: RTS
BASCALC: PHA ; CALC BASE ADR IN BASL,H
  LSR A ; FOR GIVEN LINE NO
  AND #$03 ; 0&lt=LINE NO.&lt=$17
  ORA #$04 ; ARG=000ABCDE, GENERATE
  STA BASH ; BASH=000001CD
  PLA ; AND
  AND #$18 ; BASL=EABAB000
  BCC BSCLC2
  ADC #$7F
BSCLC2: STA BASL
  ASL
  ASL
  ORA BASL
  STA BASL
  RTS
BELL1: CMP #$87 ; BELL CHAR? (CNTRL-G)
  BNE RTS2B ; NO, RETURN
  LDA #$40 ; DELAY .01 SECONDS
  JSR WAIT
  LDY #$C0
BELL2: LDA #$0C ; TOGGLE SPEAKER AT
  JSR WAIT ; 1 KHZ FOR .1 SEC.
  LDA SPKR
  DEY
  BNE BELL2
RTS2B: RTS
STOADV: LDY CH ; CURSOR H INDEX TO Y-REG
  STA (BASL),Y ; STORE CHAR IN LINE
ADVANCE: INC CH ; INCREMENT CURSOR H INDEX
  LDA CH ; (MOVE RIGHT)
  CMP WNDWDTH ; BEYOND WINDOW WIDTH?
  BCS CR ; YES CR TO NEXT LINE
RTS3: RTS ; NO,RETURN
VIDOUT: CMP #$A0 ; CONTROL CHAR?
  BCS STOADV ; NO,OUTPUT IT.
  TAY ; INVERSE VIDEO?
  BPL STOADV ; YES, OUTPUT IT.
  CMP #$8D ; CR?
  BEQ CR ; YES.
  CMP #$8A ; LINE FEED?
  BEQ LF ; IF SO, DO IT.
  CMP #$88 ; BACK SPACE? (CNTRL-H)
  BNE BELL1 ; NO, CHECK FOR BELL.
@BS: DEC CH ; DECREMENT CURSOR H INDEX
  BPL RTS3 ; IF POS, OK. ELSE MOVE UP
  LDA WNDWDTH ; SET CH TO WNDWDTH-1
  STA CH
 DEC CH ; (RIGHTMOST SCREEN POS)
UP: LDA WNDTOP ; CURSOR V INDEX
  CMP CV
  BCS RTS4 ; IF TOP LINE THEN RETURN
  DEC CV ; DEC CURSOR V-INDEX
VTAB: LDA CV ; GET CURSOR V-INDEX
VTABZ: JSR BASCALC ; GENERATE BASE ADR
  ADC WNDLFT ; ADD WINDOW LEFT INDEX
  STA BASL ; TO BASL
RTS4: RTS
ESC1: EOR #$C0 ; ESC?
F0 28 BEQ HOME IF SO, DO HOME AND CLEAR
69 FD ADC #$FD ESC-A OR B CHECK
90 C0 BCC ADVANCE A, ADVANCE
F0 DA BEQ @BS B, BACKSPACE
69 FD ADC #$FD ESC-C OR D CHECK
90 2C BCC LF C, DOWN
F0 DE BEQ UP D, GO UP
69 FD ADC #$FD ESC-E OR F CHECK
90 5C BCC CLREOL E, CLEAR TO END OF LINE
D0 E9 BNE RTS4 NOT F, RETURN
A4 24 CLREOP LDY CH CURSOR H TO Y INDEX
A5 25 LDA CV CURSOR V TO A-REGISTER
48 CLEOP1 PHA SAVE CURRENT LINE ON STK
20 24 FC JSR VTABZ CALC BASE ADDRESS
20 9E FC JSR CLEOLZ CLEAR TO EOL, SET CARRY
A0 00 LDY #$00 CLEAR FROM H INDEX=0 FOR REST
68 PLA INCREMENT CURRENT LINE
69 00 ADC #$00 (CARRY IS SET)
C5 23 CMP WNDBTM DONE TO BOTTOM OF WINDOW?
90 F0 BCC CLEOP1 NO, KEEP CLEARING LINES
B0 CA BCS VTAB YES, TAB TO CURRENT LINE
A5 22 HOME LDA WNDTOP INIT CURSOR V
85 25 STA CV AND H-INDICES
A0 00 LDY #$00
84 24 STY CH THEN CLEAR TO END OF PAGE
F0 E4 BEQ CLEOP1
A9 00 CR LDA #$00 CURSOR TO LEFT OF INDEX
85 24 STA CH (RET CURSOR H=0)
E6 25 LF INC CV INCR CURSOR V(DOWN 1 LINE)
A5 25 LDA CV
C5 23 CMP WNDBTM OFF SCREEN?
90 B6 BCC VTABZ NO, SET BASE ADDR
C6 25 DEC CV DECR CURSOR V (BACK TO BOTTOM)
A5 22 SCROLL LDA WNDTOP START AT TOP OF SCRL WNDW
48 PHA
20 24 FC JSR VTABZ GENERATE BASE ADR
A5 28 SCRL1 LDA BASL COPY BASL,H
85 2A STA BAS2L TO BAS2L,H
A5 29 LDA BASH
85 2B STA BAS2H
A4 21 LDY WNDWDTH INIT Y TO RIGHTMOST INDEX
88 DEY OF SCROLLING WINDOW
68 PLA
69 01 ADC #$01 INCR LINE NUMBER
C5 23 CMP WNDBTM DONE?
B0 0D BCS SCRL3 YES, FINISH
48 PHA
20 24 FC JSR VTABZ FORM BASL,H (BASE ADDR)
B1 28 SCRL2 LDA (BASL),Y MOVE A CHR UP ON LINE
91 2A STA (BAS2L),Y
88 DEY NEXT CHAR OF LINE
10 F9 BPL SCRL2
30 E1 BMI SCRL1 NEXT LINE (ALWAYS TAKEN)
A0 00 SCRL3 LDY #$00 CLEAR BOTTOM LINE
20 9E FC JSR CLEOLZ GET BASE ADDR FOR BOTTOM LINE
B0 86 BCS VTAB CARRY IS SET
A4 24 CLREOL LDY CH CURSOR H INDEX
A9 A0 CLEOLZ LDA #$A0
91 28 CLEOL2 STA (BASL),Y STORE BLANKS FROM 'HERE'
C8 INY TO END OF LINES (WNDWDTH)
C4 21 CPY WNDWDTH
90 F9 BCC CLEOL2
60 RTS
38 WAIT SEC
48 WAIT2 PHA
E9 01 WAIT3 SBC #$01
D0 FC BNE WAIT3 1.0204 USEC
68 PLA (13+27/2*A+5/2*A*A)
E9 01 SBC #$01
D0 F6 BNE WAIT2
60 RTS
E6 42 NXTA4 INC A4L INCR 2-BYTE A4
D0 02 BNE NXTA1 AND A1
E6 43 INC A4H
A5 3C NXTA1 LDA A1L INCR 2-BYTE A1.
C5 3E CMP A2L
A5 3D LDA A1H AND COMPARE TO A2
E5 3F SBC A2H
E6 3C INC A1L (CARRY SET IF &gt=)
D0 02 BNE RTS4B
E6 3D INC A1H
60 RTS4B RTS
A0 4B HEADR LDY #$4B WRITE A*256 'LONG 1'
20 DB FC JSR ZERDLY HALF CYCLES
D0 F9 BNE HEADR (650 USEC EACH)
69 FE ADC #$FE
B0 F5 BCS HEADR THEN A 'SHORT 0'
A0 21 LDY #$21 (400 USEC)
20 DB FC WRBIT JSR ZERDLY WRITE TWO HALF CYCLES
C8 INY OF 250 USEC ('0')
C8 INY OR 500 USEC ('0')
88 ZERDLY DEY
D0 FD BNE ZERDLY
90 05 BCC WRTAPE Y IS COUNT FOR
A0 32 LDY #$32 TIMING LOOP
88 ONEDLY DEY
D0 FD BNE ONEDLY
AC 20 C0 WRTAPE LDY TAPEOUT
A0 2C LDY #$2C
CA DEX
60 RTS
A2 08 RDBYTE LDX #$08 8 BITS TO READ
48 RDBYT2 PHA READ TWO TRANSITIONS
20 FA FC JSR RD2BIT (FIND EDGE)
68 PLA
2A ROL NEXT BIT
A0 3A LDY #$3A COUNT FOR SAMPLES
CA DEX
D0 F5 BNE RDBYT2
60 RTS
20 FD FC RD2BIT JSR RDBIT
88 RDBIT DEY DECR Y UNTIL
AD 60 C0 LDA TAPEIN TAPE TRANSITION
45 2F EOR LASTIN
10 F8 BPL RDBIT
45 2F EOR LASTIN
85 2F STA LASTIN
C0 80 CPY #$80 SET CARRY ON Y
60 RTS
A4 24 RDKEY LDY CH
B1 28 LDA (BASL),Y SET SCREEN TO FLASH
48 PHA
29 3F AND #$3F
09 40 ORA #$40
91 28 STA (BASL),Y
68 PLA
6C 38 00 JMP (KSWL) GO TO USER KEY-IN
E6 4E KEYIN INC RNDL
D0 02 BNE KEYIN2 INCR RND NUMBER
E6 4F INC RNDH
2C 00 C0 KEYIN2 BIT KBD KEY DOWN?
10 F5 BPL KEYIN LOOP
91 28 STA (BASL),Y REPLACE FLASHING SCREEN
AD 00 C0 LDA KBD GET KEYCODE
2C 10 C0 BIT KBDSTRB CLR KEY STROBE
60 RTS
20 0C FD ESC JSR RDKEY GET KEYCODE
20 2C FC JSR ESC1 HANDLE ESC FUNC.
20 0C FD RDCHAR JSR RDKEY READ KEY
C9 9B CMP #$9B ESC?
F0 F3 BEQ ESC YES, DON'T RETURN
60 RTS
A5 32 NOTCR LDA INVFLG
48 PHA
A9 FF LDA #$FF
85 32 STA INVFLG ECHO USER LINE
BD 00 02 LDA IN,X NON INVERSE
20 ED FD JSR COUT
68 PLA
85 32 STA INVFLG
BD 00 02 LDA IN,X
C9 88 CMP #$88 CHECK FOR EDIT KEYS
F0 1D BEQ BCKSPC @BS, CTRL-X
C9 98 CMP #$98
F0 0A BEQ CANCEL
E0 F8 CPX #$F8 MARGIN?
90 03 BCC NOTCR1
20 3A FF JSR BELL YES, SOUND BELL
E8 NOTCR1 INX ADVANCE INPUT INDEX
D0 13 BNE NXTCHAR
A9 DC CANCEL LDA #$DC BACKSLASH AFTER CANCELLED LINE
20 ED FD JSR COUT
20 8E FD GETLNZ JSR CROUT OUTPUT CR
A5 33 GETLN LDA PROMPT
20 ED FD JSR COUT OUTPUT PROMPT CHAR
A2 01 LDX #$01 INIT INPUT INDEX
8A BCKSPC TXA WILL BACKSPACE TO 0
F0 F3 BEQ GETLNZ
CA DEX
20 35 FD NXTCHAR JSR RDCHAR
C9 95 CMP #PICK USE SCREEN CHAR
D0 02 BNE CAPTST FOR CTRL-U
B1 28 LDA (BASL),Y
C9 E0 CAPTST CMP #$E0
90 02 BCC ADDINP CONVERT TO CAPS
29 DF AND #$DF
9D 00 02 ADDINP STA IN,X ADD TO INPUT BUF
C9 8D CMP #$8D
D0 B2 BNE NOTCR
20 9C FC JSR CLREOL CLR TO EOL IF CR
A9 8D CROUT LDA #$8D
D0 5B BNE COUT
A4 3D PRA1 LDY A1H PRINT CR,A1 IN HEX
A6 3C LDX A1L
20 8E FD PRYX2 JSR CROUT
20 40 F9 JSR PRNTYX
A0 00 LDY #$00
A9 AD LDA #$AD PRINT '-'
4C ED FD JMP COUT
A5 3C XAM8 LDA A1L
09 07 ORA #$07 SET TO FINISH AT
85 3E STA A2L MOD 8=7
A5 3D LDA A1H
85 3F STA A2H
A5 3C MODSCHK LDA A1L
29 07 AND #$07
D0 03 BNE DATAOUT
20 92 FD XAM JSR PRA1
A9 A0 DATAOUT LDA #$A0
20 ED FD JSR COUT OUTPUT BLANK
B1 3C LDA (A1L),Y
20 DA FD JSR PRBYTE OUTPUT BYTE IN HEX
20 BA FC JSR NXTA1
90 E8 BCC MODSCHK CHECK IF TIME TO,
60 RTS4C RTS PRINT ADDR
4A XAMPM LSR A DETERMINE IF MON
90 EA BCC XAM MODE IS XAM
4A LSR A ADD, OR SUB
4A LSR A
A5 3E LDA A2L
90 02 BCC ADD
49 FF EOR #$FF SUB: FORM 2'S COMPLEMENT
65 3C ADD ADC A1L
48 PHA
A9 BD LDA #$BD
20 ED FD JSR COUT PRINT '=', THEN RESULT
68 PLA
48 PRBYTE PHA PRINT BYTE AS 2 HEX
4A LSR A DIGITS, DESTROYS A-REG
4A LSR A
4A LSR A
4A LSR A
20 E5 FD JSR PRHEXZ
68 PLA
29 0F PRHEX AND #$0F PRINT HEX DIG IN A-REG
09 B0 PRHEXZ ORA #$B0 LSB'S
C9 BA CMP #$BA
90 02 BCC COUT
69 06 ADC #$06
6C 36 00 COUT JMP (CSWL) VECTOR TO USER OUTPUT ROUTINE
C9 A0 COUT1 CMP #$A0
90 02 BCC COUTZ DON'T OUTPUT CTRL'S INVERSE
25 32 AND INVFLG MASK WITH INVERSE FLAG
84 35 COUTZ STY YSAV1 SAV Y-REG
48 PHA SAV A-REG
20 FD FB JSR VIDOUT OUTPUT A-REG AS ASCII
68 PLA RESTORE A-REG
A4 35 LDY YSAV1 AND Y-REG
60 RTS THEN RETURN
C6 34 BL1 DEC YSAV
F0 9F BEQ XAM8
CA BLANK DEX BLANK TO MON
D0 16 BNE SETMDZ AFTER BLANK
C9 BA CMP #$BA DATA STORE MODE?
D0 BB BNE XAMPM NO, XAM, ADD, OR SUB
85 31 STOR STA MODE KEEP IN STORE MODE
A5 3E LDA A2L
91 40 STA (A3L),Y STORE AS LOW BYTE AS (A3)
E6 40 INC A3L
D0 02 BNE RTS5 INCR A3, RETURN
E6 41 INC A3H
60 RTS5 RTS
A4 34 SETMODE LDY YSAV SAVE CONVERTED ':', '+',
B9 FF 01 LDA IN-1,Y '-', '.' AS MODE.
85 31 SETMDZ STA MODE
60 RTS
A2 01 LT LDX #$01
B5 3E LT2 LDA A2L,X COPY A2 (2 BYTES) TO
95 42 STA A4L,X A4 AND A5
95 44 STA A5L,X
CA DEX
10 F7 BPL LT2
60 RTS
B1 3C MOVE LDA (A1L),Y MOVE (A1 TO A2) TO
91 42 STA (A4L),Y (A4)
20 B4 FC JSR NXTA4
90 F7 BCC MOVE
60 RTS
B1 3C VFY LDA (A1L),Y VERIFY (A1 TO A2) WITH
D1 42 CMP (A4L),Y (A4)
F0 1C BEQ VFYOK
20 92 FD JSR PRA1
B1 3C LDA (A1L),Y
20 DA FD JSR PRBYTE
A9 A0 LDA #$A0
20 ED FD JSR COUT
A9 A8 LDA #$A8
20 ED FD JSR COUT
B1 42 LDA (A4L),Y
20 DA FD JSR PRBYTE
A9 A9 LDA #$A9
20 ED FD JSR COUT
20 B4 FC VFYOK JSR NXTA4
90 D9 BCC VFY
60 RTS
20 75 FE LIST JSR A1PC MOVE A1 (2 BYTES) TO
A9 14 LDA #$14 PC IF SPEC'D AND
48 LIST2 PHA DISEMBLE 20 INSTRS
20 D0 F8 JSR INSTDSP
20 53 F9 JSR PCADJ ADJUST PC EACH INSTR
85 3A STA PCL
84 3B STY PCH
68 PLA
38 SEC
E9 01 SBC #$01 NEXT OF 20 INSTRS
D0 EF BNE LIST2
60 RTS
8A A1PC TXA IF USER SPEC'D ADR
F0 07 BEQ A1PCRTS COPY FROM A1 TO PC
B5 3C A1PCLP LDA A1L,X
95 3A STA PCL,X
CA DEX
10 F9 BPL A1PCLP
60 A1PCRTS RTS
A0 3F SETINV LDY #$3F SET FOR INVERSE VID
D0 02 BNE SETIFLG VIA COUT1
A0 FF SETNORM LDY #$FF SET FOR NORMAL VID
84 32 SETIFLG STY INVFLG
60 RTS
A9 00 SETKBD LDA #$00 SIMULATE PORT #0 INPUT
85 3E INPORT STA A2L SPECIFIED (KEYIN ROUTINE)
A2 38 INPRT LDX #KSWL
A0 1B LDY #KEYIN
D0 08 BNE IOPRT
A9 00 SETVID LDA #$00 SIMULATE PORT #0 OUTPUT
85 3E OUTPORT STA A2L SPECIFIED (COUT1 ROUTINE)
A2 36 OUTPRT LDX #CSWL
A0 F0 LDY #COUT1
A5 3E IOPRT LDA A2L SET RAM IN/OUT VECTORS
29 0F AND #$0F
F0 06 BEQ IOPRT1
09 C0 ORA #IOADR/256
A0 00 LDY #$00
F0 02 BEQ IOPRT2
A9 FD IOPRT1 LDA #COUT1/256
94 00 IOPRT2 STY LOC0,X
95 01 STA LOC1,X
60 RTS
EA NOP
EA NOP
4C 00 E0 XBASIC JMP BASIC TO BASIC WITH SCRATCH
4C 03 E0 BASCONT JMP BASIC2 CONTINUE BASIC
20 75 FE GO JSR A1PC ADR TO PC IF SPEC'D
20 3F FF JSR RESTORE RESTORE META REGS
6C 3A 00 JMP (PCL) GO TO USER SUBR
4C D7 FA REGZ JMP REGDSP TO REG DISPLAY
C6 34 TRACE DEC YSAV
20 75 FE STEPZ JSR A1PC ADR TO PC IF SPEC'D
4C 43 FA JMP STEP TAKE ONE STEP
4C F8 03 USR JMP USRADR TO USR SUBR AT USRADR
A9 40 WRITE LDA #$40
20 C9 FC JSR HEADR WRITE 10-SEC HEADER
A0 27 LDY #$27
A2 00 WR1 LDX #$00
41 3C EOR (A1L,X)
48 PHA
A1 3C LDA (A1L,X)
20 ED FE JSR WRBYTE
20 BA FC JSR NXTA1
A0 1D LDY #$1D
68 PLA
90 EE BCC WR1
A0 22 LDY #$22
20 ED FE JSR WRBYTE
F0 4D BEQ BELL
A2 10 WRBYTE LDX #$10
0A WRBYT2 ASL A
20 D6 FC JSR WRBIT
D0 FA BNE WRBYT2
60 RTS
20 00 FE CRMON JSR BL1 HANDLE A CR AS BLANK
68 PLA THEN POP STACK
68 PLA AND RTN TO MON
D0 6C BNE MONZ
20 FA FC READ JSR RD2BIT FIND TAPEIN EDGE
A9 16 LDA #$16
20 C9 FC JSR HEADR DELAY 3.5 SECONDS
85 2E STA CHKSUM INIT CHKSUM=$FF
20 FA FC JSR RD2BIT FIND TAPEIN EDGE
A0 24 RD2 LDY #$24 LOOK FOR SYNC BIT
20 FD FC JSR RDBIT (SHORT 0)
B0 F9 BCS RD2 LOOP UNTIL FOUND
20 FD FC JSR RDBIT SKIP SECOND SYNC H-CYCLE
A0 3B LDY #$3B INDEX FOR 0/1 TEST
20 EC FC RD3 JSR RDBYTE READ A BYTE
81 3C STA (A1L,X) STORE AT (A1)
45 2E EOR CHKSUM
85 2E STA CHKSUM UPDATE RUNNING CHKSUM
20 BA FC JSR NXTA1 INC A1, COMPARE TO A2
A0 35 LDY #$35 COMPENSATE 0/1 INDEX
90 F0 BCC RD3 LOOP UNTIL DONE
20 EC FC JSR RDBYTE READ CHKSUM BYTE
C5 2E CMP CHKSUM
F0 0D BEQ BELL GOOD, SOUND BELL AND RETURN
A9 C5 PRERR LDA #$C5
20 ED FD JSR COUT PRINT "ERR", THEN BELL
A9 D2 LDA #$D2
20 ED FD JSR COUT
20 ED FD JSR COUT
A9 87 BELL LDA #$87 OUTPUT BELL AND RETURN
4C ED FD JMP COUT
A5 48 RESTORE LDA STATUS RESTORE 6502 REG CONTENTS
48 PHA USED BY DEBUG SOFTWARE
A5 45 LDA ACC
A6 46 RESTR1 LDX XREG
A4 47 LDY YREG
28 PLP
60 RTS
85 45 SAVE STA ACC SAVE 6502 REG CONTENTS
86 46 SAV1 STX XREG
84 47 STY YREG
08 PHP
68 PLA
85 48 STA STATUS
BA TSX
86 49 STX SPNT
D8 CLD
60 RTS
20 84 FE RESET JSR SETNORM SET SCREEN MODE
20 2F FB JSR INIT AND INIT KBD/SCREEN
20 93 FE JSR SETVID AS I/O DEV'S
20 89 FE JSR SETKBD
D8 MON CLD MUST SET HEX MODE!
20 3A FF JSR BELL
A9 AA MONZ LDA #$AA '*' PROMPT FOR MON
85 33 STA PROMPT
20 67 FD JSR GETLNZ READ A LINE
20 C7 FF JSR ZMODE CLEAR MON MODE, SCAN IDX
20 A7 FF NXTITM JSR GETNUM GET ITEM, NON-HEX
84 34 STY YSAV CHAR IN A-REG
A0 17 LDY #$17 X-REG=0 IF NO HEX INPUT
88 CHRSRCH DEY
30 E8 BMI MON NOT FOUND, GO TO MON
D9 CC FF CMP CHRTBL,Y FIND CMND CHAR IN TEL
D0 F8 BNE CHRSRCH
20 BE FF JSR TOSUB FOUND, CALL CORRESPONDING
A4 34 LDY YSAV SUBROUTINE
4C 73 FF JMP NXTITM
A2 03 DIG LDX #$03
0A ASL A
0A ASL A GOT HEX DIG,
0A ASL A SHIFT INTO A2
0A ASL A
0A NXTBIT ASL A
26 3E ROL A2L
26 3F ROL A2H
CA DEX LEAVE X=$FF IF DIG
10 F8 BPL NXTBIT
A5 31 NXTBAS LDA MODE
D0 06 BNE NXTBS2 IF MODE IS ZERO
B5 3F LDA A2H,X THEN COPY A2 TO
95 3D STA A1H,X A1 AND A3
95 41 STA A3H,X
E8 NXTBS2 INX
F0 F3 BEQ NXTBAS
D0 06 BNE NXTCHR
A2 00 GETNUM LDX #$00 CLEAR A2
86 3E STX A2L
86 3F STX A2H
B9 00 02 NXTCHR LDA IN,Y GET CHAR
C8 INY
49 B0 EOR #$B0
C9 0A CMP #$0A
90 D3 BCC DIG IF HEX DIG, THEN
69 88 ADC #$88
C9 FA CMP #$FA
B0 CD BCS DIG
60 RTS
A9 FE TOSUB LDA #GO/256 PUSH HIGH-ORDER
48 PHA SUBR ADR ON STK
B9 E3 FF LDA SUBTBL,Y PUSH LOW-ORDER
48 PHA SUBR ADR ON STK
A5 31 LDA MODE
A0 00 ZMODE LDY #$00 CLR MODE, OLD MODE
84 31 STY MODE TO A-REG
60 RTS GO TO SUBR VIA RTS
BC CHRTBL .BYTE $BC F("CTRL-C")
B2 .BYTE $B2 F("CTRL-Y")
BE .BYTE $BE F("CTRL-E")
ED .BYTE $ED F("T")
EF .BYTE $EF F("V")
C4 .BYTE $C4 F("CTRL-K")
EC .BYTE $EC F("S")
A9 .BYTE $A9 F("CTRL-P")
BB .BYTE $BB F("CTRL-B")
A6 .BYTE $A6 F("-")
A4 .BYTE $A4 F("+")
06 .BYTE $06 F("M") (F=EX-OR $B0+$89)
95 .BYTE $95 F("&lt")
07 .BYTE $07 F("N")
02 .BYTE $02 F("I")
05 .BYTE $05 F("L")
F0 .BYTE $F0 F("W")
00 .BYTE $00 F("G")
EB .BYTE $EB F("R")
93 .BYTE $93 F(":")
A7 .BYTE $A7 F(".")
C6 .BYTE $C6 F("CR")
99 .BYTE $99 F(BLANK)
B2 SUBTBL .BYTE BASCONT-1
C9 .BYTE USR-1
BE .BYTE REGZ-1
C1 .BYTE TRACE-1
35 .BYTE VFY-1
.BYTE INPRT-1
.BYTE STEPZ-1
.BYTE OUTPRT-1
.BYTE XBASIC-1
.BYTE SETMODE-1
.BYTE SETMODE-1
.BYTE MOVE-1
.BYTE LT-1
.BYTE SETNORM-1
.BYTE SETINV-1
.BYTE LIST-1
.BYTE WRITE-1
.BYTE GO-1
.BYTE READ-1
.BYTE SETMODE-1
.BYTE SETMODE-1
.BYTE CRMON-1
.BYTE BLANK-1
.BYTE NMI NMI VECTOR
.BYTE NMI/256
.BYTE RESET ; RESET VECTOR
.BYTE RESET/256
.BYTE IRQ ; IRQ VECTOR
.BYTE IRQ/256
XQTNZ = $3C
