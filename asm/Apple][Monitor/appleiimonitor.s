; Port of Apple II monitor to Apple 1
;
; Original port by Winston Gayler with additional adaptations by
; Wendell Sander. Source code reverse-engineered and ported to CA65
; assembler by Jeff Tranter <tranter@pobox.com>.

; Define to get Apple 1 version, otherwise generates original Apple II
; code.
APPLE1 = 1

; ***********************
; *                     *
; * APPLE-II            *
; * MINI-ASSEMBLER      *
; *                     *
; * COPYRIGHT 1977 BY   *
; * APPLE COMPUTER INC. *
; *                     *
; * ALL RIGHTS RESERVED *
; *                     *
; * S. WOZNIAK          *
; * A. BAUM             *
; ***********************
; TITLE "APPLE-II MINI-ASSEMBLER"
FORMAT = $2E
LENGTH = $2F
MODE =   $31
PROMPT = $33
YSAV =   $34
L =      $35
PCL =    $3A
PCH =    $3B
A1H =    $3D
A2L =    $3E
A2H =    $3F
A4L =    $42
A4H =    $43
FMT =    $44
IN =     $200
; INSDS2 = $F88E
; INSTDSP = $F8D0
; PRBL2 =  $F94A
; PCADJ =  $F953
; CHAR1 =  $F9B4
; CHAR2 =  $F9BA
; MNEML =  $F9C0
; MNEMR =  $FA00
CURSUP = $FC1A
GETLNZ = $FD67
COUT =   $FDED
BL1 =    $FE00
A1PCLP = $FE78
BELL =   $FF3A
GETNUM = $FFA7
TOSUB =  $FFBE
ZMODE =  $FFC7
CHRTBL = $FFCC
.ifdef APPLE1
        .ORG $7500
.else
        .ORG $F500
.endif
REL: SBC #$81 ; IS FMT COMPATIBLE
  LSR ; WITH RELATIVE MODE?
  BNE ERR3 ; NO.
  LDY A2H
  LDX A2L ; DOUBLE DECREMENT
  BNE REL2
  DEY
REL2: DEX
  TXA
  CLC
  SBC PCL ; FORM ADDR-PC-2
  STA A2L
  BPL REL3
  INY
REL3: TYA
  SBC PCH
ERR3: BNE ERR ; ERROR IF >1-BYTE BRANCH
FINDOP: LDY LENGTH
FNDOP2: LDA A1H,Y ; MOVE INST TO (PC)
  STA (PCL),Y
  DEY
  BPL FNDOP2
.ifdef APPLE1
  NOP
  NOP
  NOP
  NOP
  NOP
  NOP
.else
  JSR CURSUP
  JSR CURSUP ; RESTORE CURSOR
.endif
  JSR INSTDSP ; TYPE FORMATTED LINE
  JSR PCADJ ; UPDATE PC
  STY PCH
  STA PCL
  JMP NXTLINE ; GET NEXT LINE
FAKEMON3: JSR TOSUB ; GO TO DELIM HANDLER
  LDY YSAV ; RESTORE Y-INDEX
FAKEMON: JSR GETNUM ; READ PARAM
  STY YSAV ; SAVE Y-INDEX
  LDY #$17 ; INIT DELIMITER INDEX
FAKEMON2: DEY ; CHECK NEXT DELIM
  BMI RESETZ ; ERR IF UNRECOGNIZED DELIM
  CMP CHRTBL,Y ; COMPARE WITH DELIM TABLE
  BNE FAKEMON2 ; NO MATCH
  CPY #$15 ; MATCH, IS IT CR?
  BNE FAKEMON3 ; NO, HANDLE IT IN MONITOR
  LDA MODE
  LDY #$0
  DEC YSAV
  JSR BL1 ; HANDLE CR OUTSIDE MONITOR
  JMP NXTLINE
TRYNEXT: LDA A1H ; GET TRIAL OPCODE
  JSR INSDS2 ; GET FMT+LENGTH FOR OPCODE
  TAX
  LDA MNEMR,X ; GET LOWER MNEMONIC BYTE
  CMP A4L ; MATCH?
  BNE NEXTOP ; NO, TRY NEXT OPCODE.
  LDA MNEML,X ; GET UPPER MNEMONIC BYTE
  CMP A4H ; MATCH?
  BNE NEXTOP ; NO, TRY NEXT OPCODE
  LDA FMT
  LDY FORMAT ; GET TRIAL FORMAT
  CPY #$9D ; TRIAL FORMAT RELATIVE?
  BEQ REL ; YES.
NREL: CMP FORMAT ; SAME FORMAT?
  BEQ FINDOP ; YES.
NEXTOP: DEC A1H ; NO, TRY NEXT OPCODE
  BNE TRYNEXT
  INC FMT ; NO MORE, TRY WITH LEN=2
  DEC L ; WAS L=2 ALREADY?
  BEQ TRYNEXT ; NO.
ERR: LDY YSAV ; YES, UNRECOGNIZED INST.
ERR2: TYA
  TAX
  JSR PRBL2 ; PRINT ^ UNDER LAST READ
  LDA #$DE ; CHAR TO INDICATE ERROR
  JSR COUT ; POSITION.
RESETZ: JSR BELL
NXTLINE: LDA #$A1 ; '!'
  STA PROMPT ; INITIALIZE PROMPT
  JSR GETLNZ ; GET LINE.
  JSR ZMODE ; INIT SCREEN STUFF
  LDA IN ; GET CHAR
  CMP #$A0 ; ASCII BLANK?
  BEQ SPACE ; YES
  INY
  CMP #$A4 ; ASCII '$' IN COL 1?
  BEQ FAKEMON ; YES, SIMULATE MONITOR
  DEY ; NO, BACKUP A CHAR
  JSR GETNUM ; GET A NUMBER
  CMP #$93 ; ':' TERMINATOR?
ERR4: BNE ERR2 ; NO, ERR.
  TXA
  BEQ ERR2 ; NO ADR PRECEDING COLON.
  JSR A1PCLP ; MOVE ADR TO PCL, PCH.
SPACE: LDA #$3 ; COUNT OF CHARS IN MNEMONIC
  STA A1H
NXTMN: JSR GETNSP ; GET FIRST MNEM CHAR.
NXTM: ASL A
  SBC #$BE ; SUBTRACT OFFSET
  CMP #$C2 ; LEGAL CHAR?
  BCC ERR2 ; NO.
  ASL A ; COMPRESS-LEFT JUSTIFY
  ASL A
  LDX #$4
NXTM2: ASL A ; DO 5 TRIPLE WORD SHIFTS
  ROL A4L
  ROL A4H
  DEX
  BPL NXTM2
  DEC A1H ; DONE WITH 3 CHARS?
  BEQ NXTM2 ; YES, BUT DO 1 MORE SHIFT
  BPL NXTMN ; NO
FORM1: LDX #$5 ; 5 CHARS IN ADDR MODE
FORM2: JSR GETNSP ; GET FIRST CHAR OF ADDR
  STY YSAV
  CMP CHAR1,X ; FIRST CHAR MATCH PATTERN?
  BNE FORM3 ; NO
  JSR GETNSP ; YES, GET SECOND CHAR
  CMP CHAR2,X ; MATCHES SECOND HALF?
  BEQ FORM5 ; YES.
  LDA CHAR2,X ; NO, IS SECOND HALF ZERO?
  BEQ FORM4 ; YES.
  CMP #$A4 ; NO,SECOND HALF OPTIONAL?
  BEQ FORM4 ; YES.
  LDY YSAV
FORM3: CLC ; CLEAR BIT-NO MATCH
FORM4: DEY ; BACK UP 1 CHAR
FORM5: ROL ; FMT FORM FORMAT BYTE
  CPX #$3 ; TIME TO CHECK FOR ADDR.
  BNE FORM7 ; NO
  JSR GETNUM ; YES
  LDA A2H
  BEQ FORM6 ; HIGH-ORDER BYTE ZERO
  INX ; NO, INCR FOR 2-BYTE
FORM6: STX L ; STORE LENGTH
  LDX #$3 ; RELOAD FORMAT INDEX
  DEY ; BACKUP A CHAR
FORM7: STX A1H ; SAVE INDEX
  DEX ; DONE WITH FORMAT CHECK?
  BPL FORM2 ; NO.
  LDA FMT ; YES, PUT LENGTH
  ASL A ; IN LOW BITS
  ASL A
  ORA L
  CMP #$20
  BCS FORM8 ; ADD "$" IF NONZERO LENGTH
  LDX L ; AND DON'T ALREADY HAVE IT
  BEQ FORM8
  ORA #$80
FORM8: STA FMT
  STY YSAV
  LDA IN,Y ; GET NEXT NONBLANK
  CMP #$BB ; '' START OF COMMENT?
  BEQ FORM9 ; YES
  CMP #$8D ; CARRIAGE RETURN?
  BNE ERR4 ; NO, ERR.
FORM9: JMP TRYNEXT
GETNSP: LDA IN,Y
  INY
  CMP #$A0 ; GET NEXT NON BLANK CHAR
  BEQ GETNSP
  RTS

; Add filler bytes up to documented Mini-Assembler entry point at
; address $X666
.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0

;        .ORG $F666
MINIASM: JMP RESETZ

; Apple 1 specific code
.ifdef APPLE1

  LDA   ($3A,X)
  TAY
  LSR
  BCC   $7675
  LSR
  ORA   #$80
  JMP   $7893
  JMP   $789B
  LDA   #$7F ; Initialize 6820
  STA   $D012
  LDX   #$A7
  STX   $D011
  STX   $D013
  LDX   #$8B ; Initialize Serial Card 300 Baud
  STX   $D004
  LDX   #$96
  STX   $D005
  RTS
  BIT   $D012 ;Character Out
  BMI   $7690
  STA   $D012
  RTS
  CMP   #$9B ; Use Esc for line kill
  BNE   $769F
  LDA   #$98
  CMP   #$88 ; Use Control h for Backspace
  BNE   $76A5
  LDA   #$DF ; Underscore out
  RTS

.else

; Add filler bytes up to documented SWEET16 entry point at
; address $X689
.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

.endif

; ***********************
; *                     *
; * APPLE-II PSEUDO     *
; * MACHINE INTERPRETER *
; *                     *
; * COPYRIGHT 1977      *
; * APPLE COMPUTER INC  *
; *                     *
; * ALL RIGHTS RESERVED *
; * S. WOZNIAK          *
; *                     *
; ***********************
; TITLE "SWEET16 INTERPRETER"
R0L = $0
R0H = $1
R14H = $1D
R15L = $1E
R15H = $1F
SW16PAG = $F7
SAVE = $FF4A
RESTORE = $FF3F
;  .ORG $F689
SW16: JSR SAVE ; PRESERVE 6502 REG CONTENTS
  PLA
  STA R15L ; INIT SWEET16 PC
  PLA ; FROM RETURN
  STA R15H ; ADDRESS
SW16B: JSR SW16C ; INTERPRET AND EXECUTE
  JMP SW16B ; ONE SWEET16 INSTR.
SW16C: INC R15L
  BNE SW16D ; INCR SWEET16 PC FOR FETCH
  INC R15H
SW16D: LDA #SW16PAG
  PHA ; PUSH ON STACK FOR RTS
  LDY #$0
  LDA (R15L),Y ; FETCH INSTR
  AND #$F ; MASK REG SPECIFICATION
  ASL A ; DOUBLE FOR TWO BYTE REGISTERS
  TAX ; TO X REG FOR INDEXING
  LSR A
  EOR (R15L),Y ; NOW HAVE OPCODE
  BEQ TOBR ; IF ZERO THEN NON-REG OP
  STX R14H ; INDICATE'PRIOR RESULT REG'
  LSR A
  LSR A ; OPCODE*2 TO LSB'S
  LSR A
  TAY ; TO Y REG FOR INDEXING
  LDA OPTBL-2,Y ; LOW ORDER ADR BYTE
  PHA ; ONTO STACK
  RTS ; GOTO REG-OP ROUTINE
TOBR: INC R15L
  BNE TOBR2 ; INCR PC
  INC R15H
TOBR2: LDA BRTBL,X ; LOW ORDER ADR BYTE
  PHA ; ONTO STACK FOR NON-REG OP
  LDA R14H ; 'PRIOR RESULT REG' INDEX
  LSR A ; PREPARE CARRY FOR BC, BNC.
  RTS ; GOTO NON-REG OP ROUTINE
RTNZ: PLA ; POP RETURN ADDRESS
  PLA
  JSR RESTORE ; RESTORE 6502 REG CONTENTS
  JMP (R15L) ; RETURN TO 6502 CODE VIA PC
SETZ: LDA (R15L),Y ; HIGH-ORDER BYTE OF CONSTANT
  STA R0H,X
  DEY
  LDA (R15L),Y ; LOW-ORDER BYTE OF CONSTANT
  STA R0L,X
  TYA ; Y-REG CONTAINS 1
  SEC
  ADC R15L ; ADD 2 TO PC
  STA R15L
  BCC SET2
  INC R15H
SET2: RTS
OPTBL: .BYTE <SET-1 ; 1X
BRTBL: .BYTE <RTN-1 ; 0
  .BYTE <LD-1 ; 2X
  .BYTE <BR-1 ; 1
  .BYTE <ST-1 ; 3X
  .BYTE <BNC-1 ; 2
  .BYTE <LDAT-1 ; 4X
  .BYTE <BC-1 ; 3
  .BYTE <STAT-1 ; 5X
  .BYTE <BP-1 ; 4
  .BYTE <LDDAT-1 ; 6X
  .BYTE <BM-1 ; 5
  .BYTE <STDAT-1 ; 7X
  .BYTE <BZ-1 ; 6
  .BYTE <POP-1 ; 8X
  .BYTE <BNZ-1 ; 7
  .BYTE <STPAT-1 ; 9X
  .BYTE <BM1-1 ; 8
  .BYTE <ADD-1 ; AX
  .BYTE <BNM1-1 ; 9
  .BYTE <SUB-1 ; BX
  .BYTE <BK-1 ; A
  .BYTE <POPD-1 ; CX
  .BYTE <RS-1 ; B
  .BYTE <CPR-1 ; DX
  .BYTE <BS-1 ; C
  .BYTE <INR-1 ; EX
  .BYTE <NUL-1 ; D
  .BYTE <DCR-1 ; FX
  .BYTE <NUL-1 ; E
  .BYTE <NUL-1 ; UNUSED
  .BYTE <NUL-1 ; F
SET: BPL SETZ ; ALWAYS TAKEN
LD: LDA R0L,X
BK = LD+1
  STA R0L
  LDA R0H,X ; MOVE RX TO R0
  STA R0H
  RTS
ST: LDA R0L
  STA R0L,X ; MOVE R0 TO RX
  LDA R0H
  STA R0H,X
  RTS
STAT: LDA R0L
STAT2: STA (R0L,X) ; STORE BYTE INDIRECT
  LDY #$0
STAT3: STY R14H ; INDICATE R0 IS RESULT NEG
INR: INC R0L,X
  BNE INR2 ; INCR RX
  INC R0H,X
INR2: RTS
LDAT: LDA (R0L,X) ; LOAD INDIRECT (RX)
  STA R0L ; TO R0
  LDY #$0
  STY R0H ; ZERO HIGH-ORDER R0 BYTE
  BEQ STAT3 ; ALWAYS TAKEN
POP: LDY #$0 ; HIGH ORDER BYTE = 0
  BEQ POP2 ; ALWAYS TAKEN
POPD: JSR DCR ; DECR RX
  LDA (R0L,X) ; POP HIGH ORDER BYTE @RX
  TAY ; SAVE IN Y-REG
POP2: JSR DCR ; DECR RX
  LDA (R0L,X) ; LOW-ORDER BYTE
  STA R0L ; TO R0
  STY R0H
POP3: LDY #$0 ; INDICATE R0 AS LAST RESULT REG
  STY R14H
  RTS
LDDAT: JSR LDAT ; LOW-ORDER BYTE TO R0, INCR RX
  LDA (R0L,X) ; HIGH-ORDER BYTE TO R0
  STA R0H
  JMP INR ; INCR RX
STDAT: JSR STAT ; STORE INDIRECT LOW-ORDER
  LDA R0H ; BYTE AND INCR RX. THEN
  STA (R0L,X) ; STORE HIGH-ORDER BYTE.
  JMP INR ; INCR RX AND RETURN
STPAT: JSR DCR ; DECR RX
  LDA R0L
  STA (R0L,X) ; STORE R0 LOW BYTE @RX
  JMP POP3 ; INDICATE R0 AS LAST RSLT REG
DCR: LDA R0L,X
  BNE DCR2 ; DECR RX
  DEC R0H,X
DCR2: DEC R0L,X
  RTS
SUB: LDY #$0 ; RESULT TO R0
CPR: SEC ; NOTE Y-REG = 13*2 FOR CPR
  LDA R0L
  SBC R0L,X
  STA R0L,Y ; R0-RX TO RY
  LDA R0H
  SBC R0H,X
SUB2: STA R0H,Y
  TYA ; LAST RESULT REG*2
  ADC #$0 ; CARRY TO LSB
  STA R14H
  RTS
ADD: LDA R0L
  ADC R0L,X
  STA R0L ; R0+RX TO R0
  LDA R0H
  ADC R0H,X
  LDY #$0 ; R0 FOR RESULT
  BEQ SUB2 ; FINISH ADD
BS: LDA R15L ; NOTE X-REG IS 12*2!
  JSR STAT2 ; PUSH LOW PC BYTE VIA R12
  LDA R15H
  JSR STAT2 ; PUSH HIGH-ORDER PC BYTE
BR: CLC
BNC: BCS BNC2 ; NO CARRY TEST
BR1: LDA (R15L),Y ; DISPLACEMENT BYTE
  BPL BR2
  DEY
BR2: ADC R15L ; ADD TO PC
  STA R15L
  TYA
  ADC R15H
  STA R15H
BNC2: RTS
BC: BCS BR
  RTS
BP: ASL A ; DOUBLE RESULT-REG INDEX
  TAX ; TO X REG FOR INDEXING
  LDA R0H,X ; TEST FOR PLUS
  BPL BR1 ; BRANCH IF SO
  RTS
BM: ASL A ; DOUBLE RESULT-REG INDEX
  TAX
  LDA R0H,X ; TEST FOR MINUS
  BMI BR1
  RTS
BZ: ASL A ; DOUBLE RESULT-REG INDEX
  TAX
  LDA R0L,X ; TEST FOR ZERO
  ORA R0H,X ; (BOTH BYTES)
  BEQ BR1 ; BRANCH IF SO
  RTS
BNZ: ASL A ; DOUBLE RESULT-REG INDEX
  TAX
  LDA R0L,X ; TEST FOR NON-ZERO
  ORA R0H,X ; (BOTH BYTES)
  BNE BR1 ; BRANCH IF SO
  RTS
BM1: ASL A ; DOUBLE RESULT-REG INDEX
  TAX
  LDA R0L,X ; CHECK BOTH BYTES
  AND R0H,X ; FOR $FF (MINUS 1)
  EOR #$FF
  BEQ BR1 ; BRANCH IF SO
  RTS
BNM1: ASL A ; DOUBLE RESULT-REG INDEX
  TAX
  LDA R0L,X
  AND R0H,X ; CHECK BOTH BYTES FOR NO $FF
  EOR #$FF
  BNE BR1 ; BRANCH IF NOT MINUS 1
NUL: RTS
RS: LDX #$18 ; 12*2 FOR R12 AS STACK POINTER
  JSR DCR ; DECR STACK POINTER
  LDA (R0L,X) ; POP HIGH RETURN ADDRESS TO PC
  STA R15H
  JSR DCR ; SAME FOR LOW-ORDER BYTE
  LDA (R0L,X)
  STA R15L
 RTS
RTN: JMP RTNZ

; ***************************
; *                         *
; * APPLE II                *
; * SYSTEM MONITOR          *
; *                         *
; * COPYRIGHT 1977 BY       *
; * APPLE COMPUTER, INC.    *
; *                         *
; * ALL RIGHTS RESERVED     *
; *                         *
; * S. WOZNIAK              *
; * A. BAUM                 *
; *                         *
; ***************************
; TITLE "APPLE II SYSTEM MONITOR"
LOC0 = $00
LOC1 = $01
WNDLFT = $20
WNDWDTH = $21
WNDTOP = $22
WNDBTM = $23
CH = $24
CV = $25
GBASL = $26
GBASH = $27
BASL = $28
BASH = $29
BAS2L = $2A
BAS2H = $2B
H2 = $2C
LMNEM = $2C
RTNL = $2C
V2 = $2D
RMNEM = $2D
RTNH = $2D
MASK = $2E
CHKSUM = $2E
; FORMAT = $2E
LASTIN = $2F
; LENGTH = $2F
SIGN = $2F
COLOR = $30
; MODE = $31
INVFLG = $32
; PROMPT = $33
; YSAV = $34
YSAV1 = $35
CSWL = $36
CSWH = $37
KSWL = $38
KSWH = $39
; PCL = $3A
; PCH = $3B
XQT = $3C
A1L = $3C
; A1H = $3D
;A2L = $3E
;A2H = $3F
A3L = $40
A3H = $41
;A4L = $42
;A4H = $43
A5L = $44
A5H = $45
ACC = $45
XREG = $46
YREG = $47
STATUS = $48
SPNT = $49
RNDL = $4E
RNDH = $4F
ACL = $50
ACH = $51
XTNDL = $52
XTNDH = $53
AUXL = $54
AUXH = $55
PICK = $95
; IN = $0200
USRADR = $03F8
NMI = $03FB
IRQLOC = $03FE
IOADR = $C000
KBD = $C000
KBDSTRB = $C010
TAPEOUT = $C020
SPKR = $C030
TXTCLR = $C050
TXTSET = $C051
MIXCLR = $C052
MIXSET = $C053
LOWSCR = $C054
HISCR = $C055
LORES = $C056
HIRES = $C057
TAPEIN = $C060
PADDL0 = $C064
PTRIG = $C070
BASIC = $E000
BASIC2 = $E003
; ORG $F800 ROM START ADDRESS
PLOT: LSR ; Y-COORD/2
  PHP ; SAVE LSB IN CARRY
  JSR GBASCALC ; CALC BASE ADR IN GBASL,H
  PLP ; RESTORE LSB FROM CARRY
  LDA #$0F ; MASK $0F IF EVEN
  BCC RTMASK
  ADC #$E0 ; MASK $F0 IF ODD
RTMASK: STA MASK
PLOT1: LDA (GBASL),Y ; DATA
  EOR COLOR ; EOR COLOR
  AND MASK ; AND MASK
  EOR (GBASL),Y ; XOR DATA
  STA (GBASL),Y ; TO DATA
  RTS
HLINE: JSR PLOT ; PLOT SQUARE
HLINE1: CPY H2 ; DONE?
  BCS RTS1 ; YES, RETURN
  INY ; NO, INCR INDEX (X-COORD)
  JSR PLOT1 ; PLOT NEXT SQUARE
  BCC HLINE1 ; ALWAYS TAKEN
VLINEZ: ADC #$01 ; NEXT Y-COORD
VLINE: PHA ; SAVE ON STACK
  JSR PLOT ; PLOT SQUARE
  PLA
  CMP V2 ; DONE?
  BCC VLINEZ ; NO, LOOP
RTS1: RTS
CLRSCR: LDY #$2F ; MAX Y, FULL SCRN CLR
  BNE CLRSC2 ; ALWAYS TAKEN
CLRTOP: LDY #$27 ; MAX Y, TOP SCREEN CLR
CLRSC2: STY V2 ; STORE AS BOTTOM COORD
; FOR VLINE CALLS
  LDY #$27 ; RIGHTMOST X-COORD (COLUMN)
CLRSC3: LDA #$00 ; TOP COORD FOR VLINE CALLS
  STA COLOR ; CLEAR COLOR (BLACK)
  JSR VLINE ; DRAW VLINE
  DEY ; NEXT LEFTMOST X-COORD
  BPL CLRSC3 ; LOOP UNTIL DONE
  RTS
GBASCALC: PHA ; FOR INPUT 000DEFGH
  LSR
  AND #$03
  ORA #$04 ; GENERATE GBASH=000001FG
  STA GBASH
  PLA ; AND GBASL=HDEDE000
  AND #$18
  BCC GBCALC
  ADC #$7F
GBCALC: STA GBASL
  ASL A
  ASL A
  ORA GBASL
  STA GBASL
  RTS
NXTCOL: LDA COLOR ; INCREMENT COLOR BY 3
  CLC
  ADC #$03
SETCOL: AND #$0F ; SETS COLOR=17*A MOD 16
  STA COLOR
  ASL A ; BOTH HALF BYTES OF COLOR EQUAL
  ASL A
  ASL A
  ASL A
  ORA COLOR
  STA COLOR
  RTS
SCRN: LSR A ; READ SCREEN Y-COORD/2
  PHP ; SAVE LSB (CARRY)
  JSR GBASCALC ; CALC BASE ADDRESS
  LDA (GBASL),Y ; GET BYTE
  PLP ; RESTORE LSB FROM CARRY
SCRN2: BCC RTMSKZ ; IF EVEN, USE LO H
  LSR A
  LSR A
  LSR A ; SHIFT HIGH HALF BYTE DOWN
  LSR A
RTMSKZ: AND #$0F ; MASK 4-BITS
  RTS
INSDS1: LDX PCL ; PRINT PCL,H
  LDY PCH
  JSR PRYX2
  JSR PRBLNK ; FOLLOWED BY A BLANK
  LDA (PCL,X) ; GET OP CODE
INSDS2: TAY
  LSR A ; EVEN/ODD TEST
  BCC IEVEN
  ROR ; BIT 1 TEST
  BCS @ERR ; XXXXXX11 INVALID OP
  CMP #$A2
  BEQ @ERR ; OPCODE $89 INVALID
  AND #$87 ; MASK BITS
IEVEN: LSR A ; LSB INTO CARRY FOR L/R TEST
  TAX
  LDA FMT1,X ; GET FORMAT INDEX BYTE
  JSR SCRN2 ; R/L H-BYTE ON CARRY
  BNE GETFMT
@ERR: LDY #$80 ; SUBSTITUTE $80 FOR INVALID OPS
  LDA #$00 ; SET PRINT FORMAT INDEX TO 0
GETFMT: TAX
  LDA FMT2,X ; INDEX INTO PRINT FORMAT TABLE
  STA FORMAT ; SAVE FOR ADR FIELD FORMATTING
  AND #$03 ; MASK FOR 2-BIT LENGTH (P=1 BYTE, 1=2 BYTE, 2=3 BYTE)
  STA LENGTH
  TYA ; OPCODE
  AND #$8F ; MASK FOR 1XXX1010 TEST
  TAX ; SAVE IT
  TYA ; OPCODE TO A AGAIN
  LDY #$03
  CPX #$8A
  BEQ MNNDX3
MNNDX1: LSR A
  BCC MNNDX3 ; FORM INDEX INTO MNEMONIC TABLE
  LSR A
MNNDX2: LSR A ; 1) 1XXX1010-&gt00101XXX
  ORA #$20 ; 2) XXXYYY01-&gt00111XXX
  DEY ; 3) XXXYYY10-&gt00110XXX
  BNE MNNDX2 ; 4) XXXYY100-&gt00100XXX
  INY ; 5) XXXXX000-&gt000XXXXX
MNNDX3: DEY
  BNE MNNDX1
  RTS
  .BYTE $FF,$FF,$FF
INSTDSP: JSR INSDS1 ; GEN FMT, LEN BYTES
  PHA ; SAVE MNEMONIC TABLE INDEX
PRNTOP: LDA (PCL),Y
  JSR PRBYTE
  LDX #$01 ; PRINT 2 BLANKS
PRNTBL: JSR PRBL2
  CPY LENGTH ; PRINT INST (1-3 BYTES)
  INY ; IN A 12 CHR FIELD
  BCC PRNTOP
  LDX #$03 ; CHAR COUNT FOR MNEMONIC PRINT
  CPY #$04
  BCC PRNTBL
  PLA ; RECOVER MNEMONIC INDEX
  TAY
  LDA MNEML,Y
  STA LMNEM ; FETCH 3-CHAR MNEMONIC
  LDA MNEMR,Y ; (PACKED IN 2-BYTES)
  STA RMNEM
PRMN1: LDA #$00
  LDY #$05
PRMN2: ASL ; RMNEM SHIFT 5 BITS OF
  ROL LMNEM ; CHARACTER INTO A
  ROL ; (CLEARS CARRY)
  DEY
  BNE PRMN2
  ADC #$BF ; ADD "?" OFFSET
  JSR COUT ; OUTPUT A CHAR OF MNEM
  DEX
  BNE PRMN1
  JSR PRBLNK ; OUTPUT 3 BLANKS
  LDY LENGTH
  LDX #$06 ; CNT FOR 6 FORMAT BITS
PRADR1: CPX #$03
  BEQ PRADR5 ; IF X=3 THEN ADDR.
PRADR2: ASL FORMAT
  BCC PRADR3
  LDA CHAR1-1,X
  JSR COUT
  LDA CHAR2-1,X
  BEQ PRADR3
  JSR COUT
PRADR3: DEX
  BNE PRADR1
  RTS
PRADR4: DEY
  BMI PRADR2
  JSR PRBYTE
PRADR5: LDA FORMAT
  CMP #$E8 ; HANDLE REL ADR MODE
  LDA (PCL),Y ; SPECIAL (PRINT TARGET,
  BCC PRADR4 ; NOT OFFSET)
RELADR: JSR PCADJ3
  TAX ; PCL,PCH+OFFSET+1 TO A,Y
  INX
  BNE PRNTYX ; +1 TO Y,X
  INY
PRNTYX: TYA
PRNTAX: JSR PRBYTE ; OUTPUT TARGET ADR
PRNTX: TXA ; OF BRANCH AND RETURN
  JMP PRBYTE
PRBLNK: LDX #$03 ; BLANK COUNT
PRBL2: LDA #$A0 ; LOAD A SPACE
PRBL3: JSR COUT ; OUTPUT A BLANK
  DEX
  BNE PRBL2 ; LOOP UNTIL COUNT=0
  RTS
PCADJ: SEC ; 0=1-BYTE, 1=2-BYTE
PCADJ2: LDA LENGTH ; 2=3-BYTE
PCADJ3: LDY PCH
  TAX ; TEST DISPLACEMENT SIGN
  BPL PCADJ4 ; (FOR REL BRANCH)
  DEY ; EXTEND NEG BY DEC PCH
PCADJ4: ADC PCL
  BCC RTS2 ; PCL+LENGTH(OR DISPL)+1 TO A
  INY ; CARRY INTO Y (PCH)
RTS2: RTS
; FMT1 BYTES: XXXXXXY0 INSTRS
; IF Y=0 THEN LEFT HALF BYTE
; IF Y=1 THEN RIGHT HALF BYTE
; (X=INDEX)
FMT1: .BYTE $04,$20,$54,$30,$0D
  .BYTE $80,$04,$90,$03,$22
  .BYTE $54,$33,$0D,$80,$04
  .BYTE $90,$04,$20,$54,$33
  .BYTE $0D,$80,$04,$90,$04
  .BYTE $20,$54,$3B,$0D,$80
  .BYTE $04,$90,$00,$22,$44
  .BYTE $33,$0D,$C8,$44,$00
  .BYTE $11,$22,$44,$33,$0D
  .BYTE $C8,$44,$A9,$01,$22
  .BYTE $44,$33,$0D,$80,$04
  .BYTE $90,$01,$22,$44,$33
  .BYTE $0D,$80,$04,$90
  .BYTE $26,$31,$87,$9A ; $ZZXXXY01 INSTR'S
FMT2: .BYTE $00 ; ERR
  .BYTE $21 ; IMM
  .BYTE $81 ; Z-PAGE
  .BYTE $82 ; ABS
  .BYTE $00 ; IMPLIED
  .BYTE $00 ; ACCUMULATOR
  .BYTE $59 ; (ZPAG,X)
  .BYTE $4D ; (ZPAG),Y
  .BYTE $91 ; ZPAG,X
  .BYTE $92 ; ABS,X
  .BYTE $86 ; ABS,Y
  .BYTE $4A ; (ABS)
  .BYTE $85 ; ZPAG,Y
  .BYTE $9D ; RELATIVE
CHAR1: .byte ",),#($"
CHAR2: .BYTE $D9,$00,$D8,$A4,$A4,$00
; CHAR2: "Y",0,"X$$",0
; MNEML IS OF FORM:
; (A) XXXXX000
; (B) XXXYY100
; (C) 1XXX1010
; (D) XXXYYY10
; (E) XXXYYY01
; (X=INDEX)
MNEML: .BYTE $1C,$8A,$1C,$23,$5D,$8B
  .BYTE $1B,$A1,$9D,$8A,$1D,$23
  .BYTE $9D,$8B,$1D,$A1,$00,$29
  .BYTE $19,$AE,$69,$A8,$19,$23
  .BYTE $24,$53,$1B,$23,$24,$53
  .BYTE $19,$A1 ; (A) FORMAT ABOVE
  .BYTE $00,$1A,$5B,$5B,$A5,$69
  .BYTE $24,$24 ; (B) FORMAT
  .BYTE $AE,$AE,$A8,$AD,$29,$00
  .BYTE $7C,$00 ; (C) FORMAT
  .BYTE $15,$9C,$6D,$9C,$A5,$69
  .BYTE $29,$53 ; (D) FORMAT
  .BYTE $84,$13,$34,$11,$A5,$69
  .BYTE $23,$A0 ; (E) FORMAT
MNEMR: .BYTE $D8,$62,$5A,$48,$26,$62
  .BYTE $94,$88,$54,$44,$C8,$54
  .BYTE $68,$44,$E8,$94,$00,$B4
  .BYTE $08,$84,$74,$B4,$28,$6E
  .BYTE $74,$F4,$CC,$4A,$72,$F2
  .BYTE $A4,$8A ; (A) FORMAT
  .BYTE $00,$AA,$A2,$A2,$74,$74
  .BYTE $74,$72 ; (B) FORMAT
  .BYTE $44,$68,$B2,$32,$B2,$00
  .BYTE $22,$00 ; (C) FORMAT
  .BYTE $1A,$1A,$26,$26,$72,$72
  .BYTE $88,$C8 ; (D) FORMAT
  .BYTE $C4,$CA,$26,$48,$44,$44
  .BYTE $A2,$C8 ; (E) FORMAT
  .BYTE $FF,$FF,$FF
STEP: JSR INSTDSP ; DISASSEMBLE ONE INST
  PLA ; AT (PCL,H)
  STA RTNL ; ADJUST TO USER
  PLA ; STACK. SAVE
  STA RTNH ; RTN ADR.
  LDX #$08
XQINIT: LDA INITBL-1,X ; INIT XEQ AREA
  STA XQT,X
  DEX
  BNE XQINIT
  LDA (PCL,X) ; USER OPCODE BYTE
  BEQ XBRK ; SPECIAL IF BREAK
  LDY LENGTH ; LEN FROM DISASSEMBLY
  CMP #$20
  BEQ XJSR ; HANDLE JSR, RTS, JMP,
  CMP #$60 ; JMP (), RTI SPECIAL
  BEQ XRTS
  CMP #$4C
  BEQ XJMP
  CMP #$6C
  BEQ XJMPAT
  CMP #$40
  BEQ XRTI
  AND #$1F
  EOR #$14
  CMP #$04 ; COPY USER INST TO XEQ AREA
  BEQ XQ2 ; WITH TRAILING NOPS
XQ1: LDA (PCL),Y ; CHANGE REL BRANCH
XQ2: STA XQT,Y ; DISP TO 4 FOR
  DEY ; JMP TO BRANCH OR
  BPL XQ1 ; NBRANCH FROM XEQ.
  JSR RESTORE ; RESTORE USER REG CONTENTS.
  JMP XQT ; XEQ USER OP FROM RAM
IRQ: STA ACC ; (RETURN TO NBRANCH)
  PLA
  PHA ; **IRQ HANDLER
  ASL A
  ASL A
  ASL A
  BMI BREAK ; TEST FOR BREAK
  JMP (IRQLOC) ; USER ROUTINE VECTOR IN RAM
BREAK: PLP
  JSR SAV1 ; SAVE REG'S ON BREAK
  PLA ; INCLUDING PC
  STA PCL
  PLA
  STA PCH
XBRK: JSR INSDS1 ; PRINT USER PC.
  JSR RGDSP1 ; AND REG'S
  JMP MON ; GO TO MONITOR
XRTI: CLC
  PLA ; SIMULATE RTI BY EXPECTING
  STA STATUS ; STATUS FROM STACK, THEN RTS
XRTS: PLA ; RTS SIMULATION
  STA PCL ; EXTRACT PC FROM STACK
  PLA ; AND UPDATE PC BY 1 (LEN=0)
PCINC2: STA PCH
PCINC3: LDA LENGTH ; UPDATE PC BY LEN
  JSR PCADJ3
  STY PCH
  CLC
  BCC NEWPCL
XJSR: CLC
  JSR PCADJ2 ; UPDATE PC AND PUSH
  TAX ; ONTO STACH FOR
  TYA ; JSR SIMULATE
  PHA
  TXA
  PHA
  LDY #$02
XJMP: CLC
XJMPAT: LDA (PCL),Y
  TAX ; LOAD PC FOR JMP,
  DEY ; (JMP) SIMULATE.
  LDA (PCL),Y
  STX PCH
NEWPCL: STA PCL
  BCS XJMP
RTNJMP: LDA RTNH
  PHA
  LDA RTNL
  PHA
REGDSP: JSR CROUT ; DISPLAY USER REG
RGDSP1: LDA #ACC ; CONTENTS WITH
  STA A3L ; LABELS
  LDA #ACC/256
  STA A3H
  LDX #$FB
RDSP1: LDA #$A0
  JSR COUT
  LDA RTBL-$FB,X
  JSR COUT
  LDA #$BD
  JSR COUT
  LDA ACC+5,X
  JSR PRBYTE
  INX
  BMI RDSP1
  RTS
BRANCH: CLC ; BRANCH TAKEN,
  LDY #$01 ; ADD LEN+2 TO PC
  LDA (PCL),Y
FB02: 20 56 F9 JSR PCADJ3
FB05: 85 3A STA PCL
FB07: 98 TYA
FB08: 38 SEC
FB09: B0 A2 BCS PCINC2
FB0B: 20 4A FF NBRNCH JSR SAVE NORMAL RETURN AFTER
FB0E: 38 SEC XEQ USER OF
FB0F: B0 9E BCS PCINC3 GO UPDATE PC
FB11: EA INITBL NOP
FB12: EA NOP DUMMY FILL FOR
FB13: 4C 0B FB JMP NBRNCH XEQ AREA
FB16: 4C FD FA JMP BRANCH
FB19: C1 RTBL .BYTE $C1
FB1A: D8 .BYTE $D8
FB1B: D9 .BYTE $D9
FB1C: D0 .BYTE $D0
FB1D: D3 .BYTE $D3
FB1E: AD 70 C0 PREAD LDA PTRIG TRIGGER PADDLES
FB21: A0 00 LDY #$00 INIT COUNT
FB23: EA NOP COMPENSATE FOR 1ST COUNT
FB24: EA NOP
FB25: BD 64 C0 PREAD2 LDA PADDL0,X COUNT Y-REG EVERY
FB28: 10 04 BPL RTS2D 12 USEC
FB2A: C8 INY
FB2B: D0 F8 BNE PREAD2 EXIT AT 255 MAX
FB2D: 88 DEY
FB2E: 60 RTS2D RTS
FB2F: A9 00 INIT LDA #$00 CLR STATUS FOR DEBUG
FB31: 85 48 STA STATUS SOFTWARE
FB33: AD 56 C0 LDA LORES
FB36: AD 54 C0 LDA LOWSCR INIT VIDEO MODE
FB39: AD 51 C0 SETTXT LDA TXTSET SET FOR TEXT MODE
FB3C: A9 00 LDA #$00 FULL SCREEN WINDOW
FB3E: F0 0B BEQ SETWND
FB40: AD 50 C0 SETGR LDA TXTCLR SET FOR GRAPHICS MODE
FB43: AD 53 C0 LDA MIXSET LOWER 4 LINES AS
FB46: 20 36 F8 JSR CLRTOP TEXT WINDOW
FB49: A9 14 LDA #$14
FB4B: 85 22 SETWND STA WNDTOP SET FOR 40 COL WINDOW
FB4D: A9 00 LDA #$00 TOP IN A-REG,
FB4F: 85 20 STA WNDLFT BTTM AT LINE 24
FB51: A9 28 LDA #$28
FB53: 85 21 STA WNDWDTH
FB55: A9 18 LDA #$18
FB57: 85 23 STA WNDBTM VTAB TO ROW 23
FB59: A9 17 LDA #$17
FB5B: 85 25 TABV STA CV VTABS TO ROW IN A-REG
FB5D: 4C 22 FC JMP VTAB
FB60: 20 A4 FB MULPM JSR MD1 ABS VAL OF AC AUX
FB63: A0 10 MUL LDY #$10 INDEX FOR 16 BITS
FB65: A5 50 MUL2 LDA ACL ACX * AUX + XTND
FB67: 4A LSR A TO AC, XTND
FB68: 90 0C BCC MUL4 IF NO CARRY,
FB6A: 18 CLC NO PARTIAL PROD.
FB6B: A2 FE LDX #$FE
FB6D: B5 54 MUL3 LDA XTNDL+2,X ADD MPLCND (AUX)
FB6F: 75 56 ADC AUXL+2,X TO PARTIAL PROD
FB71: 95 54 STA XTNDL+2,X (XTND)
FB73: E8 INX
FB74: D0 F7 BNE MUL3
FB76: A2 03 MUL4 LDX #$03
FB78: 76 MUL5 .BYTE $76
FB79: 50 .BYTE $50
FB7A: CA DEX
FB7B: 10 FB BPL MUL5
FB7D: 88 DEY
FB7E: D0 E5 BNE MUL2
FB80: 60 RTS
FB81: 20 A4 FB DIVPM JSR MD1 ABS VAL OF AC, AUX.
FB84: A0 10 DIV LDY #$10 INDEX FOR 16 BITS
FB86: 06 50 DIV2 ASL ACL
FB88: 26 51 ROL ACH
FB8A: 26 52 ROL XTNDL XTND/AUX
FB8C: 26 53 ROL XTNDH TO AC.
FB8E: 38 SEC
FB8F: A5 52 LDA XTNDL
FB91: E5 54 SBC AUXL MOD TO XTND.
FB93: AA TAX
FB94: A5 53 LDA XTNDH
FB96: E5 55 SBC AUXH
FB98: 90 06 BCC DIV3
FB9A: 86 52 STX XTNDL
FB9C: 85 53 STA XTNDH
FB9E: E6 50 INC ACL
FBA0: 88 DIV3 DEY
FBA1: D0 E3 BNE DIV2
FBA3: 60 RTS
FBA4: A0 00 MD1 LDY #$00 ABS VAL OF AC, AUX
FBA6: 84 2F STY SIGN WITH RESULT SIGN
FBA8: A2 54 LDX #AUXL IN LSB OF SIGN.
FBAA: 20 AF FB JSR MD3
FBAD: A2 50 LDX #ACL
FBAF: B5 01 MD3 LDA LOC1,X X SPECIFIES AC OR AUX
FBB1: 10 0D BPL MDRTS
FBB3: 38 SEC
FBB4: 98 TYA
FBB5: F5 00 SBC LOC0,X COMPL SPECIFIED REG
FBB7: 95 00 STA LOC0,X IF NEG.
FBB9: 98 TYA
FBBA: F5 01 SBC LOC1,X
FBBC: 95 01 STA LOC1,X
FBBE: E6 2F INC SIGN
FBC0: 60 MDRTS RTS
FBC1: 48 BASCALC PHA CALC BASE ADR IN BASL,H
FBC2: 4A LSR A FOR GIVEN LINE NO
FBC3: 29 03 AND #$03 0&lt=LINE NO.&lt=$17
FBC5: 09 04 ORA #$04 ARG=000ABCDE, GENERATE
FBC7: 85 29 STA BASH BASH=000001CD
FBC9: 68 PLA AND
FBCA: 29 18 AND #$18 BASL=EABAB000
FBCC: 90 02 BCC BSCLC2
FBCE: 69 7F ADC #$7F
FBD0: 85 28 BSCLC2 STA BASL
FBD2: 0A ASL
FBD3: 0A ASL
FBD4: 05 28 ORA BASL
FBD6: 85 28 STA BASL
FBD8: 60 RTS
FBD9: C9 87 BELL1 CMP #$87 BELL CHAR? (CNTRL-G)
FBDB: D0 12 BNE RTS2B NO, RETURN
FBDD: A9 40 LDA #$40 DELAY .01 SECONDS
FBDF: 20 A8 FC JSR WAIT
FBE2: A0 C0 LDY #$C0
FBE4: A9 0C BELL2 LDA #$0C TOGGLE SPEAKER AT
FBE6: 20 A8 FC JSR WAIT 1 KHZ FOR .1 SEC.
FBE9: AD 30 C0 LDA SPKR
FBEC: 88 DEY
FBED: D0 F5 BNE BELL2
FBEF: 60 RTS2B RTS
FBF0: A4 24 STOADV LDY CH CURSOR H INDEX TO Y-REG
FBF2: 91 28 STA (BASL),Y STORE CHAR IN LINE
FBF4: E6 24 ADVANCE INC CH INCREMENT CURSOR H INDEX
FBF6: A5 24 LDA CH (MOVE RIGHT)
FBF8: C5 21 CMP WNDWDTH BEYOND WINDOW WIDTH?
FBFA: B0 66 BCS CR YES CR TO NEXT LINE
FBFC: 60 RTS3 RTS NO,RETURN
FBFD: C9 A0 VIDOUT CMP #$A0 CONTROL CHAR?
FBFF: B0 EF BCS STOADV NO,OUTPUT IT.
FC01: A8 TAY INVERSE VIDEO?
FC02: 10 EC BPL STOADV YES, OUTPUT IT.
FC04: C9 8D CMP #$8D CR?
FC06: F0 5A BEQ CR YES.
FC08: C9 8A CMP #$8A LINE FEED?
FC0A: F0 5A BEQ LF IF SO, DO IT.
FC0C: C9 88 CMP #$88 BACK SPACE? (CNTRL-H)
FC0E: D0 C9 BNE BELL1 NO, CHECK FOR BELL.
FC10: C6 24 BS DEC CH DECREMENT CURSOR H INDEX
FC12: 10 E8 BPL RTS3 IF POS, OK. ELSE MOVE UP
FC14: A5 21 LDA WNDWDTH SET CH TO WNDWDTH-1
FC16: 85 24 STA CH
FC18: C6 24 DEC CH (RIGHTMOST SCREEN POS)
FC1A: A5 22 UP LDA WNDTOP CURSOR V INDEX
FC1C: C5 25 CMP CV
FC1E: B0 0B BCS RTS4 IF TOP LINE THEN RETURN
FC20: C6 25 DEC CV DEC CURSOR V-INDEX
FC22: A5 25 VTAB LDA CV GET CURSOR V-INDEX
FC24: 20 C1 FB VTABZ JSR BASCALC GENERATE BASE ADR
FC27: 65 20 ADC WNDLFT ADD WINDOW LEFT INDEX
FC29: 85 28 STA BASL TO BASL
FC2B: 60 RTS4 RTS
FC2C: 49 C0 ESC1 EOR #$C0 ESC?
FC2E: F0 28 BEQ HOME IF SO, DO HOME AND CLEAR
FC30: 69 FD ADC #$FD ESC-A OR B CHECK
FC32: 90 C0 BCC ADVANCE A, ADVANCE
FC34: F0 DA BEQ BS B, BACKSPACE
FC36: 69 FD ADC #$FD ESC-C OR D CHECK
FC38: 90 2C BCC LF C, DOWN
FC3A: F0 DE BEQ UP D, GO UP
FC3C: 69 FD ADC #$FD ESC-E OR F CHECK
FC3E: 90 5C BCC CLREOL E, CLEAR TO END OF LINE
FC40: D0 E9 BNE RTS4 NOT F, RETURN
FC42: A4 24 CLREOP LDY CH CURSOR H TO Y INDEX
FC44: A5 25 LDA CV CURSOR V TO A-REGISTER
FC46: 48 CLEOP1 PHA SAVE CURRENT LINE ON STK
FC47: 20 24 FC JSR VTABZ CALC BASE ADDRESS
FC4A: 20 9E FC JSR CLEOLZ CLEAR TO EOL, SET CARRY
FC4D: A0 00 LDY #$00 CLEAR FROM H INDEX=0 FOR REST
FC4F: 68 PLA INCREMENT CURRENT LINE
FC50: 69 00 ADC #$00 (CARRY IS SET)
FC52: C5 23 CMP WNDBTM DONE TO BOTTOM OF WINDOW?
FC54: 90 F0 BCC CLEOP1 NO, KEEP CLEARING LINES
FC56: B0 CA BCS VTAB YES, TAB TO CURRENT LINE
FC58: A5 22 HOME LDA WNDTOP INIT CURSOR V
FC5A: 85 25 STA CV AND H-INDICES
FC5C: A0 00 LDY #$00
FC5E: 84 24 STY CH THEN CLEAR TO END OF PAGE
FC60: F0 E4 BEQ CLEOP1
FC62: A9 00 CR LDA #$00 CURSOR TO LEFT OF INDEX
FC64: 85 24 STA CH (RET CURSOR H=0)
FC66: E6 25 LF INC CV INCR CURSOR V(DOWN 1 LINE)
FC68: A5 25 LDA CV
FC6A: C5 23 CMP WNDBTM OFF SCREEN?
FC6C: 90 B6 BCC VTABZ NO, SET BASE ADDR
FC6E: C6 25 DEC CV DECR CURSOR V (BACK TO BOTTOM)
FC70: A5 22 SCROLL LDA WNDTOP START AT TOP OF SCRL WNDW
FC72: 48 PHA
FC73: 20 24 FC JSR VTABZ GENERATE BASE ADR
FC76: A5 28 SCRL1 LDA BASL COPY BASL,H
FC78: 85 2A STA BAS2L TO BAS2L,H
FC7A: A5 29 LDA BASH
FC7C: 85 2B STA BAS2H
FC7E: A4 21 LDY WNDWDTH INIT Y TO RIGHTMOST INDEX
FC80: 88 DEY OF SCROLLING WINDOW
FC81: 68 PLA
FC82: 69 01 ADC #$01 INCR LINE NUMBER
FC84: C5 23 CMP WNDBTM DONE?
FC86: B0 0D BCS SCRL3 YES, FINISH
FC88: 48 PHA
FC89: 20 24 FC JSR VTABZ FORM BASL,H (BASE ADDR)
FC8C: B1 28 SCRL2 LDA (BASL),Y MOVE A CHR UP ON LINE
FC8E: 91 2A STA (BAS2L),Y
FC90: 88 DEY NEXT CHAR OF LINE
FC91: 10 F9 BPL SCRL2
FC93: 30 E1 BMI SCRL1 NEXT LINE (ALWAYS TAKEN)
FC95: A0 00 SCRL3 LDY #$00 CLEAR BOTTOM LINE
FC97: 20 9E FC JSR CLEOLZ GET BASE ADDR FOR BOTTOM LINE
FC9A: B0 86 BCS VTAB CARRY IS SET
FC9C: A4 24 CLREOL LDY CH CURSOR H INDEX
FC9E: A9 A0 CLEOLZ LDA #$A0
FCA0: 91 28 CLEOL2 STA (BASL),Y STORE BLANKS FROM 'HERE'
FCA2: C8 INY TO END OF LINES (WNDWDTH)
FCA3: C4 21 CPY WNDWDTH
FCA5: 90 F9 BCC CLEOL2
FCA7: 60 RTS
FCA8: 38 WAIT SEC
FCA9: 48 WAIT2 PHA
FCAA: E9 01 WAIT3 SBC #$01
FCAC: D0 FC BNE WAIT3 1.0204 USEC
FCAE: 68 PLA (13+27/2*A+5/2*A*A)
FCAF: E9 01 SBC #$01
FCB1: D0 F6 BNE WAIT2
FCB3: 60 RTS
FCB4: E6 42 NXTA4 INC A4L INCR 2-BYTE A4
FCB6: D0 02 BNE NXTA1 AND A1
FCB8: E6 43 INC A4H
FCBA: A5 3C NXTA1 LDA A1L INCR 2-BYTE A1.
FCBC: C5 3E CMP A2L
FCBE: A5 3D LDA A1H AND COMPARE TO A2
FCC0: E5 3F SBC A2H
FCC2: E6 3C INC A1L (CARRY SET IF &gt=)
FCC4: D0 02 BNE RTS4B
FCC6: E6 3D INC A1H
FCC8: 60 RTS4B RTS
FCC9: A0 4B HEADR LDY #$4B WRITE A*256 'LONG 1'
FCCB: 20 DB FC JSR ZERDLY HALF CYCLES
FCCE: D0 F9 BNE HEADR (650 USEC EACH)
FCD0: 69 FE ADC #$FE
FCD2: B0 F5 BCS HEADR THEN A 'SHORT 0'
FCD4: A0 21 LDY #$21 (400 USEC)
FCD6: 20 DB FC WRBIT JSR ZERDLY WRITE TWO HALF CYCLES
FCD9: C8 INY OF 250 USEC ('0')
FCDA: C8 INY OR 500 USEC ('0')
FCDB: 88 ZERDLY DEY
FCDC: D0 FD BNE ZERDLY
FCDE: 90 05 BCC WRTAPE Y IS COUNT FOR
FCE0: A0 32 LDY #$32 TIMING LOOP
FCE2: 88 ONEDLY DEY
FCE3: D0 FD BNE ONEDLY
FCE5: AC 20 C0 WRTAPE LDY TAPEOUT
FCE8: A0 2C LDY #$2C
FCEA: CA DEX
FCEB: 60 RTS
FCEC: A2 08 RDBYTE LDX #$08 8 BITS TO READ
FCEE: 48 RDBYT2 PHA READ TWO TRANSITIONS
FCEF: 20 FA FC JSR RD2BIT (FIND EDGE)
FCF2: 68 PLA
FCF3: 2A ROL NEXT BIT
FCF4: A0 3A LDY #$3A COUNT FOR SAMPLES
FCF6: CA DEX
FCF7: D0 F5 BNE RDBYT2
FCF9: 60 RTS
FCFA: 20 FD FC RD2BIT JSR RDBIT
FCFD: 88 RDBIT DEY DECR Y UNTIL
FCFE: AD 60 C0 LDA TAPEIN TAPE TRANSITION
FD01: 45 2F EOR LASTIN
FD03: 10 F8 BPL RDBIT
FD05: 45 2F EOR LASTIN
FD07: 85 2F STA LASTIN
FD09: C0 80 CPY #$80 SET CARRY ON Y
FD0B: 60 RTS
FD0C: A4 24 RDKEY LDY CH
FD0E: B1 28 LDA (BASL),Y SET SCREEN TO FLASH
FD10: 48 PHA
FD11: 29 3F AND #$3F
FD13: 09 40 ORA #$40
FD15: 91 28 STA (BASL),Y
FD17: 68 PLA
FD18: 6C 38 00 JMP (KSWL) GO TO USER KEY-IN
FD1B: E6 4E KEYIN INC RNDL
FD1D: D0 02 BNE KEYIN2 INCR RND NUMBER
FD1F: E6 4F INC RNDH
FD21: 2C 00 C0 KEYIN2 BIT KBD KEY DOWN?
FD24: 10 F5 BPL KEYIN LOOP
FD26: 91 28 STA (BASL),Y REPLACE FLASHING SCREEN
FD28: AD 00 C0 LDA KBD GET KEYCODE
FD2B: 2C 10 C0 BIT KBDSTRB CLR KEY STROBE
FD2E: 60 RTS
FD2F: 20 0C FD ESC JSR RDKEY GET KEYCODE
FD32: 20 2C FC JSR ESC1 HANDLE ESC FUNC.
FD35: 20 0C FD RDCHAR JSR RDKEY READ KEY
FD38: C9 9B CMP #$9B ESC?
FD3A: F0 F3 BEQ ESC YES, DON'T RETURN
FD3C: 60 RTS
FD3D: A5 32 NOTCR LDA INVFLG
FD3F: 48 PHA
FD40: A9 FF LDA #$FF
FD42: 85 32 STA INVFLG ECHO USER LINE
FD44: BD 00 02 LDA IN,X NON INVERSE
FD47: 20 ED FD JSR COUT
FD4A: 68 PLA
FD4B: 85 32 STA INVFLG
FD4D: BD 00 02 LDA IN,X
FD50: C9 88 CMP #$88 CHECK FOR EDIT KEYS
FD52: F0 1D BEQ BCKSPC BS, CTRL-X
FD54: C9 98 CMP #$98
FD56: F0 0A BEQ CANCEL
FD58: E0 F8 CPX #$F8 MARGIN?
FD5A: 90 03 BCC NOTCR1
FD5C: 20 3A FF JSR BELL YES, SOUND BELL
FD5F: E8 NOTCR1 INX ADVANCE INPUT INDEX
FD60: D0 13 BNE NXTCHAR
FD62: A9 DC CANCEL LDA #$DC BACKSLASH AFTER CANCELLED LINE
FD64: 20 ED FD JSR COUT
FD67: 20 8E FD GETLNZ JSR CROUT OUTPUT CR
FD6A: A5 33 GETLN LDA PROMPT
FD6C: 20 ED FD JSR COUT OUTPUT PROMPT CHAR
FD6F: A2 01 LDX #$01 INIT INPUT INDEX
FD71: 8A BCKSPC TXA WILL BACKSPACE TO 0
FD72: F0 F3 BEQ GETLNZ
FD74: CA DEX
FD75: 20 35 FD NXTCHAR JSR RDCHAR
FD78: C9 95 CMP #PICK USE SCREEN CHAR
FD7A: D0 02 BNE CAPTST FOR CTRL-U
FD7C: B1 28 LDA (BASL),Y
FD7E: C9 E0 CAPTST CMP #$E0
FD80: 90 02 BCC ADDINP CONVERT TO CAPS
FD82: 29 DF AND #$DF
FD84: 9D 00 02 ADDINP STA IN,X ADD TO INPUT BUF
FD87: C9 8D CMP #$8D
FD89: D0 B2 BNE NOTCR
FD8B: 20 9C FC JSR CLREOL CLR TO EOL IF CR
FD8E: A9 8D CROUT LDA #$8D
FD90: D0 5B BNE COUT
FD92: A4 3D PRA1 LDY A1H PRINT CR,A1 IN HEX
FD94: A6 3C LDX A1L
FD96: 20 8E FD PRYX2 JSR CROUT
FD99: 20 40 F9 JSR PRNTYX
FD9C: A0 00 LDY #$00
FD9E: A9 AD LDA #$AD PRINT '-'
FDA0: 4C ED FD JMP COUT
FDA3: A5 3C XAM8 LDA A1L
FDA5: 09 07 ORA #$07 SET TO FINISH AT
FDA7: 85 3E STA A2L MOD 8=7
FDA9: A5 3D LDA A1H
FDAB: 85 3F STA A2H
FDAD: A5 3C MODSCHK LDA A1L
FDAF: 29 07 AND #$07
FDB1: D0 03 BNE DATAOUT
FDB3: 20 92 FD XAM JSR PRA1
FDB6: A9 A0 DATAOUT LDA #$A0
FDB8: 20 ED FD JSR COUT OUTPUT BLANK
FDBB: B1 3C LDA (A1L),Y
FDBD: 20 DA FD JSR PRBYTE OUTPUT BYTE IN HEX
FDC0: 20 BA FC JSR NXTA1
FDC3: 90 E8 BCC MODSCHK CHECK IF TIME TO,
FDC5: 60 RTS4C RTS PRINT ADDR
FDC6: 4A XAMPM LSR A DETERMINE IF MON
FDC7: 90 EA BCC XAM MODE IS XAM
FDC9: 4A LSR A ADD, OR SUB
FDCA: 4A LSR A
FDCB: A5 3E LDA A2L
FDCD: 90 02 BCC ADD
FDCF: 49 FF EOR #$FF SUB: FORM 2'S COMPLEMENT
FDD1: 65 3C ADD ADC A1L
FDD3: 48 PHA
FDD4: A9 BD LDA #$BD
FDD6: 20 ED FD JSR COUT PRINT '=', THEN RESULT
FDD9: 68 PLA
FDDA: 48 PRBYTE PHA PRINT BYTE AS 2 HEX
FDDB: 4A LSR A DIGITS, DESTROYS A-REG
FDDC: 4A LSR A
FDDD: 4A LSR A
FDDE: 4A LSR A
FDDF: 20 E5 FD JSR PRHEXZ
FDE2: 68 PLA
FDE3: 29 0F PRHEX AND #$0F PRINT HEX DIG IN A-REG
FDE5: 09 B0 PRHEXZ ORA #$B0 LSB'S
FDE7: C9 BA CMP #$BA
FDE9: 90 02 BCC COUT
FDEB: 69 06 ADC #$06
FDED: 6C 36 00 COUT JMP (CSWL) VECTOR TO USER OUTPUT ROUTINE
FDF0: C9 A0 COUT1 CMP #$A0
FDF2: 90 02 BCC COUTZ DON'T OUTPUT CTRL'S INVERSE
FDF4: 25 32 AND INVFLG MASK WITH INVERSE FLAG
FDF6: 84 35 COUTZ STY YSAV1 SAV Y-REG
FDF8: 48 PHA SAV A-REG
FDF9: 20 FD FB JSR VIDOUT OUTPUT A-REG AS ASCII
FDFC: 68 PLA RESTORE A-REG
FDFD: A4 35 LDY YSAV1 AND Y-REG
FDFF: 60 RTS THEN RETURN
FE00: C6 34 BL1 DEC YSAV
FE02: F0 9F BEQ XAM8
FE04: CA BLANK DEX BLANK TO MON
FE05: D0 16 BNE SETMDZ AFTER BLANK
FE07: C9 BA CMP #$BA DATA STORE MODE?
FE09: D0 BB BNE XAMPM NO, XAM, ADD, OR SUB
FE0B: 85 31 STOR STA MODE KEEP IN STORE MODE
FE0D: A5 3E LDA A2L
FE0F: 91 40 STA (A3L),Y STORE AS LOW BYTE AS (A3)
FE11: E6 40 INC A3L
FE13: D0 02 BNE RTS5 INCR A3, RETURN
FE15: E6 41 INC A3H
FE17: 60 RTS5 RTS
FE18: A4 34 SETMODE LDY YSAV SAVE CONVERTED ':', '+',
FE1A: B9 FF 01 LDA IN-1,Y '-', '.' AS MODE.
FE1D: 85 31 SETMDZ STA MODE
FE1F: 60 RTS
FE20: A2 01 LT LDX #$01
FE22: B5 3E LT2 LDA A2L,X COPY A2 (2 BYTES) TO
FE24: 95 42 STA A4L,X A4 AND A5
FE26: 95 44 STA A5L,X
FE28: CA DEX
FE29: 10 F7 BPL LT2
FE2B: 60 RTS
FE2C: B1 3C MOVE LDA (A1L),Y MOVE (A1 TO A2) TO
FE2E: 91 42 STA (A4L),Y (A4)
FE30: 20 B4 FC JSR NXTA4
FE33: 90 F7 BCC MOVE
FE35: 60 RTS
FE36: B1 3C VFY LDA (A1L),Y VERIFY (A1 TO A2) WITH
FE38: D1 42 CMP (A4L),Y (A4)
FE3A: F0 1C BEQ VFYOK
FE3C: 20 92 FD JSR PRA1
FE3F: B1 3C LDA (A1L),Y
FE41: 20 DA FD JSR PRBYTE
FE44: A9 A0 LDA #$A0
FE46: 20 ED FD JSR COUT
FE49: A9 A8 LDA #$A8
FE4B: 20 ED FD JSR COUT
FE4E: B1 42 LDA (A4L),Y
FE50: 20 DA FD JSR PRBYTE
FE53: A9 A9 LDA #$A9
FE55: 20 ED FD JSR COUT
FE58: 20 B4 FC VFYOK JSR NXTA4
FE5B: 90 D9 BCC VFY
FE5D: 60 RTS
FE5E: 20 75 FE LIST JSR A1PC MOVE A1 (2 BYTES) TO
FE61: A9 14 LDA #$14 PC IF SPEC'D AND
FE63: 48 LIST2 PHA DISEMBLE 20 INSTRS
FE64: 20 D0 F8 JSR INSTDSP
FE67: 20 53 F9 JSR PCADJ ADJUST PC EACH INSTR
FE6A: 85 3A STA PCL
FE6C: 84 3B STY PCH
FE6E: 68 PLA
FE6F: 38 SEC
FE70: E9 01 SBC #$01 NEXT OF 20 INSTRS
FE72: D0 EF BNE LIST2
FE74: 60 RTS
FE75: 8A A1PC TXA IF USER SPEC'D ADR
FE76: F0 07 BEQ A1PCRTS COPY FROM A1 TO PC
FE78: B5 3C A1PCLP LDA A1L,X
FE7A: 95 3A STA PCL,X
FE7C: CA DEX
FE7D: 10 F9 BPL A1PCLP
FE7F: 60 A1PCRTS RTS
FE80: A0 3F SETINV LDY #$3F SET FOR INVERSE VID
FE82: D0 02 BNE SETIFLG VIA COUT1
FE84: A0 FF SETNORM LDY #$FF SET FOR NORMAL VID
FE86: 84 32 SETIFLG STY INVFLG
FE88: 60 RTS
FE89: A9 00 SETKBD LDA #$00 SIMULATE PORT #0 INPUT
FE8B: 85 3E INPORT STA A2L SPECIFIED (KEYIN ROUTINE)
FE8D: A2 38 INPRT LDX #KSWL
FE8F: A0 1B LDY #KEYIN
FE91: D0 08 BNE IOPRT
FE93: A9 00 SETVID LDA #$00 SIMULATE PORT #0 OUTPUT
FE95: 85 3E OUTPORT STA A2L SPECIFIED (COUT1 ROUTINE)
FE97: A2 36 OUTPRT LDX #CSWL
FE99: A0 F0 LDY #COUT1
FE9B: A5 3E IOPRT LDA A2L SET RAM IN/OUT VECTORS
FE9D: 29 0F AND #$0F
FE9F: F0 06 BEQ IOPRT1
FEA1: 09 C0 ORA #IOADR/256
FEA3: A0 00 LDY #$00
FEA5: F0 02 BEQ IOPRT2
FEA7: A9 FD IOPRT1 LDA #COUT1/256
FEA9: 94 00 IOPRT2 STY LOC0,X
FEAB: 95 01 STA LOC1,X
FEAD: 60 RTS
FEAE: EA NOP
FEAF: EA NOP
FEB0: 4C 00 E0 XBASIC JMP BASIC TO BASIC WITH SCRATCH
FEB3: 4C 03 E0 BASCONT JMP BASIC2 CONTINUE BASIC
FEB6: 20 75 FE GO JSR A1PC ADR TO PC IF SPEC'D
FEB9: 20 3F FF JSR RESTORE RESTORE META REGS
FEBC: 6C 3A 00 JMP (PCL) GO TO USER SUBR
FEBF: 4C D7 FA REGZ JMP REGDSP TO REG DISPLAY
FEC2: C6 34 TRACE DEC YSAV
FEC4: 20 75 FE STEPZ JSR A1PC ADR TO PC IF SPEC'D
FEC7: 4C 43 FA JMP STEP TAKE ONE STEP
FECA: 4C F8 03 USR JMP USRADR TO USR SUBR AT USRADR
FECD: A9 40 WRITE LDA #$40
FECF: 20 C9 FC JSR HEADR WRITE 10-SEC HEADER
FED2: A0 27 LDY #$27
FED4: A2 00 WR1 LDX #$00
FED6: 41 3C EOR (A1L,X)
FED8: 48 PHA
FED9: A1 3C LDA (A1L,X)
FEDB: 20 ED FE JSR WRBYTE
FEDE: 20 BA FC JSR NXTA1
FEE1: A0 1D LDY #$1D
FEE3: 68 PLA
FEE4: 90 EE BCC WR1
FEE6: A0 22 LDY #$22
FEE8: 20 ED FE JSR WRBYTE
FEEB: F0 4D BEQ BELL
FEED: A2 10 WRBYTE LDX #$10
FEEF: 0A WRBYT2 ASL A
FEF0: 20 D6 FC JSR WRBIT
FEF3: D0 FA BNE WRBYT2
FEF5: 60 RTS
FEF6: 20 00 FE CRMON JSR BL1 HANDLE A CR AS BLANK
FEF9: 68 PLA THEN POP STACK
FEFA: 68 PLA AND RTN TO MON
FEFB: D0 6C BNE MONZ
FEFD: 20 FA FC READ JSR RD2BIT FIND TAPEIN EDGE
FF00: A9 16 LDA #$16
FF02: 20 C9 FC JSR HEADR DELAY 3.5 SECONDS
FF05: 85 2E STA CHKSUM INIT CHKSUM=$FF
FF07: 20 FA FC JSR RD2BIT FIND TAPEIN EDGE
FF0A: A0 24 RD2 LDY #$24 LOOK FOR SYNC BIT
FF0C: 20 FD FC JSR RDBIT (SHORT 0)
FF0F: B0 F9 BCS RD2 LOOP UNTIL FOUND
FF11: 20 FD FC JSR RDBIT SKIP SECOND SYNC H-CYCLE
FF14: A0 3B LDY #$3B INDEX FOR 0/1 TEST
FF16: 20 EC FC RD3 JSR RDBYTE READ A BYTE
FF19: 81 3C STA (A1L,X) STORE AT (A1)
FF1B: 45 2E EOR CHKSUM
FF1D: 85 2E STA CHKSUM UPDATE RUNNING CHKSUM
FF1F: 20 BA FC JSR NXTA1 INC A1, COMPARE TO A2
FF22: A0 35 LDY #$35 COMPENSATE 0/1 INDEX
FF24: 90 F0 BCC RD3 LOOP UNTIL DONE
FF26: 20 EC FC JSR RDBYTE READ CHKSUM BYTE
FF29: C5 2E CMP CHKSUM
FF2B: F0 0D BEQ BELL GOOD, SOUND BELL AND RETURN
FF2D: A9 C5 PRERR LDA #$C5
FF2F: 20 ED FD JSR COUT PRINT "ERR", THEN BELL
FF32: A9 D2 LDA #$D2
FF34: 20 ED FD JSR COUT
FF37: 20 ED FD JSR COUT
FF3A: A9 87 BELL LDA #$87 OUTPUT BELL AND RETURN
FF3C: 4C ED FD JMP COUT
FF3F: A5 48 RESTORE LDA STATUS RESTORE 6502 REG CONTENTS
FF41: 48 PHA USED BY DEBUG SOFTWARE
FF42: A5 45 LDA ACC
FF44: A6 46 RESTR1 LDX XREG
FF46: A4 47 LDY YREG
FF48: 28 PLP
FF49: 60 RTS
FF4A: 85 45 SAVE STA ACC SAVE 6502 REG CONTENTS
FF4C: 86 46 SAV1 STX XREG
FF4E: 84 47 STY YREG
FF50: 08 PHP
FF51: 68 PLA
FF52: 85 48 STA STATUS
FF54: BA TSX
FF55: 86 49 STX SPNT
FF57: D8 CLD
FF58: 60 RTS
FF59: 20 84 FE RESET JSR SETNORM SET SCREEN MODE
FF5C: 20 2F FB JSR INIT AND INIT KBD/SCREEN
FF5F: 20 93 FE JSR SETVID AS I/O DEV'S
FF62: 20 89 FE JSR SETKBD
FF65: D8 MON CLD MUST SET HEX MODE!
FF66: 20 3A FF JSR BELL
FF69: A9 AA MONZ LDA #$AA '*' PROMPT FOR MON
FF6B: 85 33 STA PROMPT
FF6D: 20 67 FD JSR GETLNZ READ A LINE
FF70: 20 C7 FF JSR ZMODE CLEAR MON MODE, SCAN IDX
FF73: 20 A7 FF NXTITM JSR GETNUM GET ITEM, NON-HEX
FF76: 84 34 STY YSAV CHAR IN A-REG
FF78: A0 17 LDY #$17 X-REG=0 IF NO HEX INPUT
FF7A: 88 CHRSRCH DEY
FF7B: 30 E8 BMI MON NOT FOUND, GO TO MON
FF7D: D9 CC FF CMP CHRTBL,Y FIND CMND CHAR IN TEL
FF80: D0 F8 BNE CHRSRCH
FF82: 20 BE FF JSR TOSUB FOUND, CALL CORRESPONDING
FF85: A4 34 LDY YSAV SUBROUTINE
FF87: 4C 73 FF JMP NXTITM
FF8A: A2 03 DIG LDX #$03
FF8C: 0A ASL A
FF8D: 0A ASL A GOT HEX DIG,
FF8E: 0A ASL A SHIFT INTO A2
FF8F: 0A ASL A
FF90: 0A NXTBIT ASL A
FF91: 26 3E ROL A2L
FF93: 26 3F ROL A2H
FF95: CA DEX LEAVE X=$FF IF DIG
FF96: 10 F8 BPL NXTBIT
FF98: A5 31 NXTBAS LDA MODE
FF9A: D0 06 BNE NXTBS2 IF MODE IS ZERO
FF9C: B5 3F LDA A2H,X THEN COPY A2 TO
FF9E: 95 3D STA A1H,X A1 AND A3
FFA0: 95 41 STA A3H,X
FFA2: E8 NXTBS2 INX
FFA3: F0 F3 BEQ NXTBAS
FFA5: D0 06 BNE NXTCHR
FFA7: A2 00 GETNUM LDX #$00 CLEAR A2
FFA9: 86 3E STX A2L
FFAB: 86 3F STX A2H
FFAD: B9 00 02 NXTCHR LDA IN,Y GET CHAR
FFB0: C8 INY
FFB1: 49 B0 EOR #$B0
FFB3: C9 0A CMP #$0A
FFB5: 90 D3 BCC DIG IF HEX DIG, THEN
FFB7: 69 88 ADC #$88
FFB9: C9 FA CMP #$FA
FFBB: B0 CD BCS DIG
FFBD: 60 RTS
FFBE: A9 FE TOSUB LDA #GO/256 PUSH HIGH-ORDER
FFC0: 48 PHA SUBR ADR ON STK
FFC1: B9 E3 FF LDA SUBTBL,Y PUSH LOW-ORDER
FFC4: 48 PHA SUBR ADR ON STK
FFC5: A5 31 LDA MODE
FFC7: A0 00 ZMODE LDY #$00 CLR MODE, OLD MODE
FFC9: 84 31 STY MODE TO A-REG
FFCB: 60 RTS GO TO SUBR VIA RTS
FFCC: BC CHRTBL .BYTE $BC F("CTRL-C")
FFCD: B2 .BYTE $B2 F("CTRL-Y")
FFCE: BE .BYTE $BE F("CTRL-E")
FFCF: ED .BYTE $ED F("T")
FFD0: EF .BYTE $EF F("V")
FFD1: C4 .BYTE $C4 F("CTRL-K")
FFD2: EC .BYTE $EC F("S")
FFD3: A9 .BYTE $A9 F("CTRL-P")
FFD4: BB .BYTE $BB F("CTRL-B")
FFD5: A6 .BYTE $A6 F("-")
FFD6: A4 .BYTE $A4 F("+")
FFD7: 06 .BYTE $06 F("M") (F=EX-OR $B0+$89)
FFD8: 95 .BYTE $95 F("&lt")
FFD9: 07 .BYTE $07 F("N")
FFDA: 02 .BYTE $02 F("I")
FFDB: 05 .BYTE $05 F("L")
FFDC: F0 .BYTE $F0 F("W")
FFDD: 00 .BYTE $00 F("G")
FFDE: EB .BYTE $EB F("R")
FFDF: 93 .BYTE $93 F(":")
FFE0: A7 .BYTE $A7 F(".")
FFE1: C6 .BYTE $C6 F("CR")
FFE2: 99 .BYTE $99 F(BLANK)
FFE3: B2 SUBTBL .BYTE BASCONT-1
FFE4: C9 .BYTE USR-1
FFE5: BE .BYTE REGZ-1
FFE6: C1 .BYTE TRACE-1
FFE7: 35 .BYTE VFY-1
.BYTE INPRT-1
.BYTE STEPZ-1
.BYTE OUTPRT-1
.BYTE XBASIC-1
.BYTE SETMODE-1
.BYTE SETMODE-1
.BYTE MOVE-1
.BYTE LT-1
.BYTE SETNORM-1
.BYTE SETINV-1
.BYTE LIST-1
.BYTE WRITE-1
.BYTE GO-1
.BYTE READ-1
.BYTE SETMODE-1
.BYTE SETMODE-1
.BYTE CRMON-1
.BYTE BLANK-1
.BYTE NMI NMI VECTOR
.BYTE NMI/256
.BYTE RESET ; RESET VECTOR
.BYTE RESET/256
.BYTE IRQ ; IRQ VECTOR
.BYTE IRQ/256
XQTNZ = $3C
