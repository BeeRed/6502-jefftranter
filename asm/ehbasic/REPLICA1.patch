diff -u ehbasic.orig/basic.asm ehbasic/basic.asm
--- ehbasic.orig/basic.asm	2012-05-24 21:25:07.000000000 -0400
+++ ehbasic/basic.asm	2012-05-24 21:25:54.000000000 -0400
@@ -419,7 +419,7 @@
 LAB_SKFF		= LAB_STAK+$FF
 					; flushed stack address
 
-ccflag		= $0200	; BASIC CTRL-C flag, 00 = enabled, 01 = dis
+ccflag		= $0300	; BASIC CTRL-C flag, 00 = enabled, 01 = dis
 ccbyte		= ccflag+1	; BASIC CTRL-C byte
 ccnull		= ccbyte+1	; BASIC CTRL-C byte timeout
 
@@ -436,12 +436,12 @@
 					; start of input buffer after IRQ/NMI code
 Ibuffe		= Ibuffs+$47; end of input buffer
 
-Ram_base		= $0300	; start of user RAM (set as needed, should be page aligned)
-Ram_top		= $C000	; end of user RAM+1 (set as needed, should be page aligned)
+Ram_base		= $0400	; start of user RAM (set as needed, should be page aligned)
+Ram_top		= $5000	; end of user RAM+1 (set as needed, should be page aligned)
 
 ; This start can be changed to suit your system
 
-	*=	$C000
+	.org	$5000
 
 ; BASIC cold start entry point
 
@@ -1555,7 +1555,7 @@
 	JMP	LAB_LET		; else go do implied LET
 
 LAB_1609
-	CMP	#[TK_TAB-$80]*2	; compare normalised token * 2 with TAB
+	CMP	#(TK_TAB-$80)*2	; compare normalised token * 2 with TAB
 	BCS	LAB_15D9		; branch if A>=TAB (do syntax error then warm start)
 					; only tokens before TAB can start a line
 	TAY				; copy to index
Only in ehbasic: basic.mon
Only in ehbasic: basic-uppercase.mon
Only in ehbasic: Makefile
diff -u ehbasic.orig/min_mon.asm ehbasic/min_mon.asm
--- ehbasic.orig/min_mon.asm	2012-05-24 21:25:07.000000000 -0400
+++ ehbasic/min_mon.asm	2012-05-24 21:25:54.000000000 -0400
@@ -1,5 +1,6 @@
 
 ; minimal monitor for EhBASIC and 6502 simulator V1.05
+; Modified to support the Replica 1 by Jeff Tranter <tranter@pobox.com>
 
 ; To run EhBASIC on the simulator load and assemble [F7] this file, start the simulator
 ; running [F6] then start the code with the RESET [CTRL][SHIFT]R. Just selecting RUN
@@ -23,7 +24,7 @@
 ; and wait for the user to select [C]old or [W]arm start. nothing else
 ; fits in less than 128 bytes
 
-	*=	$FF80			; pretend this is in a 1/8K ROM
+;	.org	$FF80			; pretend this is in a 1/8K ROM
 
 ; reset vector points here
 
@@ -67,25 +68,52 @@
 LAB_dowarm
 	JMP	LAB_WARM		; do EhBASIC warm start
 
-; byte out to simulated ACIA
+; byte out to Replica 1/Apple 1 screen
 
 ACIAout
-	STA	ACIAsimwr		; save byte to simulated ACIA
+	BIT	$D012
+	BMI	ACIAout
+	STA	$D012
 	RTS
 
-; byte in from simulated ACIA
+; byte in from Replica 1/Apple 1 keyboard
 
 ACIAin
-	LDA	ACIAsimrd		; get byte from simulated ACIA
-	BEQ	LAB_nobyw		; branch if no byte waiting
+	LDA	$D011
+	BPL	LAB_nobyw		; branch if no byte waiting
 
+	LDA	$D010
+	AND	#$7F			; clear high bit
 	SEC				; flag byte received
 	RTS
 
 LAB_nobyw
 	CLC				; flag no byte received
-no_load				; empty load vector for EhBASIC
-no_save				; empty save vector for EhBASIC
+        RTS
+
+; LOAD and SAVE commands will call into CFFA1 flash interface if one
+; is present. Not sure how to determine range of memory to save and
+; load. For now, can save from Ram_base to Ram_top. Future enhancement
+; would be to pass filename on command line and call read/write
+; routines in CFFA1.
+LOAD
+SAVE
+
+; Call CFFA1 flash interface menu
+; The documented way to check for a CFFA1 is to check for two ID bytes.
+; The documentation says it is addresses $AFFC and $AFFD but the firmware
+; actually uses addresses $AFDC and $AFDD. Further, my CFFA1 board did
+; not have these locations programmed even though firmware on CD-ROM did.
+; I manually wrote these bytes to my EEPROM.
+
+        LDA     $AFDC                   ; First CFFA1 ID byte
+        CMP     #$CF                    ; Should contain $CF
+        BNE     NoCFFA1
+        LDA     $AFDD                   ; First CFFA1 ID byte
+        CMP     #$FA                    ; Should contain $FA
+        BNE     NoCFFA1
+        JSR     $9006                   ; Jump to CFFA1 menu, will return when done.
+NoCFFA1
 	RTS
 
 ; vector tables
@@ -93,8 +121,8 @@
 LAB_vec
 	.word	ACIAin		; byte in from simulated ACIA
 	.word	ACIAout		; byte out to simulated ACIA
-	.word	no_load		; null load vector for EhBASIC
-	.word	no_save		; null save vector for EhBASIC
+	.word	LOAD		; load vector for EhBASIC
+	.word	SAVE		; save vector for EhBASIC
 
 ; EhBASIC IRQ support
 
@@ -126,7 +154,7 @@
 
 ; system vectors
 
-	*=	$FFFA
+	.org	$FFFA
 
 	.word	NMI_vec		; NMI vector
 	.word	RES_vec		; RESET vector
Only in ehbasic: NOTES.txt
Only in ehbasic: REPLICA1.patch
Only in ehbasic: source.zip
Only in ehbasic: UPPERCASE.patch
